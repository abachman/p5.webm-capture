{
  "version": 3,
  "sources": ["../src/vendor/download-4.21.js", "../src/vendor/webm-writer-0.3.0/ArrayBufferDataStream.js", "../src/vendor/webm-writer-0.3.0/BlobBuffer.js", "../src/vendor/webm-writer-0.3.0/index.js", "../src/vendor/ccapture-1.0.9.js", "../src/Capturer.ts", "../src/index.ts"],
  "sourcesContent": ["//download.js v4.21, by dandavis; 2008-2018. [MIT] see http://danml.com/download.html for tests/usage\n// v1 landed a FF+Chrome compatible way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime\n// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs\n// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.\n// v4 adds AMD/UMD, commonJS, and plain browser support\n// v4.1 adds url download capability via solo URL argument (same domain/CORS only)\n// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors\n// https://github.com/rndme/download\n\nexport const download = function (data, strFileName, strMimeType) {\n  var self = window, // this script is only for browsers anyway...\n    defaultMime = \"application/octet-stream\", // this default mime also triggers iframe downloads\n    mimeType = strMimeType || defaultMime,\n    payload = data,\n    url = !strFileName && !strMimeType && payload,\n    anchor = document.createElement(\"a\"),\n    toString = function (a) {\n      return String(a);\n    },\n    myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString,\n    fileName = strFileName || \"download\",\n    blob,\n    reader;\n  myBlob = myBlob.call ? myBlob.bind(self) : Blob;\n\n  if (String(this) === \"true\") {\n    //reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\n    payload = [payload, mimeType];\n    mimeType = payload[0];\n    payload = payload[1];\n  }\n\n  if (url && url.length < 2048) {\n    // if no filename and no mime, assume a url was passed as the only argument\n    fileName = url.split(\"/\").pop().split(\"?\")[0];\n    anchor.href = url; // assign href prop to temp anchor\n    if (anchor.href.indexOf(url) !== -1) {\n      // if the browser determines that it's a potentially valid url path:\n      var ajax = new XMLHttpRequest();\n      ajax.open(\"GET\", url, true);\n      ajax.responseType = \"blob\";\n      ajax.onload = function (e) {\n        download(e.target.response, fileName, defaultMime);\n      };\n      setTimeout(function () {\n        ajax.send();\n      }, 0); // allows setting custom ajax headers using the return:\n      return ajax;\n    } // end if valid url?\n  } // end if url?\n\n  //go ahead and download dataURLs right away\n  if (/^data:([\\w+-]+\\/[\\w+.-]+)?[,;]/.test(payload)) {\n    if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {\n      payload = dataUrlToBlob(payload);\n      mimeType = payload.type || defaultMime;\n    } else {\n      return navigator.msSaveBlob // IE10 can't do a[download], only Blobs:\n        ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName)\n        : saver(payload); // everyone else can save dataURLs un-processed\n    }\n  } else {\n    //not data url, is it a string with special needs?\n    if (/([\\x80-\\xff])/.test(payload)) {\n      var i = 0,\n        tempUiArr = new Uint8Array(payload.length),\n        mx = tempUiArr.length;\n      for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);\n      payload = new myBlob([tempUiArr], { type: mimeType });\n    }\n  }\n  blob =\n    payload instanceof myBlob\n      ? payload\n      : new myBlob([payload], { type: mimeType });\n\n  function dataUrlToBlob(strUrl) {\n    var parts = strUrl.split(/[:;,]/),\n      type = parts[1],\n      indexDecoder = strUrl.indexOf(\"charset\") > 0 ? 3 : 2,\n      decoder = parts[indexDecoder] == \"base64\" ? atob : decodeURIComponent,\n      binData = decoder(parts.pop()),\n      mx = binData.length,\n      i = 0,\n      uiArr = new Uint8Array(mx);\n\n    for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);\n\n    return new myBlob([uiArr], { type: type });\n  }\n\n  function saver(url, winMode) {\n    if (\"download\" in anchor) {\n      //html5 A[download]\n      anchor.href = url;\n      anchor.setAttribute(\"download\", fileName);\n      anchor.className = \"download-js-link\";\n      anchor.innerHTML = \"downloading...\";\n      anchor.style.display = \"none\";\n      anchor.addEventListener(\"click\", function (e) {\n        e.stopPropagation();\n        this.removeEventListener(\"click\", arguments.callee);\n      });\n      document.body.appendChild(anchor);\n      setTimeout(function () {\n        anchor.click();\n        document.body.removeChild(anchor);\n        if (winMode === true) {\n          setTimeout(function () {\n            self.URL.revokeObjectURL(anchor.href);\n          }, 250);\n        }\n      }, 66);\n      return true;\n    }\n\n    // handle non-a[download] safari as best we can:\n    if (\n      /(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)\n    ) {\n      if (/^data:/.test(url))\n        url = \"data:\" + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n      if (!window.open(url)) {\n        // popup blocked, offer direct download:\n        if (\n          confirm(\n            \"Displaying New Document. Use Save As... to download, then click back to return to this page.\"\n          )\n        ) {\n          location.href = url;\n        }\n      }\n      return true;\n    }\n\n    //do iframe dataURL download (old ch+FF):\n    var f = document.createElement(\"iframe\");\n    document.body.appendChild(f);\n\n    if (!winMode && /^data:/.test(url)) {\n      // force a mime that will download:\n      url = \"data:\" + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n    }\n    f.src = url;\n    setTimeout(function () {\n      document.body.removeChild(f);\n    }, 333);\n  } //end saver\n\n  saver(self.URL.createObjectURL(blob), true);\n\n  return true;\n};\n", "/**\n * A tool for presenting an ArrayBuffer as a stream for writing some simple data types.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n/*\n * Create an ArrayBuffer of the given length and present it as a writable stream with methods\n * for writing data in different formats.\n */\nclass ArrayBufferDataStream {\n  constructor(length) {\n    this.data = new Uint8Array(length);\n    this.pos = 0;\n  }\n\n  seek(toOffset) {\n    this.pos = toOffset;\n  }\n\n  writeBytes(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      this.data[this.pos++] = arr[i];\n    }\n  }\n\n  writeByte(b) {\n    this.data[this.pos++] = b;\n  }\n\n  writeU16BE(u) {\n    this.data[this.pos++] = u >> 8;\n    this.data[this.pos++] = u;\n  }\n\n  writeDoubleBE(d) {\n    let bytes = new Uint8Array(new Float64Array([d]).buffer);\n\n    for (let i = bytes.length - 1; i >= 0; i--) {\n      this.writeByte(bytes[i]);\n    }\n  }\n\n  writeFloatBE(d) {\n    let bytes = new Uint8Array(new Float32Array([d]).buffer);\n\n    for (let i = bytes.length - 1; i >= 0; i--) {\n      this.writeByte(bytes[i]);\n    }\n  }\n\n  /**\n   * Write an ASCII string to the stream\n   */\n  writeString(s) {\n    for (let i = 0; i < s.length; i++) {\n      this.data[this.pos++] = s.charCodeAt(i);\n    }\n  }\n\n  /**\n   * Write the given 32-bit integer to the stream as an EBML variable-length integer using the given byte width\n   * (use measureEBMLVarInt).\n   *\n   * No error checking is performed to ensure that the supplied width is correct for the integer.\n   *\n   * @param i Integer to be written\n   * @param width Number of bytes to write to the stream\n   */\n  writeEBMLVarIntWidth(i, width) {\n    switch (width) {\n      case 1:\n        this.writeU8((1 << 7) | i);\n        break;\n      case 2:\n        this.writeU8((1 << 6) | (i >> 8));\n        this.writeU8(i);\n        break;\n      case 3:\n        this.writeU8((1 << 5) | (i >> 16));\n        this.writeU8(i >> 8);\n        this.writeU8(i);\n        break;\n      case 4:\n        this.writeU8((1 << 4) | (i >> 24));\n        this.writeU8(i >> 16);\n        this.writeU8(i >> 8);\n        this.writeU8(i);\n        break;\n      case 5:\n        /*\n         * JavaScript converts its doubles to 32-bit integers for bitwise operations, so we need to do a\n         * division by 2^32 instead of a right-shift of 32 to retain those top 3 bits\n         */\n        this.writeU8((1 << 3) | ((i / 4294967296) & 0x7));\n        this.writeU8(i >> 24);\n        this.writeU8(i >> 16);\n        this.writeU8(i >> 8);\n        this.writeU8(i);\n        break;\n      default:\n        throw new Error(\"Bad EBML VINT size \" + width);\n    }\n  }\n\n  /**\n   * Return the number of bytes needed to encode the given integer as an EBML VINT.\n   */\n  measureEBMLVarInt(val) {\n    if (val < (1 << 7) - 1) {\n      /* Top bit is set, leaving 7 bits to hold the integer, but we can't store 127 because\n       * \"all bits set to one\" is a reserved value. Same thing for the other cases below:\n       */\n      return 1;\n    } else if (val < (1 << 14) - 1) {\n      return 2;\n    } else if (val < (1 << 21) - 1) {\n      return 3;\n    } else if (val < (1 << 28) - 1) {\n      return 4;\n    } else if (val < 34359738367) {\n      // 2 ^ 35 - 1 (can address 32GB)\n      return 5;\n    } else {\n      throw new Error(\"EBML VINT size not supported \" + val);\n    }\n  }\n\n  writeEBMLVarInt(i) {\n    this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));\n  }\n\n  /**\n   * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.\n   * No error checking is performed to ensure that the supplied width is correct for the integer.\n   *\n   * Omit the width parameter to have it determined automatically for you.\n   *\n   * @param u Unsigned integer to be written\n   * @param width Number of bytes to write to the stream\n   */\n  writeUnsignedIntBE(u, width) {\n    if (width === undefined) {\n      width = this.measureUnsignedInt(u);\n    }\n\n    // Each case falls through:\n    switch (width) {\n      case 5:\n        this.writeU8(Math.floor(u / 4294967296)); // Need to use division to access >32 bits of floating point var\n      case 4:\n        this.writeU8(u >> 24);\n      case 3:\n        this.writeU8(u >> 16);\n      case 2:\n        this.writeU8(u >> 8);\n      case 1:\n        this.writeU8(u);\n        break;\n      default:\n        throw new Error(\"Bad UINT size \" + width);\n    }\n  }\n\n  /**\n   * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.\n   */\n  measureUnsignedInt(val) {\n    // Force to 32-bit unsigned integer\n    if (val < 1 << 8) {\n      return 1;\n    } else if (val < 1 << 16) {\n      return 2;\n    } else if (val < 1 << 24) {\n      return 3;\n    } else if (val < 4294967296) {\n      return 4;\n    } else {\n      return 5;\n    }\n  }\n\n  /**\n   * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.\n   */\n  getAsDataArray() {\n    if (this.pos < this.data.byteLength) {\n      return this.data.subarray(0, this.pos);\n    } else if (this.pos == this.data.byteLength) {\n      return this.data;\n    } else {\n      throw new Error(\"ArrayBufferDataStream's pos lies beyond end of buffer\");\n    }\n  }\n}\n\n//Synonym:\nArrayBufferDataStream.prototype.writeU8 =\n  ArrayBufferDataStream.prototype.writeByte;\n\nexport { ArrayBufferDataStream };\n", "/**\n * Allows a series of Blob-convertible objects (ArrayBuffer, Blob, String, etc) to be added to a buffer. Seeking and\n * overwriting of blobs is allowed.\n *\n * You can supply a FileWriter, in which case the BlobBuffer is just used as temporary storage before it writes it\n * through to the disk.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\nconst fs = null;\n\nclass BlobBuffer {\n  constructor(destination) {\n    let buffer = [],\n      writePromise = Promise.resolve(),\n      fileWriter = null,\n      fd = null;\n\n    if (destination && destination.constructor.name === \"FileWriter\") {\n      fileWriter = destination;\n    } else if (fs && destination) {\n      fd = destination;\n    }\n\n    // Current seek offset\n    this.pos = 0;\n\n    // One more than the index of the highest byte ever written\n    this.length = 0;\n\n    // Returns a promise that converts the blob to an ArrayBuffer\n    function readBlobAsBuffer(blob) {\n      return new Promise(function (resolve, reject) {\n        let reader = new FileReader();\n\n        reader.addEventListener(\"loadend\", function () {\n          resolve(reader.result);\n        });\n\n        reader.readAsArrayBuffer(blob);\n      });\n    }\n\n    function convertToUint8Array(thing) {\n      return new Promise(function (resolve, reject) {\n        if (thing instanceof Uint8Array) {\n          resolve(thing);\n        } else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {\n          resolve(new Uint8Array(thing));\n        } else if (thing instanceof Blob) {\n          resolve(\n            readBlobAsBuffer(thing).then(function (buffer) {\n              return new Uint8Array(buffer);\n            })\n          );\n        } else {\n          //Assume that Blob will know how to read this thing\n          resolve(\n            readBlobAsBuffer(new Blob([thing])).then(function (buffer) {\n              return new Uint8Array(buffer);\n            })\n          );\n        }\n      });\n    }\n\n    function measureData(data) {\n      let result = data.byteLength || data.length || data.size;\n\n      if (!Number.isInteger(result)) {\n        throw new Error(\"Failed to determine size of element\");\n      }\n\n      return result;\n    }\n\n    /**\n     * Seek to the given absolute offset.\n     *\n     * You may not seek beyond the end of the file (this would create a hole and/or allow blocks to be written in non-\n     * sequential order, which isn't currently supported by the memory buffer backend).\n     */\n    this.seek = function (offset) {\n      if (offset < 0) {\n        throw new Error(\"Offset may not be negative\");\n      }\n\n      if (isNaN(offset)) {\n        throw new Error(\"Offset may not be NaN\");\n      }\n\n      if (offset > this.length) {\n        throw new Error(\"Seeking beyond the end of file is not allowed\");\n      }\n\n      this.pos = offset;\n    };\n\n    /**\n     * Write the Blob-convertible data to the buffer at the current seek position.\n     *\n     * Note: If overwriting existing data, the write must not cross preexisting block boundaries (written data must\n     * be fully contained by the extent of a previous write).\n     */\n    this.write = function (data) {\n      let newEntry = {\n          offset: this.pos,\n          data: data,\n          length: measureData(data),\n        },\n        isAppend = newEntry.offset >= this.length;\n\n      this.pos += newEntry.length;\n      this.length = Math.max(this.length, this.pos);\n\n      // After previous writes complete, perform our write\n      writePromise = writePromise.then(function () {\n        if (fd) {\n          return new Promise(function (resolve, reject) {\n            convertToUint8Array(newEntry.data).then(function (dataArray) {\n              let totalWritten = 0,\n                buffer = Buffer.from(dataArray.buffer),\n                handleWriteComplete = function (err, written, buffer) {\n                  totalWritten += written;\n\n                  if (totalWritten >= buffer.length) {\n                    resolve();\n                  } else {\n                    // We still have more to write...\n                    fs.write(\n                      fd,\n                      buffer,\n                      totalWritten,\n                      buffer.length - totalWritten,\n                      newEntry.offset + totalWritten,\n                      handleWriteComplete\n                    );\n                  }\n                };\n\n              fs.write(\n                fd,\n                buffer,\n                0,\n                buffer.length,\n                newEntry.offset,\n                handleWriteComplete\n              );\n            });\n          });\n        } else if (fileWriter) {\n          return new Promise(function (resolve, reject) {\n            fileWriter.onwriteend = resolve;\n\n            fileWriter.seek(newEntry.offset);\n            fileWriter.write(new Blob([newEntry.data]));\n          });\n        } else if (!isAppend) {\n          // We might be modifying a write that was already buffered in memory.\n          // Slow linear search to find a block we might be overwriting\n          for (let i = 0; i < buffer.length; i++) {\n            let entry = buffer[i];\n\n            // If our new entry overlaps the old one in any way...\n            if (\n              !(\n                newEntry.offset + newEntry.length <= entry.offset ||\n                newEntry.offset >= entry.offset + entry.length\n              )\n            ) {\n              if (\n                newEntry.offset < entry.offset ||\n                newEntry.offset + newEntry.length > entry.offset + entry.length\n              ) {\n                throw new Error(\"Overwrite crosses blob boundaries\");\n              }\n\n              if (\n                newEntry.offset == entry.offset &&\n                newEntry.length == entry.length\n              ) {\n                // We overwrote the entire block\n                entry.data = newEntry.data;\n\n                // We're done\n                return;\n              } else {\n                return convertToUint8Array(entry.data)\n                  .then(function (entryArray) {\n                    entry.data = entryArray;\n\n                    return convertToUint8Array(newEntry.data);\n                  })\n                  .then(function (newEntryArray) {\n                    newEntry.data = newEntryArray;\n\n                    entry.data.set(\n                      newEntry.data,\n                      newEntry.offset - entry.offset\n                    );\n                  });\n              }\n            }\n          }\n          // Else fall through to do a simple append, as we didn't overwrite any pre-existing blocks\n        }\n\n        buffer.push(newEntry);\n      });\n    };\n\n    /**\n     * Finish all writes to the buffer, returning a promise that signals when that is complete.\n     *\n     * If a FileWriter was not provided, the promise is resolved with a Blob that represents the completed BlobBuffer\n     * contents. You can optionally pass in a mimeType to be used for this blob.\n     *\n     * If a FileWriter was provided, the promise is resolved with null as the first argument.\n     */\n    this.complete = function (mimeType) {\n      if (fd || fileWriter) {\n        writePromise = writePromise.then(function () {\n          return null;\n        });\n      } else {\n        // After writes complete we need to merge the buffer to give to the caller\n        writePromise = writePromise.then(function () {\n          let result = [];\n\n          for (let i = 0; i < buffer.length; i++) {\n            result.push(buffer[i].data);\n          }\n\n          return new Blob(result, { type: mimeType });\n        });\n      }\n\n      return writePromise;\n    };\n  }\n}\n\nexport { BlobBuffer }", "import { ArrayBufferDataStream } from \"./ArrayBufferDataStream\";\nimport { BlobBuffer } from \"./BlobBuffer\";\n\n/**\n * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n *\n * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n * eventually returned as one composite Blob.\n *\n * By Nicholas Sherlock.\n *\n * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\nfunction extend(base, top) {\n  let target = {};\n\n  [base, top].forEach(function (obj) {\n    for (let prop in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n        target[prop] = obj[prop];\n      }\n    }\n  });\n\n  return target;\n}\n\n/**\n * Decode a Base64 data URL into a binary string.\n *\n * @return {String} The binary string\n */\nfunction decodeBase64WebPDataURL(url) {\n  if (typeof url !== \"string\" || !url.match(/^data:image\\/webp;base64,/i)) {\n    throw new Error(\"Failed to decode WebP Base64 URL\");\n  }\n\n  return window.atob(url.substring(\"data:image/webp;base64,\".length));\n}\n\n/**\n * Convert the given canvas to a WebP encoded image and return the image data as a string.\n *\n * @return {String}\n */\nfunction renderAsWebP(canvas, quality) {\n  let frame =\n    typeof canvas === \"string\" && /^data:image\\/webp/.test(canvas)\n      ? canvas\n      : canvas.toDataURL(\"image/webp\", quality);\n\n  return decodeBase64WebPDataURL(frame);\n}\n\n/**\n * @param {String} string\n * @returns {number}\n */\nfunction byteStringToUint32LE(string) {\n  let a = string.charCodeAt(0),\n    b = string.charCodeAt(1),\n    c = string.charCodeAt(2),\n    d = string.charCodeAt(3);\n\n  return (a | (b << 8) | (c << 16) | (d << 24)) >>> 0;\n}\n\n/**\n * Extract a VP8 keyframe from a WebP image file.\n *\n * @param {String} webP - Raw binary string\n *\n * @returns {{hasAlpha: boolean, frame: string}}\n */\nfunction extractKeyframeFromWebP(webP) {\n  let cursor = webP.indexOf(\"VP8\", 12); // Start the search after the 12-byte file header\n\n  if (cursor === -1) {\n    throw new Error(\"Bad image format, does this browser support WebP?\");\n  }\n\n  let hasAlpha = false;\n\n  /* Cursor now is either directly pointing at a \"VP8 \" keyframe, or a \"VP8X\" extended format file header\n   * Seek through chunks until we find the \"VP8 \" chunk we're interested in\n   */\n  while (cursor < webP.length - 8) {\n    let chunkLength, fourCC;\n\n    fourCC = webP.substring(cursor, cursor + 4);\n    cursor += 4;\n\n    chunkLength = byteStringToUint32LE(webP.substring(cursor, cursor + 4));\n    cursor += 4;\n\n    switch (fourCC) {\n      case \"VP8 \":\n        return {\n          frame: webP.substring(cursor, cursor + chunkLength),\n          hasAlpha: hasAlpha,\n        };\n\n      case \"ALPH\":\n        hasAlpha = true;\n        /* But we otherwise ignore the content of the alpha chunk, since we don't have a decoder for it\n         * and it isn't VP8-compatible\n         */\n        break;\n    }\n\n    cursor += chunkLength;\n\n    if ((chunkLength & 0x01) !== 0) {\n      cursor++;\n      // Odd-length chunks have 1 byte of trailing padding that isn't included in their length\n    }\n  }\n\n  throw new Error(\n    \"Failed to find VP8 keyframe in WebP image, is this image mistakenly encoded in the Lossless WebP format?\"\n  );\n}\n\n// Just a little utility so we can tag values as floats for the EBML encoder's benefit\nfunction EBMLFloat32(value) {\n  this.value = value;\n}\n\nfunction EBMLFloat64(value) {\n  this.value = value;\n}\n\n/**\n * Write the given EBML object to the provided ArrayBufferStream.\n *\n * @param buffer\n * @param {Number} bufferFileOffset - The buffer's first byte is at this position inside the video file.\n *                                    This is used to complete offset and dataOffset fields in each EBML structure,\n *                                    indicating the file offset of the first byte of the EBML element and\n *                                    its data payload.\n * @param {*} ebml\n */\nfunction writeEBML(buffer, bufferFileOffset, ebml) {\n  // Is the ebml an array of sibling elements?\n  if (Array.isArray(ebml)) {\n    for (let i = 0; i < ebml.length; i++) {\n      writeEBML(buffer, bufferFileOffset, ebml[i]);\n    }\n    // Is this some sort of raw data that we want to write directly?\n  } else if (typeof ebml === \"string\") {\n    buffer.writeString(ebml);\n  } else if (ebml instanceof Uint8Array) {\n    buffer.writeBytes(ebml);\n  } else if (ebml.id) {\n    // We're writing an EBML element\n    ebml.offset = buffer.pos + bufferFileOffset;\n\n    buffer.writeUnsignedIntBE(ebml.id); // ID field\n\n    // Now we need to write the size field, so we must know the payload size:\n\n    if (Array.isArray(ebml.data)) {\n      // Writing an array of child elements. We won't try to measure the size of the children up-front\n\n      let sizePos, dataBegin, dataEnd;\n\n      if (ebml.size === -1) {\n        // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n        buffer.writeByte(0xff);\n      } else {\n        sizePos = buffer.pos;\n\n        /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n         * which should be plenty (we don't want to have to buffer that much data in memory at one time\n         * anyway!)\n         */\n        buffer.writeBytes([0, 0, 0, 0]);\n      }\n\n      dataBegin = buffer.pos;\n\n      ebml.dataOffset = dataBegin + bufferFileOffset;\n      writeEBML(buffer, bufferFileOffset, ebml.data);\n\n      if (ebml.size !== -1) {\n        dataEnd = buffer.pos;\n\n        ebml.size = dataEnd - dataBegin;\n\n        buffer.seek(sizePos);\n        buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n\n        buffer.seek(dataEnd);\n      }\n    } else if (typeof ebml.data === \"string\") {\n      buffer.writeEBMLVarInt(ebml.data.length); // Size field\n      ebml.dataOffset = buffer.pos + bufferFileOffset;\n      buffer.writeString(ebml.data);\n    } else if (typeof ebml.data === \"number\") {\n      // Allow the caller to explicitly choose the size if they wish by supplying a size field\n      if (!ebml.size) {\n        ebml.size = buffer.measureUnsignedInt(ebml.data);\n      }\n\n      buffer.writeEBMLVarInt(ebml.size); // Size field\n      ebml.dataOffset = buffer.pos + bufferFileOffset;\n      buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n    } else if (ebml.data instanceof EBMLFloat64) {\n      buffer.writeEBMLVarInt(8); // Size field\n      ebml.dataOffset = buffer.pos + bufferFileOffset;\n      buffer.writeDoubleBE(ebml.data.value);\n    } else if (ebml.data instanceof EBMLFloat32) {\n      buffer.writeEBMLVarInt(4); // Size field\n      ebml.dataOffset = buffer.pos + bufferFileOffset;\n      buffer.writeFloatBE(ebml.data.value);\n    } else if (ebml.data instanceof Uint8Array) {\n      buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n      ebml.dataOffset = buffer.pos + bufferFileOffset;\n      buffer.writeBytes(ebml.data);\n    } else {\n      throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n    }\n  } else {\n    throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n  }\n}\n\n/**\n * @typedef {Object} Frame\n * @property {string} frame - Raw VP8 keyframe data\n * @property {string} alpha - Raw VP8 keyframe with alpha represented as luminance\n * @property {Number} duration\n * @property {Number} trackNumber - From 1 to 126 (inclusive)\n * @property {Number} timecode\n */\n\n/**\n * @typedef {Object} Cluster\n * @property {Number} timecode - Start time for the cluster\n */\n\nexport class WebMWriter {\n  constructor(options) {\n    let MAX_CLUSTER_DURATION_MSEC = 5000,\n      DEFAULT_TRACK_NUMBER = 1,\n      writtenHeader = false,\n      videoWidth = 0,\n      videoHeight = 0,\n      /**\n       * @type {[HTMLCanvasElement]}\n       */\n      alphaBuffer = null,\n      /**\n       * @type {[CanvasRenderingContext2D]}\n       */\n      alphaBufferContext = null,\n      /**\n       * @type {[ImageData]}\n       */\n      alphaBufferData = null,\n      /**\n       *\n       * @type {Frame[]}\n       */\n      clusterFrameBuffer = [],\n      clusterStartTime = 0,\n      clusterDuration = 0,\n      optionDefaults = {\n        quality: 0.95,\n\n        transparent: false,\n        alphaQuality: undefined,\n\n        // If not specified this defaults to the same value as `quality`.\n        fileWriter: null,\n        fd: null,\n\n        // You must supply one of:\n        frameDuration: null,\n        frameRate: null, // Number of frames per second\n      },\n      seekPoints = {\n        Cues: {\n          id: new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]),\n          positionEBML: null,\n        },\n        SegmentInfo: {\n          id: new Uint8Array([0x15, 0x49, 0xa9, 0x66]),\n          positionEBML: null,\n        },\n        Tracks: {\n          id: new Uint8Array([0x16, 0x54, 0xae, 0x6b]),\n          positionEBML: null,\n        },\n      },\n      ebmlSegment, // Root element of the EBML document\n      segmentDuration = {\n        id: 0x4489,\n        data: new EBMLFloat64(0),\n      },\n      seekHead,\n      cues = [],\n      blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n\n    function fileOffsetToSegmentRelative(fileOffset) {\n      return fileOffset - ebmlSegment.dataOffset;\n    }\n\n    /**\n     * Extracts the transparency channel from the supplied canvas and uses it to create a VP8 alpha channel bitstream.\n     *\n     * @param {HTMLCanvasElement} source\n     *\n     * @return {HTMLCanvasElement}\n     */\n    function convertAlphaToGrayscaleImage(source) {\n      if (\n        alphaBuffer === null ||\n        alphaBuffer.width !== source.width ||\n        alphaBuffer.height !== source.height\n      ) {\n        alphaBuffer = document.createElement(\"canvas\");\n        alphaBuffer.width = source.width;\n        alphaBuffer.height = source.height;\n\n        alphaBufferContext = alphaBuffer.getContext(\"2d\");\n        alphaBufferData = alphaBufferContext.createImageData(\n          alphaBuffer.width,\n          alphaBuffer.height\n        );\n      }\n\n      let sourceContext = source.getContext(\"2d\"),\n        sourceData = sourceContext.getImageData(\n          0,\n          0,\n          source.width,\n          source.height\n        ).data,\n        destData = alphaBufferData.data,\n        dstCursor = 0,\n        srcEnd = source.width * source.height * 4;\n\n      for (\n        let srcCursor = 3 /* Since pixel byte order is RGBA */;\n        srcCursor < srcEnd;\n        srcCursor += 4\n      ) {\n        let alpha = sourceData[srcCursor];\n\n        // Turn the original alpha channel into a brightness value (ends up being the Y in YUV)\n        destData[dstCursor++] = alpha;\n        destData[dstCursor++] = alpha;\n        destData[dstCursor++] = alpha;\n        destData[dstCursor++] = 255;\n      }\n\n      alphaBufferContext.putImageData(alphaBufferData, 0, 0);\n\n      return alphaBuffer;\n    }\n\n    /**\n     * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n     *\n     * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n     * to be overwritten later.\n     */\n    function createSeekHead() {\n      let seekPositionEBMLTemplate = {\n          id: 0x53ac,\n          size: 5,\n          data: 0, // We'll overwrite this when the file is complete\n        },\n        result = {\n          id: 0x114d9b74,\n          data: [],\n        };\n\n      for (let name in seekPoints) {\n        let seekPoint = seekPoints[name];\n\n        seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n\n        result.data.push({\n          id: 0x4dbb,\n          data: [\n            {\n              id: 0x53ab,\n              data: seekPoint.id,\n            },\n            seekPoint.positionEBML,\n          ],\n        });\n      }\n\n      return result;\n    }\n\n    /**\n     * Write the WebM file header to the stream.\n     */\n    function writeHeader() {\n      seekHead = createSeekHead();\n\n      let ebmlHeader = {\n          id: 0x1a45dfa3,\n          data: [\n            {\n              id: 0x4286,\n              data: 1,\n            },\n            {\n              id: 0x42f7,\n              data: 1,\n            },\n            {\n              id: 0x42f2,\n              data: 4,\n            },\n            {\n              id: 0x42f3,\n              data: 8,\n            },\n            {\n              id: 0x4282,\n              data: \"webm\",\n            },\n            {\n              id: 0x4287,\n              data: 2,\n            },\n            {\n              id: 0x4285,\n              data: 2,\n            },\n          ],\n        },\n        segmentInfo = {\n          id: 0x1549a966,\n          data: [\n            {\n              id: 0x2ad7b1,\n              data: 1e6, // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n            },\n            {\n              id: 0x4d80,\n              data: \"webm-writer-js\",\n            },\n            {\n              id: 0x5741,\n              data: \"webm-writer-js\",\n            },\n            segmentDuration, // To be filled in later\n          ],\n        },\n        videoProperties = [\n          {\n            id: 0xb0,\n            data: videoWidth,\n          },\n          {\n            id: 0xba,\n            data: videoHeight,\n          },\n        ];\n\n      if (options.transparent) {\n        videoProperties.push({\n          id: 0x53c0,\n          data: 1,\n        });\n      }\n\n      let tracks = {\n        id: 0x1654ae6b,\n        data: [\n          {\n            id: 0xae,\n            data: [\n              {\n                id: 0xd7,\n                data: DEFAULT_TRACK_NUMBER,\n              },\n              {\n                id: 0x73c5,\n                data: DEFAULT_TRACK_NUMBER,\n              },\n              {\n                id: 0x9c,\n                data: 0,\n              },\n              {\n                id: 0x22b59c,\n                data: \"und\",\n              },\n              {\n                id: 0x86,\n                data: \"V_VP8\",\n              },\n              {\n                id: 0x258688,\n                data: \"VP8\",\n              },\n              {\n                id: 0x83,\n                data: 1,\n              },\n              {\n                id: 0xe0,\n                data: videoProperties,\n              },\n            ],\n          },\n        ],\n      };\n\n      ebmlSegment = {\n        id: 0x18538067,\n        size: -1,\n        data: [seekHead, segmentInfo, tracks],\n      };\n\n      let bufferStream = new ArrayBufferDataStream(256);\n\n      writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n      blobBuffer.write(bufferStream.getAsDataArray());\n\n      // Now we know where these top-level elements lie in the file:\n      seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(\n        segmentInfo.offset\n      );\n      seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(\n        tracks.offset\n      );\n\n      writtenHeader = true;\n    }\n\n    /**\n     * Create a BlockGroup element to hold the given keyframe (used when alpha support is required)\n     *\n     * @param {Frame} keyframe\n     *\n     * @return A BlockGroup EBML element\n     */\n    function createBlockGroupForTransparentKeyframe(keyframe) {\n      let block,\n        blockAdditions,\n        bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n\n      // Create a Block to hold the image data:\n      if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n        throw new Error(\"TrackNumber must be > 0 and < 127\");\n      }\n\n      bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n      bufferStream.writeU16BE(keyframe.timecode);\n      bufferStream.writeByte(0); // Flags byte\n\n      block = {\n        id: 0xa1,\n        data: [bufferStream.getAsDataArray(), keyframe.frame],\n      };\n\n      blockAdditions = {\n        id: 0x75a1,\n        data: [\n          {\n            id: 0xa6,\n            data: [\n              {\n                id: 0xee,\n                data: 1, // Means \"BlockAdditional has a codec-defined meaning, pass it to the codec\"\n              },\n              {\n                id: 0xa5,\n                data: keyframe.alpha, // The actual alpha channel image\n              },\n            ],\n          },\n        ],\n      };\n\n      return {\n        id: 0xa0,\n        data: [block, blockAdditions],\n      };\n    }\n\n    /**\n     * Create a SimpleBlock element to hold the given keyframe.\n     *\n     * @param {Frame} keyframe\n     *\n     * @return A SimpleBlock EBML element.\n     */\n    function createSimpleBlockForKeyframe(keyframe) {\n      let bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n\n      if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n        throw new Error(\"TrackNumber must be > 0 and < 127\");\n      }\n\n      bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n      bufferStream.writeU16BE(keyframe.timecode);\n\n      // Flags byte\n      bufferStream.writeByte(\n        1 << 7 // Keyframe\n      );\n\n      return {\n        id: 0xa3,\n        data: [bufferStream.getAsDataArray(), keyframe.frame],\n      };\n    }\n\n    /**\n     * Create either a SimpleBlock or BlockGroup (if alpha is required) for the given keyframe.\n     *\n     * @param {Frame} keyframe\n     */\n    function createContainerForKeyframe(keyframe) {\n      if (keyframe.alpha) {\n        return createBlockGroupForTransparentKeyframe(keyframe);\n      }\n\n      return createSimpleBlockForKeyframe(keyframe);\n    }\n\n    /**\n     * Create a Cluster EBML node.\n     *\n     * @param {Cluster} cluster\n     *\n     * Returns an EBML element.\n     */\n    function createCluster(cluster) {\n      return {\n        id: 0x1f43b675,\n        data: [\n          {\n            id: 0xe7,\n            data: Math.round(cluster.timecode),\n          },\n        ],\n      };\n    }\n\n    function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n      cues.push({\n        id: 0xbb,\n        data: [\n          {\n            id: 0xb3,\n            data: clusterTime,\n          },\n          {\n            id: 0xb7,\n            data: [\n              {\n                id: 0xf7,\n                data: trackIndex,\n              },\n              {\n                id: 0xf1,\n                data: fileOffsetToSegmentRelative(clusterFileOffset),\n              },\n            ],\n          },\n        ],\n      });\n    }\n\n    /**\n     * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n     * The seek entry for the Cues in the SeekHead is updated.\n     */\n    function writeCues() {\n      let ebml = {\n          id: 0x1c53bb6b,\n          data: cues,\n        },\n        cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n\n      writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n      blobBuffer.write(cuesBuffer.getAsDataArray());\n\n      // Now we know where the Cues element has ended up, we can update the SeekHead\n      seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(\n        ebml.offset\n      );\n    }\n\n    /**\n     * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n     */\n    function flushClusterFrameBuffer() {\n      if (clusterFrameBuffer.length === 0) {\n        return;\n      }\n\n      // First work out how large of a buffer we need to hold the cluster data\n      let rawImageSize = 0;\n\n      for (let i = 0; i < clusterFrameBuffer.length; i++) {\n        rawImageSize +=\n          clusterFrameBuffer[i].frame.length +\n          (clusterFrameBuffer[i].alpha\n            ? clusterFrameBuffer[i].alpha.length\n            : 0);\n      }\n\n      let buffer = new ArrayBufferDataStream(\n          rawImageSize + clusterFrameBuffer.length * 64\n        ), // Estimate 64 bytes per block header\n        cluster = createCluster({\n          timecode: Math.round(clusterStartTime),\n        });\n\n      for (let i = 0; i < clusterFrameBuffer.length; i++) {\n        cluster.data.push(createContainerForKeyframe(clusterFrameBuffer[i]));\n      }\n\n      writeEBML(buffer, blobBuffer.pos, cluster);\n      blobBuffer.write(buffer.getAsDataArray());\n\n      addCuePoint(\n        DEFAULT_TRACK_NUMBER,\n        Math.round(clusterStartTime),\n        cluster.offset\n      );\n\n      clusterFrameBuffer = [];\n      clusterStartTime += clusterDuration;\n      clusterDuration = 0;\n    }\n\n    function validateOptions() {\n      // Derive frameDuration setting if not already supplied\n      if (!options.frameDuration) {\n        if (options.frameRate) {\n          options.frameDuration = 1000 / options.frameRate;\n        } else {\n          throw new Error(\n            \"Missing required frameDuration or frameRate setting\"\n          );\n        }\n      }\n\n      // Avoid 1.0 (lossless) because it creates VP8L lossless frames that WebM doesn't support\n      options.quality = Math.max(Math.min(options.quality, 0.99999), 0);\n\n      if (options.alphaQuality === undefined) {\n        options.alphaQuality = options.quality;\n      } else {\n        options.alphaQuality = Math.max(\n          Math.min(options.alphaQuality, 0.99999),\n          0\n        );\n      }\n    }\n\n    /**\n     *\n     * @param {Frame} frame\n     */\n    function addFrameToCluster(frame) {\n      frame.trackNumber = DEFAULT_TRACK_NUMBER;\n\n      // Frame timecodes are relative to the start of their cluster:\n      frame.timecode = Math.round(clusterDuration);\n\n      clusterFrameBuffer.push(frame);\n\n      clusterDuration += frame.duration;\n\n      if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n        flushClusterFrameBuffer();\n      }\n    }\n\n    /**\n     * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n     *\n     * Call once writing is complete (so the offset of all top level elements is known).\n     */\n    function rewriteSeekHead() {\n      let seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n        oldPos = blobBuffer.pos;\n\n      // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n      writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);\n\n      // And write that through to the file\n      blobBuffer.seek(seekHead.dataOffset);\n      blobBuffer.write(seekHeadBuffer.getAsDataArray());\n\n      blobBuffer.seek(oldPos);\n    }\n\n    /**\n     * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n     */\n    function rewriteDuration() {\n      let buffer = new ArrayBufferDataStream(8),\n        oldPos = blobBuffer.pos;\n\n      // Rewrite the data payload (don't need to update the id or size)\n      buffer.writeDoubleBE(clusterStartTime);\n\n      // And write that through to the file\n      blobBuffer.seek(segmentDuration.dataOffset);\n      blobBuffer.write(buffer.getAsDataArray());\n\n      blobBuffer.seek(oldPos);\n    }\n\n    /**\n     * Add a frame to the video.\n     *\n     * @param {HTMLCanvasElement|String} frame - A Canvas element that contains the frame, or a WebP string\n     *                                           you obtained by calling toDataUrl() on an image yourself.\n     *\n     * @param {HTMLCanvasElement|String} [alpha] - For transparent video, instead of including the alpha channel\n     *                                             in your provided `frame`, you can instead provide it separately\n     *                                             here. The alpha channel of this alpha canvas will be ignored,\n     *                                             encode your alpha information into this canvas' grayscale\n     *                                             brightness instead.\n     *\n     *                                             This is useful because it allows you to paint the colours\n     *                                             you need into your `frame` even in regions which are fully\n     *                                             transparent (which Canvas doesn't normally let you influence).\n     *                                             This allows you to control the colour of the fringing seen\n     *                                             around objects on transparent backgrounds.\n     *\n     * @param {Number} [overrideFrameDuration] - Set a duration for this frame (in milliseconds) that differs\n     *                                           from the default\n     */\n    this.addFrame = function (frame, alpha, overrideFrameDuration) {\n      if (!writtenHeader) {\n        videoWidth = frame.width || 0;\n        videoHeight = frame.height || 0;\n\n        writeHeader();\n      }\n\n      let keyframe = extractKeyframeFromWebP(\n          renderAsWebP(frame, options.quality)\n        ),\n        frameDuration,\n        frameAlpha = null;\n\n      if (overrideFrameDuration) {\n        frameDuration = overrideFrameDuration;\n      } else if (typeof alpha == \"number\") {\n        frameDuration = alpha;\n      } else {\n        frameDuration = options.frameDuration;\n      }\n\n      if (options.transparent) {\n        if (alpha instanceof HTMLCanvasElement || typeof alpha === \"string\") {\n          frameAlpha = alpha;\n        } else if (keyframe.hasAlpha) {\n          frameAlpha = convertAlphaToGrayscaleImage(frame);\n        }\n      }\n\n      addFrameToCluster({\n        frame: keyframe.frame,\n        duration: frameDuration,\n        alpha: frameAlpha\n          ? extractKeyframeFromWebP(\n              renderAsWebP(frameAlpha, options.alphaQuality)\n            ).frame\n          : null,\n      });\n    };\n\n    /**\n     * Finish writing the video and return a Promise to signal completion.\n     *\n     * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n     * a Blob with the contents of the entire video.\n     */\n    this.complete = function () {\n      if (!writtenHeader) {\n        writeHeader();\n      }\n\n      flushClusterFrameBuffer();\n\n      writeCues();\n      rewriteSeekHead();\n      rewriteDuration();\n\n      return blobBuffer.complete(\"video/webm\");\n    };\n\n    this.getWrittenSize = function () {\n      return blobBuffer.length;\n    };\n\n    options = extend(optionDefaults, options || {});\n    validateOptions();\n  }\n}\n\n// export { WebMWriter };\n// export const createWebMWriter = () => {\n//   return new WebMWriter(ArrayBufferDataStream, BlobBuffer);\n// };\n", "/*\nThe MIT License\n\nCopyright (c) 2012 Jaume Sanchez Elias\nhttps://github.com/spite/ccapture.js\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nimport { download } from \"./download-4.21\";\nimport { WebMWriter } from \"./webm-writer-0.3.0\";\n\nfunction pad(n) {\n  return String(\"0000000\" + n).slice(-7);\n}\n// https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers\n\nlet g_startTime = window.Date.now();\n\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return (\n    s4() +\n    s4() +\n    \"-\" +\n    s4() +\n    \"-\" +\n    s4() +\n    \"-\" +\n    s4() +\n    \"-\" +\n    s4() +\n    s4() +\n    s4()\n  );\n}\n\nfunction CCFrameEncoder(settings) {\n  let _handlers = {};\n\n  this.settings = settings;\n\n  this.on = function (event, handler) {\n    _handlers[event] = handler;\n  };\n\n  this.emit = function (event) {\n    let handler = _handlers[event];\n    if (handler) {\n      handler.apply(null, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  this.filename = settings.name || guid();\n  this.extension = \"\";\n  this.mimeType = \"\";\n}\n\nCCFrameEncoder.prototype.start = function () {};\nCCFrameEncoder.prototype.stop = function () {};\nCCFrameEncoder.prototype.add = function () {};\nCCFrameEncoder.prototype.save = function () {};\nCCFrameEncoder.prototype.dispose = function () {};\nCCFrameEncoder.prototype.safeToProceed = function () {\n  return true;\n};\nCCFrameEncoder.prototype.step = function () {\n  console.log(\"Step not set!\");\n};\n\n/*\n  WebM Encoder\n*/\n\nfunction CCWebMEncoder(settings) {\n  // let canvas = document.createElement(\"canvas\");\n  CCFrameEncoder.call(this, settings);\n\n  this.quality = settings.quality / 100 || 0.8;\n\n  this.extension = \".webm\";\n  this.mimeType = \"video/webm\";\n  this.baseFilename = this.filename;\n  this.framerate = settings.framerate;\n\n  this.frames = 0;\n  this.part = 1;\n\n  this.videoWriter = new WebMWriter({\n    quality: this.quality,\n    fileWriter: null,\n    fd: null,\n    frameRate: this.framerate,\n  });\n}\n\nCCWebMEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\nCCWebMEncoder.prototype.start = function (canvas) {\n  this.dispose();\n};\n\nCCWebMEncoder.prototype.add = function (canvas) {\n  this.videoWriter.addFrame(canvas);\n\n  if (\n    this.settings.autoSaveTime > 0 &&\n    this.frames / this.settings.framerate >= this.settings.autoSaveTime\n  ) {\n    this.save(\n      function (blob) {\n        this.filename = this.baseFilename + \"-part-\" + pad(this.part);\n        download(blob, this.filename + this.extension, this.mimeType);\n        this.dispose();\n        this.part++;\n        this.filename = this.baseFilename + \"-part-\" + pad(this.part);\n        this.step();\n      }.bind(this)\n    );\n  } else {\n    this.frames++;\n    this.step();\n  }\n};\n\nCCWebMEncoder.prototype.save = function (callback) {\n  this.videoWriter.complete().then(callback);\n};\n\nCCWebMEncoder.prototype.dispose = function (canvas) {\n  this.frames = 0;\n  this.videoWriter = new WebMWriter({\n    quality: this.quality,\n    fileWriter: null,\n    fd: null,\n    frameRate: this.framerate,\n  });\n};\n\n/*\n  HTMLCanvasElement.captureStream()\n*/\n\nfunction CCStreamEncoder(settings) {\n  CCFrameEncoder.call(this, settings);\n\n  this.framerate = this.settings.framerate;\n  this.type = \"video/webm\";\n  this.extension = \".webm\";\n  this.stream = null;\n  this.mediaRecorder = null;\n  this.chunks = [];\n}\n\nCCStreamEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\nCCStreamEncoder.prototype.add = function (canvas) {\n  if (!this.stream) {\n    this.stream = canvas.captureStream(this.framerate);\n    this.mediaRecorder = new MediaRecorder(this.stream);\n    this.mediaRecorder.start();\n\n    this.mediaRecorder.ondataavailable = function (e) {\n      this.chunks.push(e.data);\n    }.bind(this);\n  }\n  this.step();\n};\n\nCCStreamEncoder.prototype.save = function (callback) {\n  this.mediaRecorder.onstop = function (e) {\n    let blob = new Blob(this.chunks, { type: \"video/webm\" });\n    this.chunks = [];\n    callback(blob);\n  }.bind(this);\n  this.mediaRecorder.stop();\n};\n\nfunction CCGIFEncoder(settings) {\n  CCFrameEncoder.call(this, settings);\n\n  settings.quality = 31 - ((settings.quality * 30) / 100 || 10);\n  settings.workers = settings.workers || 4;\n\n  this.extension = \".gif\";\n  this.mimeType = \"image/gif\";\n\n  this.canvas = document.createElement(\"canvas\");\n  this.ctx = this.canvas.getContext(\"2d\");\n  this.sizeSet = false;\n\n  this.encoder = new GIF({\n    workers: settings.workers,\n    quality: settings.quality,\n    workerScript: settings.workersPath + \"gif.worker.js\",\n  });\n\n  this.encoder.on(\n    \"progress\",\n    function (progress) {\n      if (this.settings.onProgress) {\n        this.settings.onProgress(progress);\n      }\n    }.bind(this)\n  );\n\n  this.encoder.on(\n    \"finished\",\n    function (blob) {\n      let cb = this.callback;\n      if (cb) {\n        this.callback = undefined;\n        cb(blob);\n      }\n    }.bind(this)\n  );\n}\n\nCCGIFEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\nCCGIFEncoder.prototype.add = function (canvas) {\n  if (!this.sizeSet) {\n    this.encoder.setOption(\"width\", canvas.width);\n    this.encoder.setOption(\"height\", canvas.height);\n    this.sizeSet = true;\n  }\n\n  this.canvas.width = canvas.width;\n  this.canvas.height = canvas.height;\n  this.ctx.drawImage(canvas, 0, 0);\n\n  this.encoder.addFrame(this.ctx, { copy: true, delay: this.settings.step });\n  this.step();\n};\n\nCCGIFEncoder.prototype.save = function (callback) {\n  this.callback = callback;\n\n  this.encoder.render();\n};\n\nfunction CCapture(settings) {\n  let _settings = settings || {},\n    _verbose,\n    _time,\n    _startTime,\n    _performanceTime,\n    _performanceStartTime,\n    // _step,\n    _encoder,\n    _timeouts = [],\n    _intervals = [],\n    _frameCount = 0,\n    _intermediateFrameCount = 0,\n    _requestAnimationFrameCallbacks = [],\n    _capturing = false,\n    _handlers = {};\n\n  _settings.framerate = _settings.framerate || 60;\n  _settings.motionBlurFrames = 2 * (_settings.motionBlurFrames || 1);\n  _verbose = _settings.verbose || false;\n  _settings.step = 1000.0 / _settings.framerate;\n  _settings.timeLimit = _settings.timeLimit || 0;\n  _settings.frameLimit = _settings.frameLimit || 0;\n  _settings.startTime = _settings.startTime || 0;\n\n  let _timeDisplay = document.createElement(\"div\");\n  _timeDisplay.style.position = \"absolute\";\n  _timeDisplay.style.left = _timeDisplay.style.top = 0;\n  _timeDisplay.style.backgroundColor = \"black\";\n  _timeDisplay.style.fontFamily = \"monospace\";\n  _timeDisplay.style.fontSize = \"11px\";\n  _timeDisplay.style.padding = \"5px\";\n  _timeDisplay.style.color = \"red\";\n  _timeDisplay.style.zIndex = 100000;\n  if (_settings.display) document.body.appendChild(_timeDisplay);\n\n  const canvasMotionBlur = document.createElement(\"canvas\");\n  const ctxMotionBlur = canvasMotionBlur.getContext(\"2d\");\n  let bufferMotionBlur;\n  let imageData;\n\n  _log(\"Step is set to \" + _settings.step + \"ms\");\n\n  let _encoders = {\n    webm: CCWebMEncoder,\n    \"webm-mediarecorder\": CCStreamEncoder,\n  };\n\n  let ctor = _encoders[_settings.format];\n  if (!ctor) {\n    throw (\n      \"Error: Incorrect or missing format: Valid formats are \" +\n      Object.keys(_encoders).join(\", \")\n    );\n  }\n\n  if (\"performance\" in window == false) {\n    window.performance = {};\n  }\n\n  Date.now =\n    Date.now ||\n    function () {\n      // thanks IE8\n      return new Date().getTime();\n    };\n\n  if (\"now\" in window.performance == false) {\n    let nowOffset = Date.now();\n\n    if (performance.timing && performance.timing.navigationStart) {\n      nowOffset = performance.timing.navigationStart;\n    }\n\n    window.performance.now = function now() {\n      return Date.now() - nowOffset;\n    };\n  }\n\n  const _oldSetTimeout = window.setTimeout,\n    _oldSetInterval = window.setInterval,\n    _oldClearInterval = window.clearInterval,\n    _oldClearTimeout = window.clearTimeout,\n    _oldRequestAnimationFrame = window.requestAnimationFrame,\n    _oldNow = window.Date.now,\n    _oldPerformanceNow = window.performance.now,\n    _oldGetTime = window.Date.prototype.getTime;\n\n  let media = [];\n\n  function _init() {\n    _log(\"Capturer start\");\n\n    _startTime = window.Date.now();\n    _time = _startTime + _settings.startTime;\n    _performanceStartTime = window.performance.now();\n    _performanceTime = _performanceStartTime + _settings.startTime;\n\n    window.Date.prototype.getTime = function () {\n      return _time;\n    };\n    window.Date.now = function () {\n      return _time;\n    };\n\n    window.setTimeout = function (callback, time) {\n      let t = {\n        callback: callback,\n        time: time,\n        triggerTime: _time + time,\n      };\n      _timeouts.push(t);\n      _log(\"Timeout set to \" + t.time);\n      return t;\n    };\n    window.clearTimeout = function (id) {\n      for (let j = 0; j < _timeouts.length; j++) {\n        if (_timeouts[j] == id) {\n          _timeouts.splice(j, 1);\n          _log(\"Timeout cleared\");\n          continue;\n        }\n      }\n    };\n    window.setInterval = function (callback, time) {\n      let t = {\n        callback: callback,\n        time: time,\n        triggerTime: _time + time,\n      };\n      _intervals.push(t);\n      _log(\"Interval set to \" + t.time);\n      return t;\n    };\n    window.clearInterval = function (id) {\n      _log(\"clear Interval\");\n      return null;\n    };\n    window.requestAnimationFrame = function (callback) {\n      _requestAnimationFrameCallbacks.push(callback);\n    };\n    window.performance.now = function () {\n      return _performanceTime;\n    };\n\n    function hookCurrentTime() {\n      if (!this._hooked) {\n        this._hooked = true;\n        this._hookedTime = this.currentTime || 0;\n        this.pause();\n        media.push(this);\n      }\n      return this._hookedTime + _settings.startTime;\n    }\n\n    try {\n      Object.defineProperty(HTMLVideoElement.prototype, \"currentTime\", {\n        get: hookCurrentTime,\n      });\n      Object.defineProperty(HTMLAudioElement.prototype, \"currentTime\", {\n        get: hookCurrentTime,\n      });\n    } catch (err) {\n      _log(err);\n    }\n  }\n\n  function _start() {\n    _init();\n    _encoder.start();\n    _capturing = true;\n  }\n\n  function _stop() {\n    _capturing = false;\n    _encoder.stop();\n    _destroy();\n  }\n\n  function _call(fn, p) {\n    _oldSetTimeout(fn, 0, p);\n  }\n\n  function _step() {\n    _call(_process);\n  }\n\n  _encoder = new ctor(_settings);\n  _encoder.step = _step;\n  _encoder.on(\"process\", _process);\n  _encoder.on(\"progress\", _progress);\n\n  function _destroy() {\n    _log(\"Capturer stop\");\n    window.setTimeout = _oldSetTimeout;\n    window.setInterval = _oldSetInterval;\n    window.clearInterval = _oldClearInterval;\n    window.clearTimeout = _oldClearTimeout;\n    window.requestAnimationFrame = _oldRequestAnimationFrame;\n    window.Date.prototype.getTime = _oldGetTime;\n    window.Date.now = _oldNow;\n    window.performance.now = _oldPerformanceNow;\n  }\n\n  function _updateTime() {\n    let seconds = _frameCount / _settings.framerate;\n    if (\n      (_settings.frameLimit && _frameCount >= _settings.frameLimit) ||\n      (_settings.timeLimit && seconds >= _settings.timeLimit)\n    ) {\n      _stop();\n      _save();\n    }\n    let d = new Date(null);\n    d.setSeconds(seconds);\n    if (_settings.motionBlurFrames > 2) {\n      _timeDisplay.textContent =\n        \"CCapture \" +\n        _settings.format +\n        \" | \" +\n        _frameCount +\n        \" frames (\" +\n        _intermediateFrameCount +\n        \" inter) | \" +\n        d.toISOString().substr(11, 8);\n    } else {\n      _timeDisplay.textContent =\n        \"CCapture \" +\n        _settings.format +\n        \" | \" +\n        _frameCount +\n        \" frames | \" +\n        d.toISOString().substr(11, 8);\n    }\n  }\n\n  function _checkFrame(canvas) {\n    if (\n      canvasMotionBlur.width !== canvas.width ||\n      canvasMotionBlur.height !== canvas.height\n    ) {\n      canvasMotionBlur.width = canvas.width;\n      canvasMotionBlur.height = canvas.height;\n      bufferMotionBlur = new Uint16Array(\n        canvasMotionBlur.height * canvasMotionBlur.width * 4\n      );\n      ctxMotionBlur.fillStyle = \"#0\";\n      ctxMotionBlur.fillRect(\n        0,\n        0,\n        canvasMotionBlur.width,\n        canvasMotionBlur.height\n      );\n    }\n  }\n\n  function _blendFrame(canvas) {\n    ctxMotionBlur.drawImage(canvas, 0, 0);\n    imageData = ctxMotionBlur.getImageData(\n      0,\n      0,\n      canvasMotionBlur.width,\n      canvasMotionBlur.height\n    );\n    for (let j = 0; j < bufferMotionBlur.length; j += 4) {\n      bufferMotionBlur[j] += imageData.data[j];\n      bufferMotionBlur[j + 1] += imageData.data[j + 1];\n      bufferMotionBlur[j + 2] += imageData.data[j + 2];\n    }\n    _intermediateFrameCount++;\n  }\n\n  function _saveFrame() {\n    let data = imageData.data;\n    for (let j = 0; j < bufferMotionBlur.length; j += 4) {\n      data[j] = (bufferMotionBlur[j] * 2) / _settings.motionBlurFrames;\n      data[j + 1] = (bufferMotionBlur[j + 1] * 2) / _settings.motionBlurFrames;\n      data[j + 2] = (bufferMotionBlur[j + 2] * 2) / _settings.motionBlurFrames;\n    }\n    ctxMotionBlur.putImageData(imageData, 0, 0);\n    _encoder.add(canvasMotionBlur);\n    _frameCount++;\n    _intermediateFrameCount = 0;\n    _log(\"Full MB Frame! \" + _frameCount + \" \" + _time);\n    for (let j = 0; j < bufferMotionBlur.length; j += 4) {\n      bufferMotionBlur[j] = 0;\n      bufferMotionBlur[j + 1] = 0;\n      bufferMotionBlur[j + 2] = 0;\n    }\n    gc();\n  }\n\n  function _capture(canvas) {\n    if (_capturing) {\n      if (_settings.motionBlurFrames > 2) {\n        _checkFrame(canvas);\n        _blendFrame(canvas);\n\n        if (_intermediateFrameCount >= 0.5 * _settings.motionBlurFrames) {\n          _saveFrame();\n        } else {\n          _step();\n        }\n      } else {\n        _encoder.add(canvas);\n        _frameCount++;\n        _log(\"Full Frame! \" + _frameCount);\n      }\n    }\n  }\n\n  function _process() {\n    let step = 1000 / _settings.framerate;\n    let dt =\n      (_frameCount + _intermediateFrameCount / _settings.motionBlurFrames) *\n      step;\n\n    _time = _startTime + dt;\n    _performanceTime = _performanceStartTime + dt;\n\n    media.forEach(function (v) {\n      v._hookedTime = dt / 1000;\n    });\n\n    _updateTime();\n    _log(\"Frame: \" + _frameCount + \" \" + _intermediateFrameCount);\n\n    for (let j = 0; j < _timeouts.length; j++) {\n      if (_time >= _timeouts[j].triggerTime) {\n        _call(_timeouts[j].callback);\n        _timeouts.splice(j, 1);\n        continue;\n      }\n    }\n\n    for (let j = 0; j < _intervals.length; j++) {\n      if (_time >= _intervals[j].triggerTime) {\n        _call(_intervals[j].callback);\n        _intervals[j].triggerTime += _intervals[j].time;\n        continue;\n      }\n    }\n\n    _requestAnimationFrameCallbacks.forEach(function (cb) {\n      _call(cb, _time - g_startTime);\n    });\n    _requestAnimationFrameCallbacks = [];\n  }\n\n  function _save(callback) {\n    if (!callback) {\n      callback = function (blob) {\n        download(\n          blob,\n          _encoder.filename + _encoder.extension,\n          _encoder.mimeType\n        );\n        return false;\n      };\n    }\n    _encoder.save(callback);\n  }\n\n  function _log(message) {\n    if (_verbose) console.log(message);\n  }\n\n  function _on(event, handler) {\n    _handlers[event] = handler;\n  }\n\n  function _emit(event) {\n    let handler = _handlers[event];\n    if (handler) {\n      handler.apply(null, Array.prototype.slice.call(arguments, 1));\n    }\n  }\n\n  function _progress(progress) {\n    _emit(\"progress\", progress);\n  }\n\n  return {\n    start: _start,\n    capture: _capture,\n    stop: _stop,\n    save: _save,\n    on: _on,\n  };\n}\n\nexport { CCapture };\n", "import { CCapture } from \"./vendor/ccapture-1.0.9\";\n\ndeclare global {\n  interface Window {\n    CCapture: any;\n  }\n}\n\nexport type CapturerSettings = {\n  element?: HTMLCanvasElement; // <canvas> element to capture\n  frameCount?: number; // total number of frames to capture\n  display?: boolean; // show CCapture HUD\n  frameRate?: number; // defaults to 60\n  onComplete?: Function; // callback on recording completion\n};\n\nexport default class Capturer {\n  running: boolean;\n  active: boolean;\n  capture: ReturnType<typeof CCapture>;\n  maxFrames: number;\n  frames: number;\n  el: HTMLCanvasElement;\n  onComplete: Function;\n\n  constructor() {\n    this.active = false;\n    this.running = false;\n  }\n\n  enableCapture(settings: CapturerSettings = {}) {\n    this.active = true;\n    this.el = settings.element || document.querySelector(\"canvas\");\n    this.maxFrames = settings.frameCount || 600;\n    this.capture = CCapture({\n      framerate: settings.frameRate || 60,\n      format: \"webm\", // required\n      verbose: false,\n      display: !!settings.display,\n    });\n    this.onComplete = settings.onComplete || function () {};\n  }\n\n  // must be safe to call on every frame\n  startCapture() {\n    if (this.active && !this.running) {\n      this.capture.start();\n      this.frames = 0;\n      this.running = true;\n    }\n  }\n\n  captureFrame() {\n    if (this.active) {\n      this.capture.capture(this.el);\n      this.frames++;\n\n      if (this.frames >= this.maxFrames) {\n        console.log(\"[captureFrame] end\");\n        this.capture.stop();\n        this.capture.save();\n        this.onComplete();\n        this.active = false;\n      }\n    }\n  }\n}\n", "import Capturer, { CapturerSettings } from \"./Capturer\";\n\ndeclare global {\n  interface Window {\n    p5?: any;\n    enableCapture: (settings: CapturerSettings) => void;\n    captureFrame: () => void;\n  }\n}\n\nif (window) {\n  // running in a browser, attach capturer to global window object\n  const capturer = new Capturer();\n\n  const enable = capturer.enableCapture.bind(capturer);\n  const start = capturer.startCapture.bind(capturer);\n  const capture = capturer.captureFrame.bind(capturer);\n\n  if (window.p5) {\n    const p5 = window.p5;\n\n    p5.prototype.enableCapture = enable;\n\n    p5.prototype.registerMethod(\"init\", () => {\n      (this as any).enableCapture = enable;\n    });\n\n    p5.prototype.registerMethod(\"pre\", () => {\n      start();\n    });\n\n    p5.prototype.registerMethod(\"post\", () => {\n      try {\n        capture();\n      } catch (ex) {\n        console.error(ex);\n      }\n    });\n    console.log(\"[webm-capture] registered with p5.js\");\n  } else {\n    console.error([\n      \"[webm-capture] ERROR! Could not find p5 object. Make sure the p5.js <script> tag is included in the page before p5.webm-capture.\",\n    ]);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
