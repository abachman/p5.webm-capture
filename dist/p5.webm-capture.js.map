{
  "version": 3,
  "sources": ["../src/vendor/webm-writer-0.2.0.js", "../src/vendor/ccapture.js", "../src/capturer.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * A tool for presenting an ArrayBuffer as a stream for writing some simple data types.\n * \n * By Nicholas Sherlock\n * \n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n\"use strict\";\n\n(function(){\n\n    // var isNodeEnviroment = typeof module !== 'undefined' && typeof module.exports !== 'undefined';\n    var isNodeEnviroment = false;\n\n    /**\n     * Create an ArrayBuffer of the given length and present it as a writable stream with methods\n     * for writing data in different formats.\n     */\n\n    var ArrayBufferDataStream = function(length) {\n        this.data = new Uint8Array(length);\n        this.pos = 0;\n    };\n    \n    ArrayBufferDataStream.prototype.seek = function(offset) {\n        this.pos = offset;\n    };\n\n    ArrayBufferDataStream.prototype.writeBytes = function(arr) {\n        for (var i = 0; i < arr.length; i++) {\n            this.data[this.pos++] = arr[i];\n        }\n    };\n\n    ArrayBufferDataStream.prototype.writeByte = function(b) {\n        this.data[this.pos++] = b;\n    };\n    \n    //Synonym:\n    ArrayBufferDataStream.prototype.writeU8 = ArrayBufferDataStream.prototype.writeByte;\n    \n    ArrayBufferDataStream.prototype.writeU16BE = function(u) {\n        this.data[this.pos++] = u >> 8;\n        this.data[this.pos++] = u;\n    };\n\n    ArrayBufferDataStream.prototype.writeDoubleBE = function(d) {\n        var \n            bytes = new Uint8Array(new Float64Array([d]).buffer);\n        \n        for (var i = bytes.length - 1; i >= 0; i--) {\n            this.writeByte(bytes[i]);\n        }\n    };\n\n    ArrayBufferDataStream.prototype.writeFloatBE = function(d) {\n        var \n            bytes = new Uint8Array(new Float32Array([d]).buffer);\n        \n        for (var i = bytes.length - 1; i >= 0; i--) {\n            this.writeByte(bytes[i]);\n        }\n    };\n\n    /**\n     * Write an ASCII string to the stream\n     */\n    ArrayBufferDataStream.prototype.writeString = function(s) {\n        for (var i = 0; i < s.length; i++) {\n            this.data[this.pos++] = s.charCodeAt(i);\n        }\n    };\n\n    /**\n     * Write the given 32-bit integer to the stream as an EBML variable-length integer using the given byte width \n     * (use measureEBMLVarInt).\n     * \n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     * \n     * @param i Integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n    ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function(i, width) {\n        switch (width) {\n            case 1:\n                this.writeU8((1 << 7) | i);\n            break;\n            case 2:\n                this.writeU8((1 << 6) | (i >> 8));\n                this.writeU8(i);\n            break;\n            case 3:\n                this.writeU8((1 << 5) | (i >> 16));\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            case 4:\n                this.writeU8((1 << 4) | (i >> 24));\n                this.writeU8(i >> 16);\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            case 5:\n                /* \n                 * JavaScript converts its doubles to 32-bit integers for bitwise operations, so we need to do a \n                 * division by 2^32 instead of a right-shift of 32 to retain those top 3 bits\n                 */\n                this.writeU8((1 << 3) | ((i / 4294967296) & 0x7)); \n                this.writeU8(i >> 24);\n                this.writeU8(i >> 16);\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            default:\n                throw new RuntimeException(\"Bad EBML VINT size \" + width);\n        }\n    };\n    \n    /**\n     * Return the number of bytes needed to encode the given integer as an EBML VINT.\n     */\n    ArrayBufferDataStream.prototype.measureEBMLVarInt = function(val) {\n        if (val < (1 << 7) - 1) { \n            /* Top bit is set, leaving 7 bits to hold the integer, but we can't store 127 because\n             * \"all bits set to one\" is a reserved value. Same thing for the other cases below:\n             */\n            return 1;\n        } else if (val < (1 << 14) - 1) {\n            return 2;\n        } else if (val < (1 << 21) - 1) {\n            return 3;\n        } else if (val < (1 << 28) - 1) {\n            return 4;\n        } else if (val < 34359738367) { // 2 ^ 35 - 1 (can address 32GB)\n            return 5;\n        } else {\n            throw new RuntimeException(\"EBML VINT size not supported \" + val);\n        }\n    };\n    \n    ArrayBufferDataStream.prototype.writeEBMLVarInt = function(i) {\n        this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));\n    };\n    \n    /**\n     * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     * \n     * Omit the width parameter to have it determined automatically for you.\n     * \n     * @param u Unsigned integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n    ArrayBufferDataStream.prototype.writeUnsignedIntBE = function(u, width) {\n        if (width === undefined) {\n            width = this.measureUnsignedInt(u);\n        }\n        \n        // Each case falls through:\n        switch (width) {\n            case 5:\n                this.writeU8(Math.floor(u / 4294967296)); // Need to use division to access >32 bits of floating point var\n            case 4:\n                this.writeU8(u >> 24);\n            case 3:\n                this.writeU8(u >> 16);\n            case 2:\n                this.writeU8(u >> 8);\n            case 1:\n                this.writeU8(u);\n            break;\n            default:\n                throw new RuntimeException(\"Bad UINT size \" + width);\n        }\n    };\n    \n    /**\n     * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.\n     */\n    ArrayBufferDataStream.prototype.measureUnsignedInt = function(val) {\n        // Force to 32-bit unsigned integer\n        if (val < (1 << 8)) {\n            return 1;\n        } else if (val < (1 << 16)) {\n            return 2;\n        } else if (val < (1 << 24)) {\n            return 3;\n        } else if (val < 4294967296) {\n            return 4;\n        } else {\n            return 5;\n        }\n    };\n\n    /**\n     * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.\n     */\n    ArrayBufferDataStream.prototype.getAsDataArray = function() {\n        if (this.pos < this.data.byteLength) {\n            return this.data.subarray(0, this.pos);\n        } else if (this.pos == this.data.byteLength) {\n            return this.data;\n        } else {\n            throw \"ArrayBufferDataStream's pos lies beyond end of buffer\";\n        }\n    };\n\n    window.ArrayBufferDataStream = ArrayBufferDataStream;\n\n    /**\n     * Allows a series of Blob-convertible objects (ArrayBuffer, Blob, String, etc) to be added to a buffer. Seeking and\n     * overwriting of blobs is allowed.\n     *\n     * You can supply a FileWriter, in which case the BlobBuffer is just used as temporary storage before it writes it\n     * through to the disk.\n     *\n     * By Nicholas Sherlock\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n\tvar BlobBuffer = function(fs) {\n\t\treturn function(destination) {\n\t\t\tvar\n\t\t\t\tbuffer = [],\n\t\t\t\twritePromise = Promise.resolve(),\n\t\t\t\tfileWriter = null,\n\t\t\t\tfd = null;\n\t\t\t\n\t\t\tif (typeof FileWriter !== \"undefined\" && destination instanceof FileWriter) {\n\t\t\t\tfileWriter = destination;\n\t\t\t} else if (fs && destination) {\n\t\t\t\tfd = destination;\n\t\t\t}\n\t\t\t\n\t\t\t// Current seek offset\n\t\t\tthis.pos = 0;\n\t\t\t\n\t\t\t// One more than the index of the highest byte ever written\n\t\t\tthis.length = 0;\n\t\t\t\n\t\t\t// Returns a promise that converts the blob to an ArrayBuffer\n\t\t\tfunction readBlobAsBuffer(blob) {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tvar\n\t\t\t\t\t\treader = new FileReader();\n\t\t\t\t\t\n\t\t\t\t\treader.addEventListener(\"loadend\", function () {\n\t\t\t\t\t\tresolve(reader.result);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\treader.readAsArrayBuffer(blob);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction convertToUint8Array(thing) {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tif (thing instanceof Uint8Array) {\n\t\t\t\t\t\tresolve(thing);\n\t\t\t\t\t} else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {\n\t\t\t\t\t\tresolve(new Uint8Array(thing));\n\t\t\t\t\t} else if (thing instanceof Blob) {\n\t\t\t\t\t\tresolve(readBlobAsBuffer(thing).then(function (buffer) {\n\t\t\t\t\t\t\treturn new Uint8Array(buffer);\n\t\t\t\t\t\t}));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Assume that Blob will know how to read this thing\n\t\t\t\t\t\tresolve(readBlobAsBuffer(new Blob([thing])).then(function (buffer) {\n\t\t\t\t\t\t\treturn new Uint8Array(buffer);\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction measureData(data) {\n\t\t\t\tvar\n\t\t\t\t\tresult = data.byteLength || data.length || data.size;\n\t\t\t\t\n\t\t\t\tif (!Number.isInteger(result)) {\n\t\t\t\t\tthrow \"Failed to determine size of element\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\t/**\n\t\t\t * Seek to the given absolute offset.\n\t\t\t *\n\t\t\t * You may not seek beyond the end of the file (this would create a hole and/or allow blocks to be written in non-\n\t\t\t * sequential order, which isn't currently supported by the memory buffer backend).\n\t\t\t */\n\t\t\tthis.seek = function (offset) {\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tthrow \"Offset may not be negative\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isNaN(offset)) {\n\t\t\t\t\tthrow \"Offset may not be NaN\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (offset > this.length) {\n\t\t\t\t\tthrow \"Seeking beyond the end of file is not allowed\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.pos = offset;\n\t\t\t};\n\t\t\t\n\t\t\t/**\n\t\t\t * Write the Blob-convertible data to the buffer at the current seek position.\n\t\t\t *\n\t\t\t * Note: If overwriting existing data, the write must not cross preexisting block boundaries (written data must\n\t\t\t * be fully contained by the extent of a previous write).\n\t\t\t */\n\t\t\tthis.write = function (data) {\n\t\t\t\tvar\n\t\t\t\t\tnewEntry = {\n\t\t\t\t\t\toffset: this.pos,\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\tlength: measureData(data)\n\t\t\t\t\t},\n\t\t\t\t\tisAppend = newEntry.offset >= this.length;\n\t\t\t\t\n\t\t\t\tthis.pos += newEntry.length;\n\t\t\t\tthis.length = Math.max(this.length, this.pos);\n\t\t\t\t\n\t\t\t\t// After previous writes complete, perform our write\n\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\tif (fd) {\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\t\t\t\tconvertToUint8Array(newEntry.data).then(function(dataArray) {\n\t\t\t\t\t\t\t\tvar\n\t\t\t\t\t\t\t\t\ttotalWritten = 0,\n\t\t\t\t\t\t\t\t\tbuffer = Buffer.from(dataArray.buffer),\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\thandleWriteComplete = function(err, written, buffer) {\n\t\t\t\t\t\t\t\t\t\ttotalWritten += written;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (totalWritten >= buffer.length) {\n\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// We still have more to write...\n\t\t\t\t\t\t\t\t\t\t\tfs.write(fd, buffer, totalWritten, buffer.length - totalWritten, newEntry.offset + totalWritten, handleWriteComplete);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tfs.write(fd, buffer, 0, buffer.length, newEntry.offset, handleWriteComplete);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (fileWriter) {\n\t\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\t\tfileWriter.onwriteend = resolve;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfileWriter.seek(newEntry.offset);\n\t\t\t\t\t\t\tfileWriter.write(new Blob([newEntry.data]));\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!isAppend) {\n\t\t\t\t\t\t// We might be modifying a write that was already buffered in memory.\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Slow linear search to find a block we might be overwriting\n\t\t\t\t\t\tfor (var i = 0; i < buffer.length; i++) {\n\t\t\t\t\t\t\tvar\n\t\t\t\t\t\t\t\tentry = buffer[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If our new entry overlaps the old one in any way...\n\t\t\t\t\t\t\tif (!(newEntry.offset + newEntry.length <= entry.offset || newEntry.offset >= entry.offset + entry.length)) {\n\t\t\t\t\t\t\t\tif (newEntry.offset < entry.offset || newEntry.offset + newEntry.length > entry.offset + entry.length) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Overwrite crosses blob boundaries\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (newEntry.offset == entry.offset && newEntry.length == entry.length) {\n\t\t\t\t\t\t\t\t\t// We overwrote the entire block\n\t\t\t\t\t\t\t\t\tentry.data = newEntry.data;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// We're done\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn convertToUint8Array(entry.data)\n\t\t\t\t\t\t\t\t\t\t.then(function (entryArray) {\n\t\t\t\t\t\t\t\t\t\t\tentry.data = entryArray;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\treturn convertToUint8Array(newEntry.data);\n\t\t\t\t\t\t\t\t\t\t}).then(function (newEntryArray) {\n\t\t\t\t\t\t\t\t\t\t\tnewEntry.data = newEntryArray;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tentry.data.set(newEntry.data, newEntry.offset - entry.offset);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Else fall through to do a simple append, as we didn't overwrite any pre-existing blocks\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbuffer.push(newEntry);\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t/**\n\t\t\t * Finish all writes to the buffer, returning a promise that signals when that is complete.\n\t\t\t *\n\t\t\t * If a FileWriter was not provided, the promise is resolved with a Blob that represents the completed BlobBuffer\n\t\t\t * contents. You can optionally pass in a mimeType to be used for this blob.\n\t\t\t *\n\t\t\t * If a FileWriter was provided, the promise is resolved with null as the first argument.\n\t\t\t */\n\t\t\tthis.complete = function (mimeType) {\n\t\t\t\tif (fd || fileWriter) {\n\t\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// After writes complete we need to merge the buffer to give to the caller\n\t\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\t\tvar\n\t\t\t\t\t\t\tresult = [];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (var i = 0; i < buffer.length; i++) {\n\t\t\t\t\t\t\tresult.push(buffer[i].data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn new Blob(result, {mimeType: mimeType});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn writePromise;\n\t\t\t};\n\t\t};\n\t}(null);\n\t\n\twindow.BlobBuffer = BlobBuffer;\n\n    /**\n     * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n     * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n     *\n     * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n     * eventually returned as one composite Blob.\n     *\n     * By Nicholas Sherlock.\n     *\n     * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n    var WebMWriter = function(ArrayBufferDataStream, BlobBuffer) {\n        function extend(base, top) {\n            var\n                target = {};\n            \n            [base, top].forEach(function(obj) {\n                for (var prop in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                        target[prop] = obj[prop];\n                    }\n                }\n            });\n            \n            return target;\n        }\n        \n        /**\n         * Decode a Base64 data URL into a binary string.\n         *\n         * Returns the binary string, or false if the URL could not be decoded.\n         */\n        function decodeBase64WebPDataURL(url) {\n            if (typeof url !== \"string\" || !url.match(/^data:image\\/webp;base64,/i)) {\n                return false;\n            }\n            \n            return window.atob(url.substring(\"data:image\\/webp;base64,\".length));\n        }\n        \n        /**\n         * Convert a raw binary string (one character = one output byte) to an ArrayBuffer\n         */\n        function stringToArrayBuffer(string) {\n            var\n                buffer = new ArrayBuffer(string.length),\n                int8Array = new Uint8Array(buffer);\n            \n            for (var i = 0; i < string.length; i++) {\n                int8Array[i] = string.charCodeAt(i);\n            }\n            \n            return buffer;\n        }\n        \n        /**\n         * Convert the given canvas to a WebP encoded image and return the image data as a string.\n         */\n        function renderAsWebP(canvas, quality) {\n            var\n                frame = canvas.toDataURL('image/webp', {quality: quality});\n            \n            return decodeBase64WebPDataURL(frame);\n        }\n        \n        function extractKeyframeFromWebP(webP) {\n            // Assume that Chrome will generate a Simple Lossy WebP which has this header:\n            var\n                keyframeStartIndex = webP.indexOf('VP8 ');\n            \n            if (keyframeStartIndex == -1) {\n                throw \"Failed to identify beginning of keyframe in WebP image\";\n            }\n            \n            // Skip the header and the 4 bytes that encode the length of the VP8 chunk\n            keyframeStartIndex += 'VP8 '.length + 4;\n            \n            return webP.substring(keyframeStartIndex);\n        }\n        \n        // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n        function EBMLFloat32(value) {\n            this.value = value;\n        }\n        \n        function EBMLFloat64(value) {\n            this.value = value;\n        }\n        \n        /**\n         * Write the given EBML object to the provided ArrayBufferStream.\n         *\n         * The buffer's first byte is at bufferFileOffset inside the video file. This is used to complete offset and\n         * dataOffset fields in each EBML structure, indicating the file offset of the first byte of the EBML element and\n         * its data payload.\n         */\n        function writeEBML(buffer, bufferFileOffset, ebml) {\n            // Is the ebml an array of sibling elements?\n            if (Array.isArray(ebml)) {\n                for (var i = 0; i < ebml.length; i++) {\n                    writeEBML(buffer, bufferFileOffset, ebml[i]);\n                }\n            // Is this some sort of raw data that we want to write directly?\n            } else if (typeof ebml === \"string\") {\n                buffer.writeString(ebml);\n            } else if (ebml instanceof Uint8Array) {\n                buffer.writeBytes(ebml);\n            } else if (ebml.id){\n                // We're writing an EBML element\n                ebml.offset = buffer.pos + bufferFileOffset;\n                \n                buffer.writeUnsignedIntBE(ebml.id); // ID field\n                \n                // Now we need to write the size field, so we must know the payload size:\n                \n                if (Array.isArray(ebml.data)) {\n                    // Writing an array of child elements. We won't try to measure the size of the children up-front\n                    \n                    var\n                        sizePos, dataBegin, dataEnd;\n                    \n                    if (ebml.size === -1) {\n                        // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n                        buffer.writeByte(0xFF);\n                    } else {\n                        sizePos = buffer.pos;\n                        \n                        /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n                         * which should be plenty (we don't want to have to buffer that much data in memory at one time\n                         * anyway!)\n                         */\n                        buffer.writeBytes([0, 0, 0, 0]);\n                    }\n                    \n                    dataBegin = buffer.pos;\n                    \n                    ebml.dataOffset = dataBegin + bufferFileOffset;\n                    writeEBML(buffer, bufferFileOffset, ebml.data);\n                    \n                    if (ebml.size !== -1) {\n                        dataEnd = buffer.pos;\n                        \n                        ebml.size = dataEnd - dataBegin;\n                        \n                        buffer.seek(sizePos);\n                        buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n                        \n                        buffer.seek(dataEnd);\n                    }\n                } else if (typeof ebml.data === \"string\") {\n                    buffer.writeEBMLVarInt(ebml.data.length); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeString(ebml.data);\n                } else if (typeof ebml.data === \"number\") {\n                    // Allow the caller to explicitly choose the size if they wish by supplying a size field\n                    if (!ebml.size) {\n                        ebml.size = buffer.measureUnsignedInt(ebml.data);\n                    }\n                    \n                    buffer.writeEBMLVarInt(ebml.size); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n                } else if (ebml.data instanceof EBMLFloat64) {\n                    buffer.writeEBMLVarInt(8); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeDoubleBE(ebml.data.value);\n                } else if (ebml.data instanceof EBMLFloat32) {\n                    buffer.writeEBMLVarInt(4); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeFloatBE(ebml.data.value);\n                } else if (ebml.data instanceof Uint8Array) {\n                    buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeBytes(ebml.data);\n                } else {\n                    throw \"Bad EBML datatype \" + typeof ebml.data;\n                }\n            } else {\n                throw \"Bad EBML datatype \" + typeof ebml.data;\n            }\n        }\n        \n        return function(options) {\n            var\n                MAX_CLUSTER_DURATION_MSEC = 5000,\n                DEFAULT_TRACK_NUMBER = 1,\n            \n                writtenHeader = false,\n                videoWidth, videoHeight,\n                \n                clusterFrameBuffer = [],\n                clusterStartTime = 0,\n                clusterDuration = 0,\n                \n                optionDefaults = {\n                    quality: 0.95,       // WebM image quality from 0.0 (worst) to 1.0 (best)\n                    fileWriter: null,    // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n                    fd: null,            // Node.JS file descriptor to write to instead of buffering (optional)\n                    \n                    // You must supply one of:\n                    frameDuration: null, // Duration of frames in milliseconds\n                    frameRate: null,     // Number of frames per second\n                },\n                \n                seekPoints = {\n                    Cues: {id: new Uint8Array([0x1C, 0x53, 0xBB, 0x6B]), positionEBML: null},\n                    SegmentInfo: {id: new Uint8Array([0x15, 0x49, 0xA9, 0x66]), positionEBML: null},\n                    Tracks: {id: new Uint8Array([0x16, 0x54, 0xAE, 0x6B]), positionEBML: null},\n                },\n                \n                ebmlSegment,\n                segmentDuration = {\n                    \"id\": 0x4489, // Duration\n                    \"data\": new EBMLFloat64(0)\n                },\n                \n                seekHead,\n                \n                cues = [],\n                \n                blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n    \n            function fileOffsetToSegmentRelative(fileOffset) {\n                return fileOffset - ebmlSegment.dataOffset;\n            }\n            \n            /**\n             * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n             *\n             * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n             * to be overwritten later.\n             */\n            function createSeekHead() {\n                var\n                    seekPositionEBMLTemplate = {\n                        \"id\": 0x53AC, // SeekPosition\n                        \"size\": 5, // Allows for 32GB video files\n                        \"data\": 0 // We'll overwrite this when the file is complete\n                    },\n                    \n                    result = {\n                        \"id\": 0x114D9B74, // SeekHead\n                        \"data\": []\n                    };\n                \n                for (var name in seekPoints) {\n                    var\n                        seekPoint = seekPoints[name];\n                \n                    seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n                    \n                    result.data.push({\n                         \"id\": 0x4DBB, // Seek\n                         \"data\": [\n                              {\n                                  \"id\": 0x53AB, // SeekID\n                                  \"data\": seekPoint.id\n                              },\n                              seekPoint.positionEBML\n                         ]\n                    });\n                }\n                \n                return result;\n            }\n            \n            /**\n             * Write the WebM file header to the stream.\n             */\n            function writeHeader() {\n                seekHead = createSeekHead();\n                \n                var\n                    ebmlHeader = {\n                        \"id\": 0x1a45dfa3, // EBML\n                        \"data\": [\n                            {\n                                \"id\": 0x4286, // EBMLVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f7, // EBMLReadVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f2, // EBMLMaxIDLength\n                                \"data\": 4\n                            },\n                            {\n                                \"id\": 0x42f3, // EBMLMaxSizeLength\n                                \"data\": 8\n                            },\n                            {\n                                \"id\": 0x4282, // DocType\n                                \"data\": \"webm\"\n                            },\n                            {\n                                \"id\": 0x4287, // DocTypeVersion\n                                \"data\": 2\n                            },\n                            {\n                                \"id\": 0x4285, // DocTypeReadVersion\n                                \"data\": 2\n                            }\n                        ]\n                    },\n                    \n                    segmentInfo = {\n                        \"id\": 0x1549a966, // Info\n                        \"data\": [\n                            {\n                                \"id\": 0x2ad7b1, // TimecodeScale\n                                \"data\": 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n                            },\n                            {\n                                \"id\": 0x4d80, // MuxingApp\n                                \"data\": \"webm-writer-js\",\n                            },\n                            {\n                                \"id\": 0x5741, // WritingApp\n                                \"data\": \"webm-writer-js\"\n                            },\n                            segmentDuration // To be filled in later\n                        ]\n                    },\n                    \n                    tracks = {\n                        \"id\": 0x1654ae6b, // Tracks\n                        \"data\": [\n                            {\n                                \"id\": 0xae, // TrackEntry\n                                \"data\": [\n                                    {\n                                        \"id\": 0xd7, // TrackNumber\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x73c5, // TrackUID\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x9c, // FlagLacing\n                                        \"data\": 0\n                                    },\n                                    {\n                                        \"id\": 0x22b59c, // Language\n                                        \"data\": \"und\"\n                                    },\n                                    {\n                                        \"id\": 0x86, // CodecID\n                                        \"data\": \"V_VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x258688, // CodecName\n                                        \"data\": \"VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x83, // TrackType\n                                        \"data\": 1\n                                    },\n                                    {\n                                        \"id\": 0xe0,  // Video\n                                        \"data\": [\n                                            {\n                                                \"id\": 0xb0, // PixelWidth\n                                                \"data\": videoWidth\n                                            },\n                                            {\n                                                \"id\": 0xba, // PixelHeight\n                                                \"data\": videoHeight\n                                            }\n                                        ]\n                                    }\n                                ]\n                            }\n                        ]\n                    };\n                \n                ebmlSegment = {\n                    \"id\": 0x18538067, // Segment\n                    \"size\": -1, // Unbounded size\n                    \"data\": [\n                        seekHead,\n                        segmentInfo,\n                        tracks,\n                    ]\n                };\n                \n                var\n                    bufferStream = new ArrayBufferDataStream(256);\n                    \n                writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n                blobBuffer.write(bufferStream.getAsDataArray());\n                \n                // Now we know where these top-level elements lie in the file:\n                seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n                seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n            };\n            \n            /**\n             * Create a SimpleBlock keyframe header using these fields:\n             *     timecode    - Time of this keyframe\n             *     trackNumber - Track number from 1 to 126 (inclusive)\n             *     frame       - Raw frame data payload string\n             *\n             * Returns an EBML element.\n             */\n            function createKeyframeBlock(keyframe) {\n                var\n                    bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n                \n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n                    throw \"TrackNumber must be > 0 and < 127\";\n                }\n    \n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                \n                // Flags byte\n                bufferStream.writeByte(\n                    1 << 7 // Keyframe\n                );\n                \n                return {\n                    \"id\": 0xA3, // SimpleBlock\n                    \"data\": [\n                         bufferStream.getAsDataArray(),\n                         keyframe.frame\n                    ]\n                };\n            }\n            \n            /**\n             * Create a Cluster node using these fields:\n             *\n             *    timecode    - Start time for the cluster\n             *\n             * Returns an EBML element.\n             */\n            function createCluster(cluster) {\n                return {\n                    \"id\": 0x1f43b675,\n                    \"data\": [\n                         {\n                            \"id\": 0xe7, // Timecode\n                            \"data\": Math.round(cluster.timecode)\n                         }\n                    ]\n                };\n            }\n            \n            function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n                cues.push({\n                    \"id\": 0xBB, // Cue\n                    \"data\": [\n                         {\n                             \"id\": 0xB3, // CueTime\n                             \"data\": clusterTime\n                         },\n                         {\n                             \"id\": 0xB7, // CueTrackPositions\n                             \"data\": [\n                                  {\n                                      \"id\": 0xF7, // CueTrack\n                                      \"data\": trackIndex\n                                  },\n                                  {\n                                      \"id\": 0xF1, // CueClusterPosition\n                                      \"data\": fileOffsetToSegmentRelative(clusterFileOffset)\n                                  }\n                             ]\n                         }\n                    ]\n                });\n            }\n            \n            /**\n             * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n             * The seek entry for the Cues in the SeekHead is updated.\n             */\n            function writeCues() {\n                var\n                    ebml = {\n                        \"id\": 0x1C53BB6B,\n                        \"data\": cues\n                    },\n                    \n                    cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n                \n                writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n                blobBuffer.write(cuesBuffer.getAsDataArray());\n                \n                // Now we know where the Cues element has ended up, we can update the SeekHead\n                seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n            }\n            \n            /**\n             * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n             */\n            function flushClusterFrameBuffer() {\n                if (clusterFrameBuffer.length == 0) {\n                    return;\n                }\n    \n                // First work out how large of a buffer we need to hold the cluster data\n                var\n                    rawImageSize = 0;\n                \n                for (var i = 0; i < clusterFrameBuffer.length; i++) {\n                    rawImageSize += clusterFrameBuffer[i].frame.length;\n                }\n                \n                var\n                    buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 32), // Estimate 32 bytes per SimpleBlock header\n    \n                    cluster = createCluster({\n                        timecode: Math.round(clusterStartTime),\n                    });\n                    \n                for (var i = 0; i < clusterFrameBuffer.length; i++) {\n                    cluster.data.push(createKeyframeBlock(clusterFrameBuffer[i]));\n                }\n                \n                writeEBML(buffer, blobBuffer.pos, cluster);\n                blobBuffer.write(buffer.getAsDataArray());\n                \n                addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n                \n                clusterFrameBuffer = [];\n                clusterStartTime += clusterDuration;\n                clusterDuration = 0;\n            }\n            \n            function validateOptions() {\n                // Derive frameDuration setting if not already supplied\n                if (!options.frameDuration) {\n                    if (options.frameRate) {\n                        options.frameDuration = 1000 / options.frameRate;\n                    } else {\n                        throw \"Missing required frameDuration or frameRate setting\";\n                    }\n                }\n            }\n            \n            function addFrameToCluster(frame) {\n                frame.trackNumber = DEFAULT_TRACK_NUMBER;\n                \n                // Frame timecodes are relative to the start of their cluster:\n                frame.timecode = Math.round(clusterDuration);\n    \n                clusterFrameBuffer.push(frame);\n                \n                clusterDuration += frame.duration;\n                \n                if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n                    flushClusterFrameBuffer();\n                }\n            }\n            \n            /**\n             * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n             *\n             * Call once writing is complete (so the offset of all top level elements is known).\n             */\n            function rewriteSeekHead() {\n                var\n                    seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n                    oldPos = blobBuffer.pos;\n                \n                // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n                writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);\n                \n                // And write that through to the file\n                blobBuffer.seek(seekHead.dataOffset);\n                blobBuffer.write(seekHeadBuffer.getAsDataArray());\n    \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n             */\n            function rewriteDuration() {\n                var\n                    buffer = new ArrayBufferDataStream(8),\n                    oldPos = blobBuffer.pos;\n                \n                // Rewrite the data payload (don't need to update the id or size)\n                buffer.writeDoubleBE(clusterStartTime);\n                \n                // And write that through to the file\n                blobBuffer.seek(segmentDuration.dataOffset);\n                blobBuffer.write(buffer.getAsDataArray());\n        \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Add a frame to the video. Currently the frame must be a Canvas element.\n             */\n            this.addFrame = function(canvas) {\n                if (writtenHeader) {\n                    if (canvas.width != videoWidth || canvas.height != videoHeight) {\n                        throw \"Frame size differs from previous frames\";\n                    }\n                } else {\n                    videoWidth = canvas.width;\n                    videoHeight = canvas.height;\n    \n                    writeHeader();\n                    writtenHeader = true;\n                }\n    \n                var\n                    webP = renderAsWebP(canvas, {quality: options.quality});\n                \n                if (!webP) {\n                    throw \"Couldn't decode WebP frame, does the browser support WebP?\";\n                }\n                \n                addFrameToCluster({\n                    frame: extractKeyframeFromWebP(webP),\n                    duration: options.frameDuration\n                });\n            };\n            \n            /**\n             * Finish writing the video and return a Promise to signal completion.\n             *\n             * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n             * a Blob with the contents of the entire video.\n             */\n            this.complete = function() {\n                flushClusterFrameBuffer();\n                \n                writeCues();\n                rewriteSeekHead();\n                rewriteDuration();\n                \n                return blobBuffer.complete('video/webm');\n            };\n            \n            this.getWrittenSize = function() {\n                return blobBuffer.length;\n            };\n    \n            options = extend(optionDefaults, options || {});\n            validateOptions();\n        };\n    };\n\n    window.WebMWriter = WebMWriter(ArrayBufferDataStream, BlobBuffer);\n})();\n", "; (function () {\n\n  \"use strict\";\n\n  var Tar = window.Tar;\n  var download = window.download;\n  var GIF = window.GIF;\n  var WebMWriter = window.WebMWriter;\n\n  /**\n  * Used as a reference to the global object.\n  *\n  * The `this` value is used if it's the global object to avoid Greasemonkey's\n  * restricted `window` object, otherwise the `window` object is used.\n  */\n\n  if (!('gc' in window)) {\n    window.gc = function () { }\n  }\n\n  if (!HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n      value: function (callback, type, quality) {\n\n        var binStr = atob(this.toDataURL(type, quality).split(',')[1]),\n          len = binStr.length,\n          arr = new Uint8Array(len);\n\n        for (var i = 0; i < len; i++) {\n          arr[i] = binStr.charCodeAt(i);\n        }\n\n        callback(new Blob([arr], { type: type || 'image/png' }));\n      }\n    });\n  }\n\n  // @license http://opensource.org/licenses/MIT\n  // copyright Paul Irish 2015\n\n\n  // Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n  //   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n  // as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n  // if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n  // but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n  (function () {\n\n    if (\"performance\" in window == false) {\n      window.performance = {};\n    }\n\n    if (\"now\" in window.performance == false) {\n      var nowOffset = Date.now();\n\n      window.performance.now = function now() {\n        return Date.now() - nowOffset;\n      }\n    }\n  })();\n\n  function pad(n) {\n    return String(\"0000000\" + n).slice(-7);\n  }\n  // https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers\n\n  var g_startTime = window.Date.now();\n\n  function guid() {\n    function s4() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  }\n\n  function CCFrameEncoder(settings) {\n\n    var _handlers = {};\n\n    this.settings = settings;\n\n    this.on = function (event, handler) {\n\n      _handlers[event] = handler;\n\n    };\n\n    this.emit = function (event) {\n\n      var handler = _handlers[event];\n      if (handler) {\n\n        handler.apply(null, Array.prototype.slice.call(arguments, 1));\n\n      }\n\n    };\n\n    this.filename = settings.name || guid();\n    this.extension = '';\n    this.mimeType = '';\n\n  }\n\n  CCFrameEncoder.prototype.start = function () { };\n  CCFrameEncoder.prototype.stop = function () { };\n  CCFrameEncoder.prototype.add = function () { };\n  CCFrameEncoder.prototype.save = function () { };\n  CCFrameEncoder.prototype.dispose = function () { };\n  CCFrameEncoder.prototype.safeToProceed = function () { return true; };\n  CCFrameEncoder.prototype.step = function () { console.log('Step not set!') }\n\n  // function CCTarEncoder(settings) {\n  //   CCFrameEncoder.call(this, settings);\n  //   this.extension = '.tar'\n  //   this.mimeType = 'application/x-tar'\n  //   this.fileExtension = '';\n  //   this.baseFilename = this.filename;\n  //   this.tape = null\n  //   this.count = 0;\n  //   this.part = 1;\n  //   this.frames = 0;\n  // }\n\n  // CCTarEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n  // CCTarEncoder.prototype.start = function () {\n  //   this.dispose();\n  // };\n  // CCTarEncoder.prototype.add = function (blob) {\n  //   var fileReader = new FileReader();\n  //   fileReader.onload = function () {\n  //     this.tape.append(pad(this.count) + this.fileExtension, new Uint8Array(fileReader.result));\n  //     if (this.settings.autoSaveTime > 0 && (this.frames / this.settings.framerate) >= this.settings.autoSaveTime) {\n  //       this.save(function (blob) {\n  //         this.filename = this.baseFilename + '-part-' + pad(this.part);\n  //         download(blob, this.filename + this.extension, this.mimeType);\n  //         var count = this.count;\n  //         this.dispose();\n  //         this.count = count + 1;\n  //         this.part++;\n  //         this.filename = this.baseFilename + '-part-' + pad(this.part);\n  //         this.frames = 0;\n  //         this.step();\n  //       }.bind(this))\n  //     } else {\n  //       this.count++;\n  //       this.frames++;\n  //       this.step();\n  //     }\n\n  //   }.bind(this);\n  //   fileReader.readAsArrayBuffer(blob);\n\n  // }\n\n  // CCTarEncoder.prototype.save = function (callback) {\n\n  //   callback(this.tape.save());\n\n  // }\n\n  // CCTarEncoder.prototype.dispose = function () {\n\n  //   this.tape = new Tar();\n  //   this.count = 0;\n\n  // }\n\n  // function CCPNGEncoder(settings) {\n\n  //   CCTarEncoder.call(this, settings);\n\n  //   this.type = 'image/png';\n  //   this.fileExtension = '.png';\n\n  // }\n\n  // CCPNGEncoder.prototype = Object.create(CCTarEncoder.prototype);\n\n  // CCPNGEncoder.prototype.add = function (canvas) {\n\n  //   canvas.toBlob(function (blob) {\n  //     CCTarEncoder.prototype.add.call(this, blob);\n  //   }.bind(this), this.type)\n\n  // }\n\n  // function CCJPEGEncoder(settings) {\n\n  //   CCTarEncoder.call(this, settings);\n\n  //   this.type = 'image/jpeg';\n  //   this.fileExtension = '.jpg';\n  //   this.quality = (settings.quality / 100) || .8;\n\n  // }\n\n  // CCJPEGEncoder.prototype = Object.create(CCTarEncoder.prototype);\n\n  // CCJPEGEncoder.prototype.add = function (canvas) {\n\n  //   canvas.toBlob(function (blob) {\n  //     CCTarEncoder.prototype.add.call(this, blob);\n  //   }.bind(this), this.type, this.quality)\n  // }\n\n  /*\n  \n    WebM Encoder\n  \n  */\n\n  function CCWebMEncoder(settings) {\n    var canvas = document.createElement('canvas');\n\n    CCFrameEncoder.call(this, settings);\n\n    this.quality = (settings.quality / 100) || .8;\n\n    this.extension = '.webm'\n    this.mimeType = 'video/webm'\n    this.baseFilename = this.filename;\n    this.framerate = settings.framerate;\n\n    this.frames = 0;\n    this.part = 1;\n\n    this.videoWriter = new WebMWriter({\n      quality: this.quality,\n      fileWriter: null,\n      fd: null,\n      frameRate: this.framerate\n    });\n\n  }\n\n  CCWebMEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n  CCWebMEncoder.prototype.start = function (canvas) {\n\n    this.dispose();\n\n  }\n\n  CCWebMEncoder.prototype.add = function (canvas) {\n\n    this.videoWriter.addFrame(canvas);\n\n    if (this.settings.autoSaveTime > 0 && (this.frames / this.settings.framerate) >= this.settings.autoSaveTime) {\n      this.save(function (blob) {\n        this.filename = this.baseFilename + '-part-' + pad(this.part);\n        download(blob, this.filename + this.extension, this.mimeType);\n        this.dispose();\n        this.part++;\n        this.filename = this.baseFilename + '-part-' + pad(this.part);\n        this.step();\n      }.bind(this))\n    } else {\n      this.frames++;\n      this.step();\n    }\n\n  }\n\n  CCWebMEncoder.prototype.save = function (callback) {\n\n    this.videoWriter.complete().then(callback);\n\n  }\n\n  CCWebMEncoder.prototype.dispose = function (canvas) {\n\n    this.frames = 0;\n    this.videoWriter = new WebMWriter({\n      quality: this.quality,\n      fileWriter: null,\n      fd: null,\n      frameRate: this.framerate\n    });\n\n  }\n\n  function CCFFMpegServerEncoder(settings) {\n\n    CCFrameEncoder.call(this, settings);\n\n    settings.quality = (settings.quality / 100) || .8;\n\n    this.encoder = new FFMpegServer.Video(settings);\n    this.encoder.on('process', function () {\n      this.emit('process')\n    }.bind(this));\n    this.encoder.on('finished', function (url, size) {\n      var cb = this.callback;\n      if (cb) {\n        this.callback = undefined;\n        cb(url, size);\n      }\n    }.bind(this));\n    this.encoder.on('progress', function (progress) {\n      if (this.settings.onProgress) {\n        this.settings.onProgress(progress)\n      }\n    }.bind(this));\n    this.encoder.on('error', function (data) {\n      alert(JSON.stringify(data, null, 2));\n    }.bind(this));\n\n  }\n\n  CCFFMpegServerEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n  CCFFMpegServerEncoder.prototype.start = function () {\n\n    this.encoder.start(this.settings);\n\n  };\n\n  CCFFMpegServerEncoder.prototype.add = function (canvas) {\n\n    this.encoder.add(canvas);\n\n  }\n\n  CCFFMpegServerEncoder.prototype.save = function (callback) {\n\n    this.callback = callback;\n    this.encoder.end();\n\n  }\n\n  CCFFMpegServerEncoder.prototype.safeToProceed = function () {\n    return this.encoder.safeToProceed();\n  };\n\n  /*\n    HTMLCanvasElement.captureStream()\n  */\n\n  function CCStreamEncoder(settings) {\n\n    CCFrameEncoder.call(this, settings);\n\n    this.framerate = this.settings.framerate;\n    this.type = 'video/webm';\n    this.extension = '.webm';\n    this.stream = null;\n    this.mediaRecorder = null;\n    this.chunks = [];\n\n  }\n\n  CCStreamEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n  CCStreamEncoder.prototype.add = function (canvas) {\n\n    if (!this.stream) {\n      this.stream = canvas.captureStream(this.framerate);\n      this.mediaRecorder = new MediaRecorder(this.stream);\n      this.mediaRecorder.start();\n\n      this.mediaRecorder.ondataavailable = function (e) {\n        this.chunks.push(e.data);\n      }.bind(this);\n\n    }\n    this.step();\n\n  }\n\n  CCStreamEncoder.prototype.save = function (callback) {\n\n    this.mediaRecorder.onstop = function (e) {\n      var blob = new Blob(this.chunks, { 'type': 'video/webm' });\n      this.chunks = [];\n      callback(blob);\n\n    }.bind(this);\n\n    this.mediaRecorder.stop();\n\n  }\n\n  /*function CCGIFEncoder( settings ) {\n  \n    CCFrameEncoder.call( this );\n  \n    settings.quality = settings.quality || 6;\n    this.settings = settings;\n  \n    this.encoder = new GIFEncoder();\n    this.encoder.setRepeat( 1 );\n      this.encoder.setDelay( settings.step );\n      this.encoder.setQuality( 6 );\n      this.encoder.setTransparent( null );\n      this.encoder.setSize( 150, 150 );\n  \n      this.canvas = document.createElement( 'canvas' );\n      this.ctx = this.canvas.getContext( '2d' );\n  \n  }\n  \n  CCGIFEncoder.prototype = Object.create( CCFrameEncoder );\n  \n  CCGIFEncoder.prototype.start = function() {\n  \n    this.encoder.start();\n  \n  }\n  \n  CCGIFEncoder.prototype.add = function( canvas ) {\n  \n    this.canvas.width = canvas.width;\n    this.canvas.height = canvas.height;\n    this.ctx.drawImage( canvas, 0, 0 );\n    this.encoder.addFrame( this.ctx );\n  \n    this.encoder.setSize( canvas.width, canvas.height );\n    var readBuffer = new Uint8Array(canvas.width * canvas.height * 4);\n    var context = canvas.getContext( 'webgl' );\n    context.readPixels(0, 0, canvas.width, canvas.height, context.RGBA, context.UNSIGNED_BYTE, readBuffer);\n    this.encoder.addFrame( readBuffer, true );\n  \n  }\n  \n  CCGIFEncoder.prototype.stop = function() {\n  \n    this.encoder.finish();\n  \n  }\n  \n  CCGIFEncoder.prototype.save = function( callback ) {\n  \n    var binary_gif = this.encoder.stream().getData();\n  \n    var data_url = 'data:image/gif;base64,'+encode64(binary_gif);\n    window.location = data_url;\n    return;\n  \n    var blob = new Blob( [ binary_gif ], { type: \"octet/stream\" } );\n    var url = window.URL.createObjectURL( blob );\n    callback( url );\n  \n  }*/\n\n  function CCGIFEncoder(settings) {\n\n    CCFrameEncoder.call(this, settings);\n\n    settings.quality = 31 - ((settings.quality * 30 / 100) || 10);\n    settings.workers = settings.workers || 4;\n\n    this.extension = '.gif'\n    this.mimeType = 'image/gif'\n\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    this.sizeSet = false;\n\n    this.encoder = new GIF({\n      workers: settings.workers,\n      quality: settings.quality,\n      workerScript: settings.workersPath + 'gif.worker.js'\n    });\n\n    this.encoder.on('progress', function (progress) {\n      if (this.settings.onProgress) {\n        this.settings.onProgress(progress)\n      }\n    }.bind(this));\n\n    this.encoder.on('finished', function (blob) {\n      var cb = this.callback;\n      if (cb) {\n        this.callback = undefined;\n        cb(blob);\n      }\n    }.bind(this));\n\n  }\n\n  CCGIFEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n  CCGIFEncoder.prototype.add = function (canvas) {\n\n    if (!this.sizeSet) {\n      this.encoder.setOption('width', canvas.width);\n      this.encoder.setOption('height', canvas.height);\n      this.sizeSet = true;\n    }\n\n    this.canvas.width = canvas.width;\n    this.canvas.height = canvas.height;\n    this.ctx.drawImage(canvas, 0, 0);\n\n    this.encoder.addFrame(this.ctx, { copy: true, delay: this.settings.step });\n    this.step();\n\n    /*this.encoder.setSize( canvas.width, canvas.height );\n    var readBuffer = new Uint8Array(canvas.width * canvas.height * 4);\n    var context = canvas.getContext( 'webgl' );\n    context.readPixels(0, 0, canvas.width, canvas.height, context.RGBA, context.UNSIGNED_BYTE, readBuffer);\n    this.encoder.addFrame( readBuffer, true );*/\n\n  }\n\n  CCGIFEncoder.prototype.save = function (callback) {\n\n    this.callback = callback;\n\n    this.encoder.render();\n\n  }\n\n  function CCapture(settings) {\n\n    var _settings = settings || {},\n      _date = new Date(),\n      _verbose,\n      _display,\n      _time,\n      _startTime,\n      _performanceTime,\n      _performanceStartTime,\n      _step,\n      _encoder,\n      _timeouts = [],\n      _intervals = [],\n      _frameCount = 0,\n      _intermediateFrameCount = 0,\n      _lastFrame = null,\n      _requestAnimationFrameCallbacks = [],\n      _capturing = false,\n      _handlers = {};\n\n    _settings.framerate = _settings.framerate || 60;\n    _settings.motionBlurFrames = 2 * (_settings.motionBlurFrames || 1);\n    _verbose = _settings.verbose || false;\n    _display = _settings.display || false;\n    _settings.step = 1000.0 / _settings.framerate;\n    _settings.timeLimit = _settings.timeLimit || 0;\n    _settings.frameLimit = _settings.frameLimit || 0;\n    _settings.startTime = _settings.startTime || 0;\n\n    var _timeDisplay = document.createElement('div');\n    _timeDisplay.style.position = 'absolute';\n    _timeDisplay.style.left = _timeDisplay.style.top = 0\n    _timeDisplay.style.backgroundColor = 'black';\n    _timeDisplay.style.fontFamily = 'monospace'\n    _timeDisplay.style.fontSize = '11px'\n    _timeDisplay.style.padding = '5px'\n    _timeDisplay.style.color = 'red';\n    _timeDisplay.style.zIndex = 100000\n    if (_settings.display) document.body.appendChild(_timeDisplay);\n\n    var canvasMotionBlur = document.createElement('canvas');\n    var ctxMotionBlur = canvasMotionBlur.getContext('2d');\n    var bufferMotionBlur;\n    var imageData;\n\n    _log('Step is set to ' + _settings.step + 'ms');\n\n    var _encoders = {\n      // gif: CCGIFEncoder,\n      webm: CCWebMEncoder,\n      // ffmpegserver: CCFFMpegServerEncoder,\n      // png: CCPNGEncoder,\n      // jpg: CCJPEGEncoder,\n      'webm-mediarecorder': CCStreamEncoder\n    };\n\n    var ctor = _encoders[_settings.format];\n    if (!ctor) {\n      throw \"Error: Incorrect or missing format: Valid formats are \" + Object.keys(_encoders).join(\", \");\n    }\n    _encoder = new ctor(_settings);\n    _encoder.step = _step\n\n    _encoder.on('process', _process);\n    _encoder.on('progress', _progress);\n\n    if (\"performance\" in window == false) {\n      window.performance = {};\n    }\n\n    Date.now = (Date.now || function () {  // thanks IE8\n      return new Date().getTime();\n    });\n\n    if (\"now\" in window.performance == false) {\n\n      var nowOffset = Date.now();\n\n      if (performance.timing && performance.timing.navigationStart) {\n        nowOffset = performance.timing.navigationStart\n      }\n\n      window.performance.now = function now() {\n        return Date.now() - nowOffset;\n      }\n    }\n\n    var _oldSetTimeout = window.setTimeout,\n      _oldSetInterval = window.setInterval,\n      _oldClearInterval = window.clearInterval,\n      _oldClearTimeout = window.clearTimeout,\n      _oldRequestAnimationFrame = window.requestAnimationFrame,\n      _oldNow = window.Date.now,\n      _oldPerformanceNow = window.performance.now,\n      _oldGetTime = window.Date.prototype.getTime;\n    // Date.prototype._oldGetTime = Date.prototype.getTime;\n\n    var media = [];\n\n    function _init() {\n\n      _log('Capturer start');\n\n      _startTime = window.Date.now();\n      _time = _startTime + _settings.startTime;\n      _performanceStartTime = window.performance.now();\n      _performanceTime = _performanceStartTime + _settings.startTime;\n\n      window.Date.prototype.getTime = function () {\n        return _time;\n      };\n      window.Date.now = function () {\n        return _time;\n      };\n\n      window.setTimeout = function (callback, time) {\n        var t = {\n          callback: callback,\n          time: time,\n          triggerTime: _time + time\n        };\n        _timeouts.push(t);\n        _log('Timeout set to ' + t.time);\n        return t;\n      };\n      window.clearTimeout = function (id) {\n        for (var j = 0; j < _timeouts.length; j++) {\n          if (_timeouts[j] == id) {\n            _timeouts.splice(j, 1);\n            _log('Timeout cleared');\n            continue;\n          }\n        }\n      };\n      window.setInterval = function (callback, time) {\n        var t = {\n          callback: callback,\n          time: time,\n          triggerTime: _time + time\n        };\n        _intervals.push(t);\n        _log('Interval set to ' + t.time);\n        return t;\n      };\n      window.clearInterval = function (id) {\n        _log('clear Interval');\n        return null;\n      };\n      window.requestAnimationFrame = function (callback) {\n        _requestAnimationFrameCallbacks.push(callback);\n      };\n      window.performance.now = function () {\n        return _performanceTime;\n      };\n\n      function hookCurrentTime() {\n        if (!this._hooked) {\n          this._hooked = true;\n          this._hookedTime = this.currentTime || 0;\n          this.pause();\n          media.push(this);\n        }\n        return this._hookedTime + _settings.startTime;\n      };\n\n      try {\n        Object.defineProperty(HTMLVideoElement.prototype, 'currentTime', { get: hookCurrentTime })\n        Object.defineProperty(HTMLAudioElement.prototype, 'currentTime', { get: hookCurrentTime })\n      } catch (err) {\n        _log(err);\n      }\n\n    }\n\n    function _start() {\n      _init();\n      _encoder.start();\n      _capturing = true;\n    }\n\n    function _stop() {\n      _capturing = false;\n      _encoder.stop();\n      _destroy();\n    }\n\n    function _call(fn, p) {\n      _oldSetTimeout(fn, 0, p);\n    }\n\n    function _step() {\n      //_oldRequestAnimationFrame( _process );\n      _call(_process);\n    }\n\n    function _destroy() {\n      _log('Capturer stop');\n      window.setTimeout = _oldSetTimeout;\n      window.setInterval = _oldSetInterval;\n      window.clearInterval = _oldClearInterval;\n      window.clearTimeout = _oldClearTimeout;\n      window.requestAnimationFrame = _oldRequestAnimationFrame;\n      window.Date.prototype.getTime = _oldGetTime;\n      window.Date.now = _oldNow;\n      window.performance.now = _oldPerformanceNow;\n    }\n\n    function _updateTime() {\n      var seconds = _frameCount / _settings.framerate;\n      if ((_settings.frameLimit && _frameCount >= _settings.frameLimit) || (_settings.timeLimit && seconds >= _settings.timeLimit)) {\n        _stop();\n        _save();\n      }\n      var d = new Date(null);\n      d.setSeconds(seconds);\n      if (_settings.motionBlurFrames > 2) {\n        _timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames (' + _intermediateFrameCount + ' inter) | ' + d.toISOString().substr(11, 8);\n      } else {\n        _timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames | ' + d.toISOString().substr(11, 8);\n      }\n    }\n\n    function _checkFrame(canvas) {\n\n      if (canvasMotionBlur.width !== canvas.width || canvasMotionBlur.height !== canvas.height) {\n        canvasMotionBlur.width = canvas.width;\n        canvasMotionBlur.height = canvas.height;\n        bufferMotionBlur = new Uint16Array(canvasMotionBlur.height * canvasMotionBlur.width * 4);\n        ctxMotionBlur.fillStyle = '#0'\n        ctxMotionBlur.fillRect(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);\n      }\n\n    }\n\n    function _blendFrame(canvas) {\n\n      //_log( 'Intermediate Frame: ' + _intermediateFrameCount );\n\n      ctxMotionBlur.drawImage(canvas, 0, 0);\n      imageData = ctxMotionBlur.getImageData(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);\n      for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n        bufferMotionBlur[j] += imageData.data[j];\n        bufferMotionBlur[j + 1] += imageData.data[j + 1];\n        bufferMotionBlur[j + 2] += imageData.data[j + 2];\n      }\n      _intermediateFrameCount++;\n\n    }\n\n    function _saveFrame() {\n      var data = imageData.data;\n      for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n        data[j] = bufferMotionBlur[j] * 2 / _settings.motionBlurFrames;\n        data[j + 1] = bufferMotionBlur[j + 1] * 2 / _settings.motionBlurFrames;\n        data[j + 2] = bufferMotionBlur[j + 2] * 2 / _settings.motionBlurFrames;\n      }\n      ctxMotionBlur.putImageData(imageData, 0, 0);\n      _encoder.add(canvasMotionBlur);\n      _frameCount++;\n      _intermediateFrameCount = 0;\n      _log('Full MB Frame! ' + _frameCount + ' ' + _time);\n      for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n        bufferMotionBlur[j] = 0;\n        bufferMotionBlur[j + 1] = 0;\n        bufferMotionBlur[j + 2] = 0;\n      }\n      gc();\n\n    }\n\n    function _capture(canvas) {\n\n      if (_capturing) {\n\n        if (_settings.motionBlurFrames > 2) {\n\n          _checkFrame(canvas);\n          _blendFrame(canvas);\n\n          if (_intermediateFrameCount >= .5 * _settings.motionBlurFrames) {\n            _saveFrame();\n          } else {\n            _step();\n          }\n\n        } else {\n          _encoder.add(canvas);\n          _frameCount++;\n          _log('Full Frame! ' + _frameCount);\n        }\n\n      }\n\n    }\n\n    function _process() {\n\n      var step = 1000 / _settings.framerate;\n      var dt = (_frameCount + _intermediateFrameCount / _settings.motionBlurFrames) * step;\n\n      _time = _startTime + dt;\n      _performanceTime = _performanceStartTime + dt;\n\n      media.forEach(function (v) {\n        v._hookedTime = dt / 1000;\n      });\n\n      _updateTime();\n      _log('Frame: ' + _frameCount + ' ' + _intermediateFrameCount);\n\n      for (var j = 0; j < _timeouts.length; j++) {\n        if (_time >= _timeouts[j].triggerTime) {\n          _call(_timeouts[j].callback)\n          //console.log( 'timeout!' );\n          _timeouts.splice(j, 1);\n          continue;\n        }\n      }\n\n      for (var j = 0; j < _intervals.length; j++) {\n        if (_time >= _intervals[j].triggerTime) {\n          _call(_intervals[j].callback);\n          _intervals[j].triggerTime += _intervals[j].time;\n          //console.log( 'interval!' );\n          continue;\n        }\n      }\n\n      _requestAnimationFrameCallbacks.forEach(function (cb) {\n        _call(cb, _time - g_startTime);\n      });\n      _requestAnimationFrameCallbacks = [];\n\n    }\n\n    function _save(callback) {\n\n      if (!callback) {\n        callback = function (blob) {\n          download(blob, _encoder.filename + _encoder.extension, _encoder.mimeType);\n          return false;\n        }\n      }\n      _encoder.save(callback);\n\n    }\n\n    function _log(message) {\n      if (_verbose) console.log(message);\n    }\n\n    function _on(event, handler) {\n\n      _handlers[event] = handler;\n\n    }\n\n    function _emit(event) {\n\n      var handler = _handlers[event];\n      if (handler) {\n\n        handler.apply(null, Array.prototype.slice.call(arguments, 1));\n\n      }\n\n    }\n\n    function _progress(progress) {\n\n      _emit('progress', progress);\n\n    }\n\n    return {\n      start: _start,\n      capture: _capture,\n      stop: _stop,\n      save: _save,\n      on: _on\n    }\n  }\n\n  window.CCapture = CCapture;\n}());", "import \"./vendor/webm-writer-0.2.0\";\nimport \"./vendor/ccapture.js\";\n\ndeclare global {\n  interface Window {\n    CCapture: any;\n  }\n}\n\nexport type CapturerSettings = {\n  frameCount: number;\n  element: HTMLCanvasElement;\n  onComplete?: Function;\n};\n\nexport default class Capturer {\n  running: boolean;\n  active: boolean;\n  capture: CCapture;\n  maxFrames: number;\n  frames: number;\n  el: HTMLCanvasElement;\n  onComplete: Function;\n\n  constructor() {\n    this.active = false;\n    this.running = false;\n  }\n\n  enableCapture({ frameCount, element, onComplete }: CapturerSettings) {\n    this.active = true;\n    this.el = element;\n    this.maxFrames = frameCount;\n    this.frames = 0;\n    this.capture = new window.CCapture({\n      framerate: 60,\n      format: \"webm\",\n      verbose: false,\n    });\n    this.onComplete = onComplete || function () {};\n  }\n\n  captureFrame() {\n    if (this.active && !this.running) {\n      this.capture.start();\n    }\n\n    if (this.active) {\n      this.capture.capture(this.el);\n      this.frames++;\n\n      if (this.frames > this.maxFrames) {\n        this.capture.stop();\n        this.capture.save();\n        this.onComplete();\n      }\n    }\n  }\n}\n", "import Capturer, { CapturerSettings } from \"./capturer\";\n\ndeclare global {\n  interface Window {\n    enableCapture: (settings: CapturerSettings) => void;\n    captureFrame: () => void;\n  }\n}\n\nif (window) {\n  // running in a browser, attach capturer to global window object\n  const capturer = new Capturer();\n  window.enableCapture = capturer.enableCapture.bind(capturer);\n  window.captureFrame = capturer.captureFrame.bind(capturer);\n}\n"],
  "mappings": "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",
  "names": []
}
