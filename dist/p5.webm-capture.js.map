{
  "version": 3,
  "sources": ["../src/vendor/webm-writer-0.3.0.js", "../src/vendor/download.js", "../src/vendor/ccapture.js", "../src/capturer.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * A tool for presenting an ArrayBuffer as a stream for writing some simple data types.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n\"use strict\";\n\n(function () {\n  /*\n   * Create an ArrayBuffer of the given length and present it as a writable stream with methods\n   * for writing data in different formats.\n   */\n  let ArrayBufferDataStream = function (length) {\n    this.data = new Uint8Array(length);\n    this.pos = 0;\n  };\n\n  ArrayBufferDataStream.prototype.seek = function (toOffset) {\n    this.pos = toOffset;\n  };\n\n  ArrayBufferDataStream.prototype.writeBytes = function (arr) {\n    for (let i = 0; i < arr.length; i++) {\n      this.data[this.pos++] = arr[i];\n    }\n  };\n\n  ArrayBufferDataStream.prototype.writeByte = function (b) {\n    this.data[this.pos++] = b;\n  };\n\n  //Synonym:\n  ArrayBufferDataStream.prototype.writeU8 =\n    ArrayBufferDataStream.prototype.writeByte;\n\n  ArrayBufferDataStream.prototype.writeU16BE = function (u) {\n    this.data[this.pos++] = u >> 8;\n    this.data[this.pos++] = u;\n  };\n\n  ArrayBufferDataStream.prototype.writeDoubleBE = function (d) {\n    let bytes = new Uint8Array(new Float64Array([d]).buffer);\n\n    for (let i = bytes.length - 1; i >= 0; i--) {\n      this.writeByte(bytes[i]);\n    }\n  };\n\n  ArrayBufferDataStream.prototype.writeFloatBE = function (d) {\n    let bytes = new Uint8Array(new Float32Array([d]).buffer);\n\n    for (let i = bytes.length - 1; i >= 0; i--) {\n      this.writeByte(bytes[i]);\n    }\n  };\n\n  /**\n   * Write an ASCII string to the stream\n   */\n  ArrayBufferDataStream.prototype.writeString = function (s) {\n    for (let i = 0; i < s.length; i++) {\n      this.data[this.pos++] = s.charCodeAt(i);\n    }\n  };\n\n  /**\n   * Write the given 32-bit integer to the stream as an EBML variable-length integer using the given byte width\n   * (use measureEBMLVarInt).\n   *\n   * No error checking is performed to ensure that the supplied width is correct for the integer.\n   *\n   * @param i Integer to be written\n   * @param width Number of bytes to write to the stream\n   */\n  ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function (i, width) {\n    switch (width) {\n      case 1:\n        this.writeU8((1 << 7) | i);\n        break;\n      case 2:\n        this.writeU8((1 << 6) | (i >> 8));\n        this.writeU8(i);\n        break;\n      case 3:\n        this.writeU8((1 << 5) | (i >> 16));\n        this.writeU8(i >> 8);\n        this.writeU8(i);\n        break;\n      case 4:\n        this.writeU8((1 << 4) | (i >> 24));\n        this.writeU8(i >> 16);\n        this.writeU8(i >> 8);\n        this.writeU8(i);\n        break;\n      case 5:\n        /*\n         * JavaScript converts its doubles to 32-bit integers for bitwise operations, so we need to do a\n         * division by 2^32 instead of a right-shift of 32 to retain those top 3 bits\n         */\n        this.writeU8((1 << 3) | ((i / 4294967296) & 0x7));\n        this.writeU8(i >> 24);\n        this.writeU8(i >> 16);\n        this.writeU8(i >> 8);\n        this.writeU8(i);\n        break;\n      default:\n        throw new Error(\"Bad EBML VINT size \" + width);\n    }\n  };\n\n  /**\n   * Return the number of bytes needed to encode the given integer as an EBML VINT.\n   */\n  ArrayBufferDataStream.prototype.measureEBMLVarInt = function (val) {\n    if (val < (1 << 7) - 1) {\n      /* Top bit is set, leaving 7 bits to hold the integer, but we can't store 127 because\n       * \"all bits set to one\" is a reserved value. Same thing for the other cases below:\n       */\n      return 1;\n    } else if (val < (1 << 14) - 1) {\n      return 2;\n    } else if (val < (1 << 21) - 1) {\n      return 3;\n    } else if (val < (1 << 28) - 1) {\n      return 4;\n    } else if (val < 34359738367) {\n      // 2 ^ 35 - 1 (can address 32GB)\n      return 5;\n    } else {\n      throw new Error(\"EBML VINT size not supported \" + val);\n    }\n  };\n\n  ArrayBufferDataStream.prototype.writeEBMLVarInt = function (i) {\n    this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));\n  };\n\n  /**\n   * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.\n   * No error checking is performed to ensure that the supplied width is correct for the integer.\n   *\n   * Omit the width parameter to have it determined automatically for you.\n   *\n   * @param u Unsigned integer to be written\n   * @param width Number of bytes to write to the stream\n   */\n  ArrayBufferDataStream.prototype.writeUnsignedIntBE = function (u, width) {\n    if (width === undefined) {\n      width = this.measureUnsignedInt(u);\n    }\n\n    // Each case falls through:\n    switch (width) {\n      case 5:\n        this.writeU8(Math.floor(u / 4294967296)); // Need to use division to access >32 bits of floating point var\n      case 4:\n        this.writeU8(u >> 24);\n      case 3:\n        this.writeU8(u >> 16);\n      case 2:\n        this.writeU8(u >> 8);\n      case 1:\n        this.writeU8(u);\n        break;\n      default:\n        throw new Error(\"Bad UINT size \" + width);\n    }\n  };\n\n  /**\n   * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.\n   */\n  ArrayBufferDataStream.prototype.measureUnsignedInt = function (val) {\n    // Force to 32-bit unsigned integer\n    if (val < 1 << 8) {\n      return 1;\n    } else if (val < 1 << 16) {\n      return 2;\n    } else if (val < 1 << 24) {\n      return 3;\n    } else if (val < 4294967296) {\n      return 4;\n    } else {\n      return 5;\n    }\n  };\n\n  /**\n   * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.\n   */\n  ArrayBufferDataStream.prototype.getAsDataArray = function () {\n    if (this.pos < this.data.byteLength) {\n      return this.data.subarray(0, this.pos);\n    } else if (this.pos == this.data.byteLength) {\n      return this.data;\n    } else {\n      throw new Error(\"ArrayBufferDataStream's pos lies beyond end of buffer\");\n    }\n  };\n\n  window.ArrayBufferDataStream = ArrayBufferDataStream;\n})();\n(\"use strict\");\n\n/**\n * Allows a series of Blob-convertible objects (ArrayBuffer, Blob, String, etc) to be added to a buffer. Seeking and\n * overwriting of blobs is allowed.\n *\n * You can supply a FileWriter, in which case the BlobBuffer is just used as temporary storage before it writes it\n * through to the disk.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n(function () {\n  let BlobBuffer = function (fs) {\n    return function (destination) {\n      let buffer = [],\n        writePromise = Promise.resolve(),\n        fileWriter = null,\n        fd = null;\n\n      if (destination && destination.constructor.name === \"FileWriter\") {\n        fileWriter = destination;\n      } else if (fs && destination) {\n        fd = destination;\n      }\n\n      if (!fs && fileWriter == null && fd == null) {\n        console.error('unable to write!')\n      }\n\n      // Current seek offset\n      this.pos = 0;\n\n      // One more than the index of the highest byte ever written\n      this.length = 0;\n\n      // Returns a promise that converts the blob to an ArrayBuffer\n      function readBlobAsBuffer(blob) {\n        return new Promise(function (resolve, reject) {\n          let reader = new FileReader();\n\n          reader.addEventListener(\"loadend\", function () {\n            resolve(reader.result);\n          });\n\n          reader.readAsArrayBuffer(blob);\n        });\n      }\n\n      function convertToUint8Array(thing) {\n        return new Promise(function (resolve, reject) {\n          if (thing instanceof Uint8Array) {\n            resolve(thing);\n          } else if (\n            thing instanceof ArrayBuffer ||\n            ArrayBuffer.isView(thing)\n          ) {\n            resolve(new Uint8Array(thing));\n          } else if (thing instanceof Blob) {\n            resolve(\n              readBlobAsBuffer(thing).then(function (buffer) {\n                return new Uint8Array(buffer);\n              })\n            );\n          } else {\n            //Assume that Blob will know how to read this thing\n            resolve(\n              readBlobAsBuffer(new Blob([thing])).then(function (buffer) {\n                return new Uint8Array(buffer);\n              })\n            );\n          }\n        });\n      }\n\n      function measureData(data) {\n        let result = data.byteLength || data.length || data.size;\n\n        if (!Number.isInteger(result)) {\n          throw new Error(\"Failed to determine size of element\");\n        }\n\n        return result;\n      }\n\n      /**\n       * Seek to the given absolute offset.\n       *\n       * You may not seek beyond the end of the file (this would create a hole and/or allow blocks to be written in non-\n       * sequential order, which isn't currently supported by the memory buffer backend).\n       */\n      this.seek = function (offset) {\n        if (offset < 0) {\n          throw new Error(\"Offset may not be negative\");\n        }\n\n        if (isNaN(offset)) {\n          throw new Error(\"Offset may not be NaN\");\n        }\n\n        if (offset > this.length) {\n          throw new Error(\"Seeking beyond the end of file is not allowed\");\n        }\n\n        this.pos = offset;\n      };\n\n      /**\n       * Write the Blob-convertible data to the buffer at the current seek position.\n       *\n       * Note: If overwriting existing data, the write must not cross preexisting block boundaries (written data must\n       * be fully contained by the extent of a previous write).\n       */\n      this.write = function (data) {\n        let newEntry = {\n            offset: this.pos,\n            data: data,\n            length: measureData(data),\n          },\n          isAppend = newEntry.offset >= this.length;\n\n        this.pos += newEntry.length;\n        this.length = Math.max(this.length, this.pos);\n\n        // After previous writes complete, perform our write\n        writePromise = writePromise.then(function () {\n          if (fd) {\n            return new Promise(function (resolve, reject) {\n              convertToUint8Array(newEntry.data).then(function (dataArray) {\n                let totalWritten = 0,\n                  buffer = Buffer.from(dataArray.buffer),\n                  handleWriteComplete = function (err, written, buffer) {\n                    totalWritten += written;\n\n                    if (totalWritten >= buffer.length) {\n                      resolve();\n                    } else {\n                      // We still have more to write...\n                      fs.write(\n                        fd,\n                        buffer,\n                        totalWritten,\n                        buffer.length - totalWritten,\n                        newEntry.offset + totalWritten,\n                        handleWriteComplete\n                      );\n                    }\n                  };\n\n                fs.write(\n                  fd,\n                  buffer,\n                  0,\n                  buffer.length,\n                  newEntry.offset,\n                  handleWriteComplete\n                );\n              });\n            });\n          } else if (fileWriter) {\n            return new Promise(function (resolve, reject) {\n              fileWriter.onwriteend = resolve;\n\n              fileWriter.seek(newEntry.offset);\n              fileWriter.write(new Blob([newEntry.data]));\n            });\n          } else if (!isAppend) {\n            // We might be modifying a write that was already buffered in memory.\n\n            // Slow linear search to find a block we might be overwriting\n            for (let i = 0; i < buffer.length; i++) {\n              let entry = buffer[i];\n\n              // If our new entry overlaps the old one in any way...\n              if (\n                !(\n                  newEntry.offset + newEntry.length <= entry.offset ||\n                  newEntry.offset >= entry.offset + entry.length\n                )\n              ) {\n                if (\n                  newEntry.offset < entry.offset ||\n                  newEntry.offset + newEntry.length >\n                    entry.offset + entry.length\n                ) {\n                  throw new Error(\"Overwrite crosses blob boundaries\");\n                }\n\n                if (\n                  newEntry.offset == entry.offset &&\n                  newEntry.length == entry.length\n                ) {\n                  // We overwrote the entire block\n                  entry.data = newEntry.data;\n\n                  // We're done\n                  return;\n                } else {\n                  return convertToUint8Array(entry.data)\n                    .then(function (entryArray) {\n                      entry.data = entryArray;\n\n                      return convertToUint8Array(newEntry.data);\n                    })\n                    .then(function (newEntryArray) {\n                      newEntry.data = newEntryArray;\n\n                      entry.data.set(\n                        newEntry.data,\n                        newEntry.offset - entry.offset\n                      );\n                    });\n                }\n              }\n            }\n            // Else fall through to do a simple append, as we didn't overwrite any pre-existing blocks\n          }\n\n          buffer.push(newEntry);\n        });\n      };\n\n      /**\n       * Finish all writes to the buffer, returning a promise that signals when that is complete.\n       *\n       * If a FileWriter was not provided, the promise is resolved with a Blob that represents the completed BlobBuffer\n       * contents. You can optionally pass in a mimeType to be used for this blob.\n       *\n       * If a FileWriter was provided, the promise is resolved with null as the first argument.\n       */\n      this.complete = function (mimeType) {\n        if (fd || fileWriter) {\n          writePromise = writePromise.then(function () {\n            return null;\n          });\n        } else {\n          // After writes complete we need to merge the buffer to give to the caller\n          writePromise = writePromise.then(function () {\n            let result = [];\n\n            for (let i = 0; i < buffer.length; i++) {\n              result.push(buffer[i].data);\n            }\n\n            return new Blob(result, { type: mimeType });\n          });\n        }\n\n        return writePromise;\n      };\n    };\n  };\n\n  window.BlobBuffer = BlobBuffer(null);\n})();\n/**\n * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n *\n * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n * eventually returned as one composite Blob.\n *\n * By Nicholas Sherlock.\n *\n * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n(\"use strict\");\n\n(function () {\n  function extend(base, top) {\n    let target = {};\n\n    [base, top].forEach(function (obj) {\n      for (let prop in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n          target[prop] = obj[prop];\n        }\n      }\n    });\n\n    return target;\n  }\n\n  /**\n   * Decode a Base64 data URL into a binary string.\n   *\n   * @return {String} The binary string\n   */\n  function decodeBase64WebPDataURL(url) {\n    if (typeof url !== \"string\" || !url.match(/^data:image\\/webp;base64,/i)) {\n      throw new Error(\"Failed to decode WebP Base64 URL\");\n    }\n\n    return window.atob(url.substring(\"data:image/webp;base64,\".length));\n  }\n\n  /**\n   * Convert the given canvas to a WebP encoded image and return the image data as a string.\n   *\n   * @return {String}\n   */\n  function renderAsWebP(canvas, quality) {\n    let frame =\n      typeof canvas === \"string\" && /^data:image\\/webp/.test(canvas)\n        ? canvas\n        : canvas.toDataURL(\"image/webp\", quality);\n\n    return decodeBase64WebPDataURL(frame);\n  }\n\n  /**\n   * @param {String} string\n   * @returns {number}\n   */\n  function byteStringToUint32LE(string) {\n    let a = string.charCodeAt(0),\n      b = string.charCodeAt(1),\n      c = string.charCodeAt(2),\n      d = string.charCodeAt(3);\n\n    return (a | (b << 8) | (c << 16) | (d << 24)) >>> 0;\n  }\n\n  /**\n   * Extract a VP8 keyframe from a WebP image file.\n   *\n   * @param {String} webP - Raw binary string\n   *\n   * @returns {{hasAlpha: boolean, frame: string}}\n   */\n  function extractKeyframeFromWebP(webP) {\n    let cursor = webP.indexOf(\"VP8\", 12); // Start the search after the 12-byte file header\n\n    if (cursor === -1) {\n      throw new Error(\"Bad image format, does this browser support WebP?\");\n    }\n\n    let hasAlpha = false;\n\n    /* Cursor now is either directly pointing at a \"VP8 \" keyframe, or a \"VP8X\" extended format file header\n     * Seek through chunks until we find the \"VP8 \" chunk we're interested in\n     */\n    while (cursor < webP.length - 8) {\n      let chunkLength, fourCC;\n\n      fourCC = webP.substring(cursor, cursor + 4);\n      cursor += 4;\n\n      chunkLength = byteStringToUint32LE(webP.substring(cursor, cursor + 4));\n      cursor += 4;\n\n      switch (fourCC) {\n        case \"VP8 \":\n          return {\n            frame: webP.substring(cursor, cursor + chunkLength),\n            hasAlpha: hasAlpha,\n          };\n\n        case \"ALPH\":\n          hasAlpha = true;\n          /* But we otherwise ignore the content of the alpha chunk, since we don't have a decoder for it\n           * and it isn't VP8-compatible\n           */\n          break;\n      }\n\n      cursor += chunkLength;\n\n      if ((chunkLength & 0x01) !== 0) {\n        cursor++;\n        // Odd-length chunks have 1 byte of trailing padding that isn't included in their length\n      }\n    }\n\n    throw new Error(\n      \"Failed to find VP8 keyframe in WebP image, is this image mistakenly encoded in the Lossless WebP format?\"\n    );\n  }\n\n  // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n  function EBMLFloat32(value) {\n    this.value = value;\n  }\n\n  function EBMLFloat64(value) {\n    this.value = value;\n  }\n\n  /**\n   * Write the given EBML object to the provided ArrayBufferStream.\n   *\n   * @param buffer\n   * @param {Number} bufferFileOffset - The buffer's first byte is at this position inside the video file.\n   *                                    This is used to complete offset and dataOffset fields in each EBML structure,\n   *                                    indicating the file offset of the first byte of the EBML element and\n   *                                    its data payload.\n   * @param {*} ebml\n   */\n  function writeEBML(buffer, bufferFileOffset, ebml) {\n    // Is the ebml an array of sibling elements?\n    if (Array.isArray(ebml)) {\n      for (let i = 0; i < ebml.length; i++) {\n        writeEBML(buffer, bufferFileOffset, ebml[i]);\n      }\n      // Is this some sort of raw data that we want to write directly?\n    } else if (typeof ebml === \"string\") {\n      buffer.writeString(ebml);\n    } else if (ebml instanceof Uint8Array) {\n      buffer.writeBytes(ebml);\n    } else if (ebml.id) {\n      // We're writing an EBML element\n      ebml.offset = buffer.pos + bufferFileOffset;\n\n      buffer.writeUnsignedIntBE(ebml.id); // ID field\n\n      // Now we need to write the size field, so we must know the payload size:\n\n      if (Array.isArray(ebml.data)) {\n        // Writing an array of child elements. We won't try to measure the size of the children up-front\n\n        let sizePos, dataBegin, dataEnd;\n\n        if (ebml.size === -1) {\n          // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n          buffer.writeByte(0xff);\n        } else {\n          sizePos = buffer.pos;\n\n          /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n           * which should be plenty (we don't want to have to buffer that much data in memory at one time\n           * anyway!)\n           */\n          buffer.writeBytes([0, 0, 0, 0]);\n        }\n\n        dataBegin = buffer.pos;\n\n        ebml.dataOffset = dataBegin + bufferFileOffset;\n        writeEBML(buffer, bufferFileOffset, ebml.data);\n\n        if (ebml.size !== -1) {\n          dataEnd = buffer.pos;\n\n          ebml.size = dataEnd - dataBegin;\n\n          buffer.seek(sizePos);\n          buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n\n          buffer.seek(dataEnd);\n        }\n      } else if (typeof ebml.data === \"string\") {\n        buffer.writeEBMLVarInt(ebml.data.length); // Size field\n        ebml.dataOffset = buffer.pos + bufferFileOffset;\n        buffer.writeString(ebml.data);\n      } else if (typeof ebml.data === \"number\") {\n        // Allow the caller to explicitly choose the size if they wish by supplying a size field\n        if (!ebml.size) {\n          ebml.size = buffer.measureUnsignedInt(ebml.data);\n        }\n\n        buffer.writeEBMLVarInt(ebml.size); // Size field\n        ebml.dataOffset = buffer.pos + bufferFileOffset;\n        buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n      } else if (ebml.data instanceof EBMLFloat64) {\n        buffer.writeEBMLVarInt(8); // Size field\n        ebml.dataOffset = buffer.pos + bufferFileOffset;\n        buffer.writeDoubleBE(ebml.data.value);\n      } else if (ebml.data instanceof EBMLFloat32) {\n        buffer.writeEBMLVarInt(4); // Size field\n        ebml.dataOffset = buffer.pos + bufferFileOffset;\n        buffer.writeFloatBE(ebml.data.value);\n      } else if (ebml.data instanceof Uint8Array) {\n        buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n        ebml.dataOffset = buffer.pos + bufferFileOffset;\n        buffer.writeBytes(ebml.data);\n      } else {\n        throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n      }\n    } else {\n      throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n    }\n  }\n\n  /**\n   * @typedef {Object} Frame\n   * @property {string} frame - Raw VP8 keyframe data\n   * @property {string} alpha - Raw VP8 keyframe with alpha represented as luminance\n   * @property {Number} duration\n   * @property {Number} trackNumber - From 1 to 126 (inclusive)\n   * @property {Number} timecode\n   */\n\n  /**\n   * @typedef {Object} Cluster\n   * @property {Number} timecode - Start time for the cluster\n   */\n\n  /**\n   * @param ArrayBufferDataStream - Imported library\n   * @param BlobBuffer - Imported library\n   *\n   * @returns WebMWriter\n   *\n   * @constructor\n   */\n  let WebMWriter = function (ArrayBufferDataStream, BlobBuffer) {\n    return function (options) {\n      let MAX_CLUSTER_DURATION_MSEC = 5000,\n        DEFAULT_TRACK_NUMBER = 1,\n        writtenHeader = false,\n        videoWidth = 0,\n        videoHeight = 0,\n        /**\n         * @type {[HTMLCanvasElement]}\n         */\n        alphaBuffer = null,\n        /**\n         * @type {[CanvasRenderingContext2D]}\n         */\n        alphaBufferContext = null,\n        /**\n         * @type {[ImageData]}\n         */\n        alphaBufferData = null,\n        /**\n         *\n         * @type {Frame[]}\n         */\n        clusterFrameBuffer = [],\n        clusterStartTime = 0,\n        clusterDuration = 0,\n        optionDefaults = {\n          quality: 0.95, // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (WebP lossless) is not supported\n\n          transparent: false, // True if an alpha channel should be included in the video\n          alphaQuality: undefined, // Allows you to set the quality level of the alpha channel separately.\n          // If not specified this defaults to the same value as `quality`.\n\n          fileWriter: null, // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n          fd: null, // Node.JS file descriptor to write to instead of buffering (optional)\n\n          // You must supply one of:\n          frameDuration: null, // Duration of frames in milliseconds\n          frameRate: null, // Number of frames per second\n        },\n        seekPoints = {\n          Cues: {\n            id: new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]),\n            positionEBML: null,\n          },\n          SegmentInfo: {\n            id: new Uint8Array([0x15, 0x49, 0xa9, 0x66]),\n            positionEBML: null,\n          },\n          Tracks: {\n            id: new Uint8Array([0x16, 0x54, 0xae, 0x6b]),\n            positionEBML: null,\n          },\n        },\n        ebmlSegment, // Root element of the EBML document\n        segmentDuration = {\n          id: 0x4489, // Duration\n          data: new EBMLFloat64(0),\n        },\n        seekHead,\n        cues = [],\n        blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n\n      function fileOffsetToSegmentRelative(fileOffset) {\n        return fileOffset - ebmlSegment.dataOffset;\n      }\n\n      /**\n       * Extracts the transparency channel from the supplied canvas and uses it to create a VP8 alpha channel bitstream.\n       *\n       * @param {HTMLCanvasElement} source\n       *\n       * @return {HTMLCanvasElement}\n       */\n      function convertAlphaToGrayscaleImage(source) {\n        if (\n          alphaBuffer === null ||\n          alphaBuffer.width !== source.width ||\n          alphaBuffer.height !== source.height\n        ) {\n          alphaBuffer = document.createElement(\"canvas\");\n          alphaBuffer.width = source.width;\n          alphaBuffer.height = source.height;\n\n          alphaBufferContext = alphaBuffer.getContext(\"2d\");\n          alphaBufferData = alphaBufferContext.createImageData(\n            alphaBuffer.width,\n            alphaBuffer.height\n          );\n        }\n\n        let sourceContext = source.getContext(\"2d\"),\n          sourceData = sourceContext.getImageData(\n            0,\n            0,\n            source.width,\n            source.height\n          ).data,\n          destData = alphaBufferData.data,\n          dstCursor = 0,\n          srcEnd = source.width * source.height * 4;\n\n        for (\n          let srcCursor = 3 /* Since pixel byte order is RGBA */;\n          srcCursor < srcEnd;\n          srcCursor += 4\n        ) {\n          let alpha = sourceData[srcCursor];\n\n          // Turn the original alpha channel into a brightness value (ends up being the Y in YUV)\n          destData[dstCursor++] = alpha;\n          destData[dstCursor++] = alpha;\n          destData[dstCursor++] = alpha;\n          destData[dstCursor++] = 255;\n        }\n\n        alphaBufferContext.putImageData(alphaBufferData, 0, 0);\n\n        return alphaBuffer;\n      }\n\n      /**\n       * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n       *\n       * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n       * to be overwritten later.\n       */\n      function createSeekHead() {\n        let seekPositionEBMLTemplate = {\n            id: 0x53ac, // SeekPosition\n            size: 5, // Allows for 32GB video files\n            data: 0, // We'll overwrite this when the file is complete\n          },\n          result = {\n            id: 0x114d9b74, // SeekHead\n            data: [],\n          };\n\n        for (let name in seekPoints) {\n          let seekPoint = seekPoints[name];\n\n          seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n\n          result.data.push({\n            id: 0x4dbb, // Seek\n            data: [\n              {\n                id: 0x53ab, // SeekID\n                data: seekPoint.id,\n              },\n              seekPoint.positionEBML,\n            ],\n          });\n        }\n\n        return result;\n      }\n\n      /**\n       * Write the WebM file header to the stream.\n       */\n      function writeHeader() {\n        seekHead = createSeekHead();\n\n        let ebmlHeader = {\n            id: 0x1a45dfa3, // EBML\n            data: [\n              {\n                id: 0x4286, // EBMLVersion\n                data: 1,\n              },\n              {\n                id: 0x42f7, // EBMLReadVersion\n                data: 1,\n              },\n              {\n                id: 0x42f2, // EBMLMaxIDLength\n                data: 4,\n              },\n              {\n                id: 0x42f3, // EBMLMaxSizeLength\n                data: 8,\n              },\n              {\n                id: 0x4282, // DocType\n                data: \"webm\",\n              },\n              {\n                id: 0x4287, // DocTypeVersion\n                data: 2,\n              },\n              {\n                id: 0x4285, // DocTypeReadVersion\n                data: 2,\n              },\n            ],\n          },\n          segmentInfo = {\n            id: 0x1549a966, // Info\n            data: [\n              {\n                id: 0x2ad7b1, // TimecodeScale\n                data: 1e6, // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n              },\n              {\n                id: 0x4d80, // MuxingApp\n                data: \"webm-writer-js\",\n              },\n              {\n                id: 0x5741, // WritingApp\n                data: \"webm-writer-js\",\n              },\n              segmentDuration, // To be filled in later\n            ],\n          },\n          videoProperties = [\n            {\n              id: 0xb0, // PixelWidth\n              data: videoWidth,\n            },\n            {\n              id: 0xba, // PixelHeight\n              data: videoHeight,\n            },\n          ];\n\n        if (options.transparent) {\n          videoProperties.push({\n            id: 0x53c0, // AlphaMode\n            data: 1,\n          });\n        }\n\n        let tracks = {\n          id: 0x1654ae6b, // Tracks\n          data: [\n            {\n              id: 0xae, // TrackEntry\n              data: [\n                {\n                  id: 0xd7, // TrackNumber\n                  data: DEFAULT_TRACK_NUMBER,\n                },\n                {\n                  id: 0x73c5, // TrackUID\n                  data: DEFAULT_TRACK_NUMBER,\n                },\n                {\n                  id: 0x9c, // FlagLacing\n                  data: 0,\n                },\n                {\n                  id: 0x22b59c, // Language\n                  data: \"und\",\n                },\n                {\n                  id: 0x86, // CodecID\n                  data: \"V_VP8\",\n                },\n                {\n                  id: 0x258688, // CodecName\n                  data: \"VP8\",\n                },\n                {\n                  id: 0x83, // TrackType\n                  data: 1,\n                },\n                {\n                  id: 0xe0, // Video\n                  data: videoProperties,\n                },\n              ],\n            },\n          ],\n        };\n\n        ebmlSegment = {\n          id: 0x18538067, // Segment\n          size: -1, // Unbounded size\n          data: [seekHead, segmentInfo, tracks],\n        };\n\n        let bufferStream = new ArrayBufferDataStream(256);\n\n        writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n        blobBuffer.write(bufferStream.getAsDataArray());\n\n        // Now we know where these top-level elements lie in the file:\n        seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(\n          segmentInfo.offset\n        );\n        seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(\n          tracks.offset\n        );\n\n        writtenHeader = true;\n      }\n\n      /**\n       * Create a BlockGroup element to hold the given keyframe (used when alpha support is required)\n       *\n       * @param {Frame} keyframe\n       *\n       * @return A BlockGroup EBML element\n       */\n      function createBlockGroupForTransparentKeyframe(keyframe) {\n        let block,\n          blockAdditions,\n          bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n\n        // Create a Block to hold the image data:\n\n        if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n          throw new Error(\"TrackNumber must be > 0 and < 127\");\n        }\n\n        bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n        bufferStream.writeU16BE(keyframe.timecode);\n        bufferStream.writeByte(0); // Flags byte\n\n        block = {\n          id: 0xa1, // Block\n          data: [bufferStream.getAsDataArray(), keyframe.frame],\n        };\n\n        blockAdditions = {\n          id: 0x75a1, // BlockAdditions\n          data: [\n            {\n              id: 0xa6, // BlockMore\n              data: [\n                {\n                  id: 0xee, // BlockAddID\n                  data: 1, // Means \"BlockAdditional has a codec-defined meaning, pass it to the codec\"\n                },\n                {\n                  id: 0xa5, // BlockAdditional\n                  data: keyframe.alpha, // The actual alpha channel image\n                },\n              ],\n            },\n          ],\n        };\n\n        return {\n          id: 0xa0, // BlockGroup\n          data: [block, blockAdditions],\n        };\n      }\n\n      /**\n       * Create a SimpleBlock element to hold the given keyframe.\n       *\n       * @param {Frame} keyframe\n       *\n       * @return A SimpleBlock EBML element.\n       */\n      function createSimpleBlockForKeyframe(keyframe) {\n        let bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n\n        if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n          throw new Error(\"TrackNumber must be > 0 and < 127\");\n        }\n\n        bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n        bufferStream.writeU16BE(keyframe.timecode);\n\n        // Flags byte\n        bufferStream.writeByte(\n          1 << 7 // Keyframe\n        );\n\n        return {\n          id: 0xa3, // SimpleBlock\n          data: [bufferStream.getAsDataArray(), keyframe.frame],\n        };\n      }\n\n      /**\n       * Create either a SimpleBlock or BlockGroup (if alpha is required) for the given keyframe.\n       *\n       * @param {Frame} keyframe\n       */\n      function createContainerForKeyframe(keyframe) {\n        if (keyframe.alpha) {\n          return createBlockGroupForTransparentKeyframe(keyframe);\n        }\n\n        return createSimpleBlockForKeyframe(keyframe);\n      }\n\n      /**\n       * Create a Cluster EBML node.\n       *\n       * @param {Cluster} cluster\n       *\n       * Returns an EBML element.\n       */\n      function createCluster(cluster) {\n        return {\n          id: 0x1f43b675,\n          data: [\n            {\n              id: 0xe7, // Timecode\n              data: Math.round(cluster.timecode),\n            },\n          ],\n        };\n      }\n\n      function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n        cues.push({\n          id: 0xbb, // Cue\n          data: [\n            {\n              id: 0xb3, // CueTime\n              data: clusterTime,\n            },\n            {\n              id: 0xb7, // CueTrackPositions\n              data: [\n                {\n                  id: 0xf7, // CueTrack\n                  data: trackIndex,\n                },\n                {\n                  id: 0xf1, // CueClusterPosition\n                  data: fileOffsetToSegmentRelative(clusterFileOffset),\n                },\n              ],\n            },\n          ],\n        });\n      }\n\n      /**\n       * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n       * The seek entry for the Cues in the SeekHead is updated.\n       */\n      function writeCues() {\n        let ebml = {\n            id: 0x1c53bb6b,\n            data: cues,\n          },\n          cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n\n        writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n        blobBuffer.write(cuesBuffer.getAsDataArray());\n\n        // Now we know where the Cues element has ended up, we can update the SeekHead\n        seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(\n          ebml.offset\n        );\n      }\n\n      /**\n       * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n       */\n      function flushClusterFrameBuffer() {\n        if (clusterFrameBuffer.length === 0) {\n          return;\n        }\n\n        // First work out how large of a buffer we need to hold the cluster data\n        let rawImageSize = 0;\n\n        for (let i = 0; i < clusterFrameBuffer.length; i++) {\n          rawImageSize +=\n            clusterFrameBuffer[i].frame.length +\n            (clusterFrameBuffer[i].alpha\n              ? clusterFrameBuffer[i].alpha.length\n              : 0);\n        }\n\n        let buffer = new ArrayBufferDataStream(\n            rawImageSize + clusterFrameBuffer.length * 64\n          ), // Estimate 64 bytes per block header\n          cluster = createCluster({\n            timecode: Math.round(clusterStartTime),\n          });\n\n        for (let i = 0; i < clusterFrameBuffer.length; i++) {\n          cluster.data.push(createContainerForKeyframe(clusterFrameBuffer[i]));\n        }\n\n        writeEBML(buffer, blobBuffer.pos, cluster);\n        blobBuffer.write(buffer.getAsDataArray());\n\n        addCuePoint(\n          DEFAULT_TRACK_NUMBER,\n          Math.round(clusterStartTime),\n          cluster.offset\n        );\n\n        clusterFrameBuffer = [];\n        clusterStartTime += clusterDuration;\n        clusterDuration = 0;\n      }\n\n      function validateOptions() {\n        // Derive frameDuration setting if not already supplied\n        if (!options.frameDuration) {\n          if (options.frameRate) {\n            options.frameDuration = 1000 / options.frameRate;\n          } else {\n            throw new Error(\n              \"Missing required frameDuration or frameRate setting\"\n            );\n          }\n        }\n\n        // Avoid 1.0 (lossless) because it creates VP8L lossless frames that WebM doesn't support\n        options.quality = Math.max(Math.min(options.quality, 0.99999), 0);\n\n        if (options.alphaQuality === undefined) {\n          options.alphaQuality = options.quality;\n        } else {\n          options.alphaQuality = Math.max(\n            Math.min(options.alphaQuality, 0.99999),\n            0\n          );\n        }\n      }\n\n      /**\n       *\n       * @param {Frame} frame\n       */\n      function addFrameToCluster(frame) {\n        frame.trackNumber = DEFAULT_TRACK_NUMBER;\n\n        // Frame timecodes are relative to the start of their cluster:\n        frame.timecode = Math.round(clusterDuration);\n\n        clusterFrameBuffer.push(frame);\n\n        clusterDuration += frame.duration;\n\n        if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n          flushClusterFrameBuffer();\n        }\n      }\n\n      /**\n       * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n       *\n       * Call once writing is complete (so the offset of all top level elements is known).\n       */\n      function rewriteSeekHead() {\n        let seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n          oldPos = blobBuffer.pos;\n\n        // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n        writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);\n\n        // And write that through to the file\n        blobBuffer.seek(seekHead.dataOffset);\n        blobBuffer.write(seekHeadBuffer.getAsDataArray());\n\n        blobBuffer.seek(oldPos);\n      }\n\n      /**\n       * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n       */\n      function rewriteDuration() {\n        let buffer = new ArrayBufferDataStream(8),\n          oldPos = blobBuffer.pos;\n\n        // Rewrite the data payload (don't need to update the id or size)\n        buffer.writeDoubleBE(clusterStartTime);\n\n        // And write that through to the file\n        blobBuffer.seek(segmentDuration.dataOffset);\n        blobBuffer.write(buffer.getAsDataArray());\n\n        blobBuffer.seek(oldPos);\n      }\n\n      /**\n       * Add a frame to the video.\n       *\n       * @param {HTMLCanvasElement|String} frame - A Canvas element that contains the frame, or a WebP string\n       *                                           you obtained by calling toDataUrl() on an image yourself.\n       *\n       * @param {HTMLCanvasElement|String} [alpha] - For transparent video, instead of including the alpha channel\n       *                                             in your provided `frame`, you can instead provide it separately\n       *                                             here. The alpha channel of this alpha canvas will be ignored,\n       *                                             encode your alpha information into this canvas' grayscale\n       *                                             brightness instead.\n       *\n       *                                             This is useful because it allows you to paint the colours\n       *                                             you need into your `frame` even in regions which are fully\n       *                                             transparent (which Canvas doesn't normally let you influence).\n       *                                             This allows you to control the colour of the fringing seen\n       *                                             around objects on transparent backgrounds.\n       *\n       * @param {Number} [overrideFrameDuration] - Set a duration for this frame (in milliseconds) that differs\n       *                                           from the default\n       */\n      this.addFrame = function (frame, alpha, overrideFrameDuration) {\n        if (!writtenHeader) {\n          videoWidth = frame.width || 0;\n          videoHeight = frame.height || 0;\n\n          writeHeader();\n        }\n\n        let keyframe = extractKeyframeFromWebP(\n            renderAsWebP(frame, options.quality)\n          ),\n          frameDuration,\n          frameAlpha = null;\n\n        if (overrideFrameDuration) {\n          frameDuration = overrideFrameDuration;\n        } else if (typeof alpha == \"number\") {\n          frameDuration = alpha;\n        } else {\n          frameDuration = options.frameDuration;\n        }\n\n        if (options.transparent) {\n          if (alpha instanceof HTMLCanvasElement || typeof alpha === \"string\") {\n            frameAlpha = alpha;\n          } else if (keyframe.hasAlpha) {\n            frameAlpha = convertAlphaToGrayscaleImage(frame);\n          }\n        }\n\n        addFrameToCluster({\n          frame: keyframe.frame,\n          duration: frameDuration,\n          alpha: frameAlpha\n            ? extractKeyframeFromWebP(\n                renderAsWebP(frameAlpha, options.alphaQuality)\n              ).frame\n            : null,\n        });\n      };\n\n      /**\n       * Finish writing the video and return a Promise to signal completion.\n       *\n       * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n       * a Blob with the contents of the entire video.\n       */\n      this.complete = function () {\n        console.log(\"webm-writer complete!\", blobBuffer.length);\n\n        if (!writtenHeader) {\n          writeHeader();\n        }\n\n        flushClusterFrameBuffer();\n\n        writeCues();\n        rewriteSeekHead();\n        rewriteDuration();\n\n        return blobBuffer.complete(\"video/webm\");\n      };\n\n      this.getWrittenSize = function () {\n        return blobBuffer.length;\n      };\n\n      options = extend(optionDefaults, options || {});\n      validateOptions();\n    };\n  };\n\n  window.WebMWriter = WebMWriter(\n    window.ArrayBufferDataStream,\n    window.BlobBuffer\n  );\n})();\n", "//download.js v4.21, by dandavis; 2008-2018. [MIT] see http://danml.com/download.html for tests/usage\n// v1 landed a FF+Chrome compatible way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime\n// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs\n// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.\n// v4 adds AMD/UMD, commonJS, and plain browser support\n// v4.1 adds url download capability via solo URL argument (same domain/CORS only)\n// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors\n// https://github.com/rndme/download\n\n; (function () {\n  window.download = function (data, strFileName, strMimeType) {\n    var self = window, // this script is only for browsers anyway...\n      defaultMime = \"application/octet-stream\", // this default mime also triggers iframe downloads\n      mimeType = strMimeType || defaultMime,\n      payload = data,\n      url = !strFileName && !strMimeType && payload,\n      anchor = document.createElement(\"a\"),\n      toString = function (a) { return String(a); },\n      myBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),\n      fileName = strFileName || \"download\",\n      blob,\n      reader;\n    myBlob = myBlob.call ? myBlob.bind(self) : Blob;\n\n    if (String(this) === \"true\") { //reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\n      payload = [payload, mimeType];\n      mimeType = payload[0];\n      payload = payload[1];\n    }\n\n\n    if (url && url.length < 2048) { // if no filename and no mime, assume a url was passed as the only argument\n      fileName = url.split(\"/\").pop().split(\"?\")[0];\n      anchor.href = url; // assign href prop to temp anchor\n      if (anchor.href.indexOf(url) !== -1) { // if the browser determines that it's a potentially valid url path:\n        var ajax = new XMLHttpRequest();\n        ajax.open(\"GET\", url, true);\n        ajax.responseType = 'blob';\n        ajax.onload = function (e) {\n          download(e.target.response, fileName, defaultMime);\n        };\n        setTimeout(function () { ajax.send(); }, 0); // allows setting custom ajax headers using the return:\n        return ajax;\n      } // end if valid url?\n    } // end if url?\n\n\n    //go ahead and download dataURLs right away\n    if (/^data:([\\w+-]+\\/[\\w+.-]+)?[,;]/.test(payload)) {\n\n      if (payload.length > (1024 * 1024 * 1.999) && myBlob !== toString) {\n        payload = dataUrlToBlob(payload);\n        mimeType = payload.type || defaultMime;\n      } else {\n        return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:\n          navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :\n          saver(payload); // everyone else can save dataURLs un-processed\n      }\n\n    } else {//not data url, is it a string with special needs?\n      if (/([\\x80-\\xff])/.test(payload)) {\n        var i = 0, tempUiArr = new Uint8Array(payload.length), mx = tempUiArr.length;\n        for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);\n        payload = new myBlob([tempUiArr], { type: mimeType });\n      }\n    }\n    blob = payload instanceof myBlob ?\n      payload :\n      new myBlob([payload], { type: mimeType });\n\n\n    function dataUrlToBlob(strUrl) {\n      var parts = strUrl.split(/[:;,]/),\n        type = parts[1],\n        indexDecoder = strUrl.indexOf(\"charset\") > 0 ? 3 : 2,\n        decoder = parts[indexDecoder] == \"base64\" ? atob : decodeURIComponent,\n        binData = decoder(parts.pop()),\n        mx = binData.length,\n        i = 0,\n        uiArr = new Uint8Array(mx);\n\n      for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);\n\n      return new myBlob([uiArr], { type: type });\n    }\n\n    function saver(url, winMode) {\n\n      if ('download' in anchor) { //html5 A[download]\n        anchor.href = url;\n        anchor.setAttribute(\"download\", fileName);\n        anchor.className = \"download-js-link\";\n        anchor.innerHTML = \"downloading...\";\n        anchor.style.display = \"none\";\n        anchor.addEventListener('click', function (e) {\n          e.stopPropagation();\n          this.removeEventListener('click', arguments.callee);\n        });\n        document.body.appendChild(anchor);\n        setTimeout(function () {\n          anchor.click();\n          document.body.removeChild(anchor);\n          if (winMode === true) { setTimeout(function () { self.URL.revokeObjectURL(anchor.href); }, 250); }\n        }, 66);\n        return true;\n      }\n\n      // handle non-a[download] safari as best we can:\n      if (/(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)) {\n        if (/^data:/.test(url)) url = \"data:\" + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n        if (!window.open(url)) { // popup blocked, offer direct download:\n          if (confirm(\"Displaying New Document. Use Save As... to download, then click back to return to this page.\")) { location.href = url; }\n        }\n        return true;\n      }\n\n      //do iframe dataURL download (old ch+FF):\n      var f = document.createElement(\"iframe\");\n      document.body.appendChild(f);\n\n      if (!winMode && /^data:/.test(url)) { // force a mime that will download:\n        url = \"data:\" + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n      }\n      f.src = url;\n      setTimeout(function () { document.body.removeChild(f); }, 333);\n\n    }//end saver\n\n\n\n\n    if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)\n      return navigator.msSaveBlob(blob, fileName);\n    }\n\n    if (self.URL) { // simple fast and modern way using Blob and URL:\n      saver(self.URL.createObjectURL(blob), true);\n    } else {\n      // handle non-Blob()+non-URL browsers:\n      if (typeof blob === \"string\" || blob.constructor === toString) {\n        try {\n          return saver(\"data:\" + mimeType + \";base64,\" + self.btoa(blob));\n        } catch (y) {\n          return saver(\"data:\" + mimeType + \",\" + encodeURIComponent(blob));\n        }\n      }\n\n      // Blob but not URL support:\n      reader = new FileReader();\n      reader.onload = function (e) {\n        saver(this.result);\n      };\n      reader.readAsDataURL(blob);\n    }\n    return true;\n  }; /* end download() */\n})();", "/*\nThe MIT License\n\nCopyright (c) 2012 Jaume Sanchez Elias\nhttps://github.com/spite/ccapture.js\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n; (function () {\n\n  \"use strict\";\n\n  var Tar = window.Tar;\n  var download = window.download;\n  var GIF = window.GIF;\n  var WebMWriter = window.WebMWriter;\n\n  /**\n  * Used as a reference to the global object.\n  *\n  * The `this` value is used if it's the global object to avoid Greasemonkey's\n  * restricted `window` object, otherwise the `window` object is used.\n  */\n\n  if (!('gc' in window)) {\n    window.gc = function () { }\n  }\n\n  if (!HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n      value: function (callback, type, quality) {\n\n        var binStr = atob(this.toDataURL(type, quality).split(',')[1]),\n          len = binStr.length,\n          arr = new Uint8Array(len);\n\n        for (var i = 0; i < len; i++) {\n          arr[i] = binStr.charCodeAt(i);\n        }\n\n        callback(new Blob([arr], { type: type || 'image/png' }));\n      }\n    });\n  }\n\n  // @license http://opensource.org/licenses/MIT\n  // copyright Paul Irish 2015\n\n\n  // Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n  //   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n  // as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n  // if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n  // but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n  (function () {\n\n    if (\"performance\" in window == false) {\n      window.performance = {};\n    }\n\n    if (\"now\" in window.performance == false) {\n      var nowOffset = Date.now();\n\n      window.performance.now = function now() {\n        return Date.now() - nowOffset;\n      }\n    }\n  })();\n\n  function pad(n) {\n    return String(\"0000000\" + n).slice(-7);\n  }\n  // https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers\n\n  var g_startTime = window.Date.now();\n\n  function guid() {\n    function s4() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  }\n\n  function CCFrameEncoder(settings) {\n\n    var _handlers = {};\n\n    this.settings = settings;\n\n    this.on = function (event, handler) {\n\n      _handlers[event] = handler;\n\n    };\n\n    this.emit = function (event) {\n\n      var handler = _handlers[event];\n      if (handler) {\n\n        handler.apply(null, Array.prototype.slice.call(arguments, 1));\n\n      }\n\n    };\n\n    this.filename = settings.name || guid();\n    this.extension = '';\n    this.mimeType = '';\n\n  }\n\n  CCFrameEncoder.prototype.start = function () { };\n  CCFrameEncoder.prototype.stop = function () { };\n  CCFrameEncoder.prototype.add = function () { };\n  CCFrameEncoder.prototype.save = function () { };\n  CCFrameEncoder.prototype.dispose = function () { };\n  CCFrameEncoder.prototype.safeToProceed = function () { return true; };\n  CCFrameEncoder.prototype.step = function () { console.log('Step not set!') }\n\n  // function CCTarEncoder(settings) {\n  //   CCFrameEncoder.call(this, settings);\n  //   this.extension = '.tar'\n  //   this.mimeType = 'application/x-tar'\n  //   this.fileExtension = '';\n  //   this.baseFilename = this.filename;\n  //   this.tape = null\n  //   this.count = 0;\n  //   this.part = 1;\n  //   this.frames = 0;\n  // }\n\n  // CCTarEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n  // CCTarEncoder.prototype.start = function () {\n  //   this.dispose();\n  // };\n  // CCTarEncoder.prototype.add = function (blob) {\n  //   var fileReader = new FileReader();\n  //   fileReader.onload = function () {\n  //     this.tape.append(pad(this.count) + this.fileExtension, new Uint8Array(fileReader.result));\n  //     if (this.settings.autoSaveTime > 0 && (this.frames / this.settings.framerate) >= this.settings.autoSaveTime) {\n  //       this.save(function (blob) {\n  //         this.filename = this.baseFilename + '-part-' + pad(this.part);\n  //         download(blob, this.filename + this.extension, this.mimeType);\n  //         var count = this.count;\n  //         this.dispose();\n  //         this.count = count + 1;\n  //         this.part++;\n  //         this.filename = this.baseFilename + '-part-' + pad(this.part);\n  //         this.frames = 0;\n  //         this.step();\n  //       }.bind(this))\n  //     } else {\n  //       this.count++;\n  //       this.frames++;\n  //       this.step();\n  //     }\n\n  //   }.bind(this);\n  //   fileReader.readAsArrayBuffer(blob);\n\n  // }\n\n  // CCTarEncoder.prototype.save = function (callback) {\n\n  //   callback(this.tape.save());\n\n  // }\n\n  // CCTarEncoder.prototype.dispose = function () {\n\n  //   this.tape = new Tar();\n  //   this.count = 0;\n\n  // }\n\n  // function CCPNGEncoder(settings) {\n\n  //   CCTarEncoder.call(this, settings);\n\n  //   this.type = 'image/png';\n  //   this.fileExtension = '.png';\n\n  // }\n\n  // CCPNGEncoder.prototype = Object.create(CCTarEncoder.prototype);\n\n  // CCPNGEncoder.prototype.add = function (canvas) {\n\n  //   canvas.toBlob(function (blob) {\n  //     CCTarEncoder.prototype.add.call(this, blob);\n  //   }.bind(this), this.type)\n\n  // }\n\n  // function CCJPEGEncoder(settings) {\n\n  //   CCTarEncoder.call(this, settings);\n\n  //   this.type = 'image/jpeg';\n  //   this.fileExtension = '.jpg';\n  //   this.quality = (settings.quality / 100) || .8;\n\n  // }\n\n  // CCJPEGEncoder.prototype = Object.create(CCTarEncoder.prototype);\n\n  // CCJPEGEncoder.prototype.add = function (canvas) {\n\n  //   canvas.toBlob(function (blob) {\n  //     CCTarEncoder.prototype.add.call(this, blob);\n  //   }.bind(this), this.type, this.quality)\n  // }\n\n  /*\n  \n    WebM Encoder\n  \n  */\n\n  function CCWebMEncoder(settings) {\n    var canvas = document.createElement('canvas');\n\n    CCFrameEncoder.call(this, settings);\n\n    this.quality = (settings.quality / 100) || .8;\n\n    this.extension = '.webm'\n    this.mimeType = 'video/webm'\n    this.baseFilename = this.filename;\n    this.framerate = settings.framerate;\n\n    this.frames = 0;\n    this.part = 1;\n\n    this.videoWriter = new WebMWriter({\n      quality: this.quality,\n      fileWriter: null,\n      fd: null,\n      frameRate: this.framerate\n    });\n\n  }\n\n  CCWebMEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n  CCWebMEncoder.prototype.start = function (canvas) {\n\n    this.dispose();\n\n  }\n\n  CCWebMEncoder.prototype.add = function (canvas) {\n\n    this.videoWriter.addFrame(canvas);\n\n    if (this.settings.autoSaveTime > 0 && (this.frames / this.settings.framerate) >= this.settings.autoSaveTime) {\n      this.save(function (blob) {\n        this.filename = this.baseFilename + '-part-' + pad(this.part);\n        download(blob, this.filename + this.extension, this.mimeType);\n        this.dispose();\n        this.part++;\n        this.filename = this.baseFilename + '-part-' + pad(this.part);\n        this.step();\n      }.bind(this))\n    } else {\n      this.frames++;\n      this.step();\n    }\n\n  }\n\n  CCWebMEncoder.prototype.save = function (callback) {\n\n    this.videoWriter.complete().then(callback);\n\n  }\n\n  CCWebMEncoder.prototype.dispose = function (canvas) {\n\n    this.frames = 0;\n    this.videoWriter = new WebMWriter({\n      quality: this.quality,\n      fileWriter: null,\n      fd: null,\n      frameRate: this.framerate\n    });\n\n  }\n\n  function CCFFMpegServerEncoder(settings) {\n\n    CCFrameEncoder.call(this, settings);\n\n    settings.quality = (settings.quality / 100) || .8;\n\n    this.encoder = new FFMpegServer.Video(settings);\n    this.encoder.on('process', function () {\n      this.emit('process')\n    }.bind(this));\n    this.encoder.on('finished', function (url, size) {\n      var cb = this.callback;\n      if (cb) {\n        this.callback = undefined;\n        cb(url, size);\n      }\n    }.bind(this));\n    this.encoder.on('progress', function (progress) {\n      if (this.settings.onProgress) {\n        this.settings.onProgress(progress)\n      }\n    }.bind(this));\n    this.encoder.on('error', function (data) {\n      alert(JSON.stringify(data, null, 2));\n    }.bind(this));\n\n  }\n\n  CCFFMpegServerEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n  CCFFMpegServerEncoder.prototype.start = function () {\n\n    this.encoder.start(this.settings);\n\n  };\n\n  CCFFMpegServerEncoder.prototype.add = function (canvas) {\n\n    this.encoder.add(canvas);\n\n  }\n\n  CCFFMpegServerEncoder.prototype.save = function (callback) {\n\n    this.callback = callback;\n    this.encoder.end();\n\n  }\n\n  CCFFMpegServerEncoder.prototype.safeToProceed = function () {\n    return this.encoder.safeToProceed();\n  };\n\n  /*\n    HTMLCanvasElement.captureStream()\n  */\n\n  function CCStreamEncoder(settings) {\n\n    CCFrameEncoder.call(this, settings);\n\n    this.framerate = this.settings.framerate;\n    this.type = 'video/webm';\n    this.extension = '.webm';\n    this.stream = null;\n    this.mediaRecorder = null;\n    this.chunks = [];\n\n  }\n\n  CCStreamEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n  CCStreamEncoder.prototype.add = function (canvas) {\n\n    if (!this.stream) {\n      this.stream = canvas.captureStream(this.framerate);\n      this.mediaRecorder = new MediaRecorder(this.stream);\n      this.mediaRecorder.start();\n\n      this.mediaRecorder.ondataavailable = function (e) {\n        this.chunks.push(e.data);\n      }.bind(this);\n\n    }\n    this.step();\n\n  }\n\n  CCStreamEncoder.prototype.save = function (callback) {\n\n    this.mediaRecorder.onstop = function (e) {\n      var blob = new Blob(this.chunks, { 'type': 'video/webm' });\n      this.chunks = [];\n      callback(blob);\n\n    }.bind(this);\n\n    this.mediaRecorder.stop();\n\n  }\n\n  /*function CCGIFEncoder( settings ) {\n  \n    CCFrameEncoder.call( this );\n  \n    settings.quality = settings.quality || 6;\n    this.settings = settings;\n  \n    this.encoder = new GIFEncoder();\n    this.encoder.setRepeat( 1 );\n      this.encoder.setDelay( settings.step );\n      this.encoder.setQuality( 6 );\n      this.encoder.setTransparent( null );\n      this.encoder.setSize( 150, 150 );\n  \n      this.canvas = document.createElement( 'canvas' );\n      this.ctx = this.canvas.getContext( '2d' );\n  \n  }\n  \n  CCGIFEncoder.prototype = Object.create( CCFrameEncoder );\n  \n  CCGIFEncoder.prototype.start = function() {\n  \n    this.encoder.start();\n  \n  }\n  \n  CCGIFEncoder.prototype.add = function( canvas ) {\n  \n    this.canvas.width = canvas.width;\n    this.canvas.height = canvas.height;\n    this.ctx.drawImage( canvas, 0, 0 );\n    this.encoder.addFrame( this.ctx );\n  \n    this.encoder.setSize( canvas.width, canvas.height );\n    var readBuffer = new Uint8Array(canvas.width * canvas.height * 4);\n    var context = canvas.getContext( 'webgl' );\n    context.readPixels(0, 0, canvas.width, canvas.height, context.RGBA, context.UNSIGNED_BYTE, readBuffer);\n    this.encoder.addFrame( readBuffer, true );\n  \n  }\n  \n  CCGIFEncoder.prototype.stop = function() {\n  \n    this.encoder.finish();\n  \n  }\n  \n  CCGIFEncoder.prototype.save = function( callback ) {\n  \n    var binary_gif = this.encoder.stream().getData();\n  \n    var data_url = 'data:image/gif;base64,'+encode64(binary_gif);\n    window.location = data_url;\n    return;\n  \n    var blob = new Blob( [ binary_gif ], { type: \"octet/stream\" } );\n    var url = window.URL.createObjectURL( blob );\n    callback( url );\n  \n  }*/\n\n  function CCGIFEncoder(settings) {\n\n    CCFrameEncoder.call(this, settings);\n\n    settings.quality = 31 - ((settings.quality * 30 / 100) || 10);\n    settings.workers = settings.workers || 4;\n\n    this.extension = '.gif'\n    this.mimeType = 'image/gif'\n\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    this.sizeSet = false;\n\n    this.encoder = new GIF({\n      workers: settings.workers,\n      quality: settings.quality,\n      workerScript: settings.workersPath + 'gif.worker.js'\n    });\n\n    this.encoder.on('progress', function (progress) {\n      if (this.settings.onProgress) {\n        this.settings.onProgress(progress)\n      }\n    }.bind(this));\n\n    this.encoder.on('finished', function (blob) {\n      var cb = this.callback;\n      if (cb) {\n        this.callback = undefined;\n        cb(blob);\n      }\n    }.bind(this));\n\n  }\n\n  CCGIFEncoder.prototype = Object.create(CCFrameEncoder.prototype);\n\n  CCGIFEncoder.prototype.add = function (canvas) {\n\n    if (!this.sizeSet) {\n      this.encoder.setOption('width', canvas.width);\n      this.encoder.setOption('height', canvas.height);\n      this.sizeSet = true;\n    }\n\n    this.canvas.width = canvas.width;\n    this.canvas.height = canvas.height;\n    this.ctx.drawImage(canvas, 0, 0);\n\n    this.encoder.addFrame(this.ctx, { copy: true, delay: this.settings.step });\n    this.step();\n\n    /*this.encoder.setSize( canvas.width, canvas.height );\n    var readBuffer = new Uint8Array(canvas.width * canvas.height * 4);\n    var context = canvas.getContext( 'webgl' );\n    context.readPixels(0, 0, canvas.width, canvas.height, context.RGBA, context.UNSIGNED_BYTE, readBuffer);\n    this.encoder.addFrame( readBuffer, true );*/\n\n  }\n\n  CCGIFEncoder.prototype.save = function (callback) {\n\n    this.callback = callback;\n\n    this.encoder.render();\n\n  }\n\n  function CCapture(settings) {\n\n    var _settings = settings || {},\n      _date = new Date(),\n      _verbose,\n      _display,\n      _time,\n      _startTime,\n      _performanceTime,\n      _performanceStartTime,\n      _step,\n      _encoder,\n      _timeouts = [],\n      _intervals = [],\n      _frameCount = 0,\n      _intermediateFrameCount = 0,\n      _lastFrame = null,\n      _requestAnimationFrameCallbacks = [],\n      _capturing = false,\n      _handlers = {};\n\n    _settings.framerate = _settings.framerate || 60;\n    _settings.motionBlurFrames = 2 * (_settings.motionBlurFrames || 1);\n    _verbose = _settings.verbose || false;\n    _display = _settings.display || false;\n    _settings.step = 1000.0 / _settings.framerate;\n    _settings.timeLimit = _settings.timeLimit || 0;\n    _settings.frameLimit = _settings.frameLimit || 0;\n    _settings.startTime = _settings.startTime || 0;\n\n    var _timeDisplay = document.createElement('div');\n    _timeDisplay.style.position = 'absolute';\n    _timeDisplay.style.left = _timeDisplay.style.top = 0\n    _timeDisplay.style.backgroundColor = 'black';\n    _timeDisplay.style.fontFamily = 'monospace'\n    _timeDisplay.style.fontSize = '11px'\n    _timeDisplay.style.padding = '5px'\n    _timeDisplay.style.color = 'red';\n    _timeDisplay.style.zIndex = 100000\n    if (_settings.display) document.body.appendChild(_timeDisplay);\n\n    var canvasMotionBlur = document.createElement('canvas');\n    var ctxMotionBlur = canvasMotionBlur.getContext('2d');\n    var bufferMotionBlur;\n    var imageData;\n\n    _log('Step is set to ' + _settings.step + 'ms');\n\n    var _encoders = {\n      // gif: CCGIFEncoder,\n      webm: CCWebMEncoder,\n      // ffmpegserver: CCFFMpegServerEncoder,\n      // png: CCPNGEncoder,\n      // jpg: CCJPEGEncoder,\n      'webm-mediarecorder': CCStreamEncoder\n    };\n\n    var ctor = _encoders[_settings.format];\n    if (!ctor) {\n      throw \"Error: Incorrect or missing format: Valid formats are \" + Object.keys(_encoders).join(\", \");\n    }\n    _encoder = new ctor(_settings);\n    _encoder.step = _step\n\n    _encoder.on('process', _process);\n    _encoder.on('progress', _progress);\n\n    if (\"performance\" in window == false) {\n      window.performance = {};\n    }\n\n    Date.now = (Date.now || function () {  // thanks IE8\n      return new Date().getTime();\n    });\n\n    if (\"now\" in window.performance == false) {\n\n      var nowOffset = Date.now();\n\n      if (performance.timing && performance.timing.navigationStart) {\n        nowOffset = performance.timing.navigationStart\n      }\n\n      window.performance.now = function now() {\n        return Date.now() - nowOffset;\n      }\n    }\n\n    var _oldSetTimeout = window.setTimeout,\n      _oldSetInterval = window.setInterval,\n      _oldClearInterval = window.clearInterval,\n      _oldClearTimeout = window.clearTimeout,\n      _oldRequestAnimationFrame = window.requestAnimationFrame,\n      _oldNow = window.Date.now,\n      _oldPerformanceNow = window.performance.now,\n      _oldGetTime = window.Date.prototype.getTime;\n    // Date.prototype._oldGetTime = Date.prototype.getTime;\n\n    var media = [];\n\n    function _init() {\n\n      _log('Capturer start');\n\n      _startTime = window.Date.now();\n      _time = _startTime + _settings.startTime;\n      _performanceStartTime = window.performance.now();\n      _performanceTime = _performanceStartTime + _settings.startTime;\n\n      window.Date.prototype.getTime = function () {\n        return _time;\n      };\n      window.Date.now = function () {\n        return _time;\n      };\n\n      window.setTimeout = function (callback, time) {\n        var t = {\n          callback: callback,\n          time: time,\n          triggerTime: _time + time\n        };\n        _timeouts.push(t);\n        _log('Timeout set to ' + t.time);\n        return t;\n      };\n      window.clearTimeout = function (id) {\n        for (var j = 0; j < _timeouts.length; j++) {\n          if (_timeouts[j] == id) {\n            _timeouts.splice(j, 1);\n            _log('Timeout cleared');\n            continue;\n          }\n        }\n      };\n      window.setInterval = function (callback, time) {\n        var t = {\n          callback: callback,\n          time: time,\n          triggerTime: _time + time\n        };\n        _intervals.push(t);\n        _log('Interval set to ' + t.time);\n        return t;\n      };\n      window.clearInterval = function (id) {\n        _log('clear Interval');\n        return null;\n      };\n      window.requestAnimationFrame = function (callback) {\n        _requestAnimationFrameCallbacks.push(callback);\n      };\n      window.performance.now = function () {\n        return _performanceTime;\n      };\n\n      function hookCurrentTime() {\n        if (!this._hooked) {\n          this._hooked = true;\n          this._hookedTime = this.currentTime || 0;\n          this.pause();\n          media.push(this);\n        }\n        return this._hookedTime + _settings.startTime;\n      };\n\n      try {\n        Object.defineProperty(HTMLVideoElement.prototype, 'currentTime', { get: hookCurrentTime })\n        Object.defineProperty(HTMLAudioElement.prototype, 'currentTime', { get: hookCurrentTime })\n      } catch (err) {\n        _log(err);\n      }\n\n    }\n\n    function _start() {\n      _init();\n      _encoder.start();\n      _capturing = true;\n    }\n\n    function _stop() {\n      _capturing = false;\n      _encoder.stop();\n      _destroy();\n    }\n\n    function _call(fn, p) {\n      _oldSetTimeout(fn, 0, p);\n    }\n\n    function _step() {\n      //_oldRequestAnimationFrame( _process );\n      _call(_process);\n    }\n\n    function _destroy() {\n      _log('Capturer stop');\n      window.setTimeout = _oldSetTimeout;\n      window.setInterval = _oldSetInterval;\n      window.clearInterval = _oldClearInterval;\n      window.clearTimeout = _oldClearTimeout;\n      window.requestAnimationFrame = _oldRequestAnimationFrame;\n      window.Date.prototype.getTime = _oldGetTime;\n      window.Date.now = _oldNow;\n      window.performance.now = _oldPerformanceNow;\n    }\n\n    function _updateTime() {\n      var seconds = _frameCount / _settings.framerate;\n      if ((_settings.frameLimit && _frameCount >= _settings.frameLimit) || (_settings.timeLimit && seconds >= _settings.timeLimit)) {\n        _stop();\n        _save();\n      }\n      var d = new Date(null);\n      d.setSeconds(seconds);\n      if (_settings.motionBlurFrames > 2) {\n        _timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames (' + _intermediateFrameCount + ' inter) | ' + d.toISOString().substr(11, 8);\n      } else {\n        _timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames | ' + d.toISOString().substr(11, 8);\n      }\n    }\n\n    function _checkFrame(canvas) {\n\n      if (canvasMotionBlur.width !== canvas.width || canvasMotionBlur.height !== canvas.height) {\n        canvasMotionBlur.width = canvas.width;\n        canvasMotionBlur.height = canvas.height;\n        bufferMotionBlur = new Uint16Array(canvasMotionBlur.height * canvasMotionBlur.width * 4);\n        ctxMotionBlur.fillStyle = '#0'\n        ctxMotionBlur.fillRect(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);\n      }\n\n    }\n\n    function _blendFrame(canvas) {\n\n      //_log( 'Intermediate Frame: ' + _intermediateFrameCount );\n\n      ctxMotionBlur.drawImage(canvas, 0, 0);\n      imageData = ctxMotionBlur.getImageData(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);\n      for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n        bufferMotionBlur[j] += imageData.data[j];\n        bufferMotionBlur[j + 1] += imageData.data[j + 1];\n        bufferMotionBlur[j + 2] += imageData.data[j + 2];\n      }\n      _intermediateFrameCount++;\n\n    }\n\n    function _saveFrame() {\n      var data = imageData.data;\n      for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n        data[j] = bufferMotionBlur[j] * 2 / _settings.motionBlurFrames;\n        data[j + 1] = bufferMotionBlur[j + 1] * 2 / _settings.motionBlurFrames;\n        data[j + 2] = bufferMotionBlur[j + 2] * 2 / _settings.motionBlurFrames;\n      }\n      ctxMotionBlur.putImageData(imageData, 0, 0);\n      _encoder.add(canvasMotionBlur);\n      _frameCount++;\n      _intermediateFrameCount = 0;\n      _log('Full MB Frame! ' + _frameCount + ' ' + _time);\n      for (var j = 0; j < bufferMotionBlur.length; j += 4) {\n        bufferMotionBlur[j] = 0;\n        bufferMotionBlur[j + 1] = 0;\n        bufferMotionBlur[j + 2] = 0;\n      }\n      gc();\n\n    }\n\n    function _capture(canvas) {\n\n      if (_capturing) {\n\n        if (_settings.motionBlurFrames > 2) {\n\n          _checkFrame(canvas);\n          _blendFrame(canvas);\n\n          if (_intermediateFrameCount >= .5 * _settings.motionBlurFrames) {\n            _saveFrame();\n          } else {\n            _step();\n          }\n\n        } else {\n          _encoder.add(canvas);\n          _frameCount++;\n          _log('Full Frame! ' + _frameCount);\n        }\n\n      }\n\n    }\n\n    function _process() {\n\n      var step = 1000 / _settings.framerate;\n      var dt = (_frameCount + _intermediateFrameCount / _settings.motionBlurFrames) * step;\n\n      _time = _startTime + dt;\n      _performanceTime = _performanceStartTime + dt;\n\n      media.forEach(function (v) {\n        v._hookedTime = dt / 1000;\n      });\n\n      _updateTime();\n      _log('Frame: ' + _frameCount + ' ' + _intermediateFrameCount);\n\n      for (var j = 0; j < _timeouts.length; j++) {\n        if (_time >= _timeouts[j].triggerTime) {\n          _call(_timeouts[j].callback)\n          //console.log( 'timeout!' );\n          _timeouts.splice(j, 1);\n          continue;\n        }\n      }\n\n      for (var j = 0; j < _intervals.length; j++) {\n        if (_time >= _intervals[j].triggerTime) {\n          _call(_intervals[j].callback);\n          _intervals[j].triggerTime += _intervals[j].time;\n          //console.log( 'interval!' );\n          continue;\n        }\n      }\n\n      _requestAnimationFrameCallbacks.forEach(function (cb) {\n        _call(cb, _time - g_startTime);\n      });\n      _requestAnimationFrameCallbacks = [];\n\n    }\n\n    function _save(callback) {\n\n      if (!callback) {\n        callback = function (blob) {\n          download(blob, _encoder.filename + _encoder.extension, _encoder.mimeType);\n          return false;\n        }\n      }\n      _encoder.save(callback);\n\n    }\n\n    function _log(message) {\n      if (_verbose) console.log(message);\n    }\n\n    function _on(event, handler) {\n\n      _handlers[event] = handler;\n\n    }\n\n    function _emit(event) {\n\n      var handler = _handlers[event];\n      if (handler) {\n\n        handler.apply(null, Array.prototype.slice.call(arguments, 1));\n\n      }\n\n    }\n\n    function _progress(progress) {\n\n      _emit('progress', progress);\n\n    }\n\n    return {\n      start: _start,\n      capture: _capture,\n      stop: _stop,\n      save: _save,\n      on: _on\n    }\n  }\n\n  window.CCapture = CCapture;\n}());", "import \"./vendor/webm-writer-0.3.0\";\nimport \"./vendor/download\";\nimport \"./vendor/ccapture\";\n\ndeclare global {\n  interface Window {\n    CCapture: any;\n  }\n}\n\nexport type CapturerSettings = {\n  frameCount: number;\n  element: HTMLCanvasElement;\n  onComplete?: Function;\n};\n\nexport default class Capturer {\n  running: boolean;\n  active: boolean;\n  capture: CCapture;\n  maxFrames: number;\n  frames: number;\n  el: HTMLCanvasElement;\n  onComplete: Function;\n\n  constructor() {\n    this.active = false;\n    this.running = false;\n  }\n\n  enableCapture({ frameCount, element, onComplete }: CapturerSettings) {\n    this.active = true;\n    this.el = element;\n    this.maxFrames = frameCount;\n    this.frames = 0;\n    this.capture = new window.CCapture({\n      framerate: 60,\n      format: \"webm\",\n      verbose: false,\n    });\n    this.onComplete = onComplete || function () {};\n  }\n\n  captureFrame() {\n    if (this.active && !this.running) {\n      this.capture.start();\n    }\n\n    if (this.active) {\n      this.capture.capture(this.el);\n      this.frames++;\n\n      if (this.frames > this.maxFrames) {\n        this.capture.stop();\n        this.capture.save();\n        this.onComplete();\n      }\n    }\n  }\n}\n", "import Capturer, { CapturerSettings } from \"./capturer\";\n\ndeclare global {\n  interface Window {\n    enableCapture: (settings: CapturerSettings) => void;\n    captureFrame: () => void;\n  }\n}\n\nif (window) {\n  // running in a browser, attach capturer to global window object\n  const capturer = new Capturer();\n  window.enableCapture = capturer.enableCapture.bind(capturer);\n  window.captureFrame = capturer.captureFrame.bind(capturer);\n}\n"],
  "mappings": ";;AAUA,EAAC,YAAY;AAKX,QAAI,wBAAwB,SAAU,QAAQ;AAC5C,WAAK,OAAO,IAAI,WAAW;AAC3B,WAAK,MAAM;AAAA;AAGb,0BAAsB,UAAU,OAAO,SAAU,UAAU;AACzD,WAAK,MAAM;AAAA;AAGb,0BAAsB,UAAU,aAAa,SAAU,KAAK;AAC1D,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,aAAK,KAAK,KAAK,SAAS,IAAI;AAAA;AAAA;AAIhC,0BAAsB,UAAU,YAAY,SAAU,GAAG;AACvD,WAAK,KAAK,KAAK,SAAS;AAAA;AAI1B,0BAAsB,UAAU,UAC9B,sBAAsB,UAAU;AAElC,0BAAsB,UAAU,aAAa,SAAU,GAAG;AACxD,WAAK,KAAK,KAAK,SAAS,KAAK;AAC7B,WAAK,KAAK,KAAK,SAAS;AAAA;AAG1B,0BAAsB,UAAU,gBAAgB,SAAU,GAAG;AAC3D,UAAI,QAAQ,IAAI,WAAW,IAAI,aAAa,CAAC,IAAI;AAEjD,eAAS,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AAC1C,aAAK,UAAU,MAAM;AAAA;AAAA;AAIzB,0BAAsB,UAAU,eAAe,SAAU,GAAG;AAC1D,UAAI,QAAQ,IAAI,WAAW,IAAI,aAAa,CAAC,IAAI;AAEjD,eAAS,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AAC1C,aAAK,UAAU,MAAM;AAAA;AAAA;AAOzB,0BAAsB,UAAU,cAAc,SAAU,GAAG;AACzD,eAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,aAAK,KAAK,KAAK,SAAS,EAAE,WAAW;AAAA;AAAA;AAazC,0BAAsB,UAAU,uBAAuB,SAAU,GAAG,OAAO;AACzE,cAAQ;AAAA,aACD;AACH,eAAK,QAAS,KAAK,IAAK;AACxB;AAAA,aACG;AACH,eAAK,QAAS,KAAK,IAAM,KAAK;AAC9B,eAAK,QAAQ;AACb;AAAA,aACG;AACH,eAAK,QAAS,KAAK,IAAM,KAAK;AAC9B,eAAK,QAAQ,KAAK;AAClB,eAAK,QAAQ;AACb;AAAA,aACG;AACH,eAAK,QAAS,KAAK,IAAM,KAAK;AAC9B,eAAK,QAAQ,KAAK;AAClB,eAAK,QAAQ,KAAK;AAClB,eAAK,QAAQ;AACb;AAAA,aACG;AAKH,eAAK,QAAS,KAAK,IAAO,IAAI,aAAc;AAC5C,eAAK,QAAQ,KAAK;AAClB,eAAK,QAAQ,KAAK;AAClB,eAAK,QAAQ,KAAK;AAClB,eAAK,QAAQ;AACb;AAAA;AAEA,gBAAM,IAAI,MAAM,wBAAwB;AAAA;AAAA;AAO9C,0BAAsB,UAAU,oBAAoB,SAAU,KAAK;AACjE,UAAI,MAAO,MAAK,KAAK,GAAG;AAItB,eAAO;AAAA,iBACE,MAAO,MAAK,MAAM,GAAG;AAC9B,eAAO;AAAA,iBACE,MAAO,MAAK,MAAM,GAAG;AAC9B,eAAO;AAAA,iBACE,MAAO,MAAK,MAAM,GAAG;AAC9B,eAAO;AAAA,iBACE,MAAM,aAAa;AAE5B,eAAO;AAAA,aACF;AACL,cAAM,IAAI,MAAM,kCAAkC;AAAA;AAAA;AAItD,0BAAsB,UAAU,kBAAkB,SAAU,GAAG;AAC7D,WAAK,qBAAqB,GAAG,KAAK,kBAAkB;AAAA;AAYtD,0BAAsB,UAAU,qBAAqB,SAAU,GAAG,OAAO;AACvE,UAAI,UAAU,QAAW;AACvB,gBAAQ,KAAK,mBAAmB;AAAA;AAIlC,cAAQ;AAAA,aACD;AACH,eAAK,QAAQ,KAAK,MAAM,IAAI;AAAA,aACzB;AACH,eAAK,QAAQ,KAAK;AAAA,aACf;AACH,eAAK,QAAQ,KAAK;AAAA,aACf;AACH,eAAK,QAAQ,KAAK;AAAA,aACf;AACH,eAAK,QAAQ;AACb;AAAA;AAEA,gBAAM,IAAI,MAAM,mBAAmB;AAAA;AAAA;AAOzC,0BAAsB,UAAU,qBAAqB,SAAU,KAAK;AAElE,UAAI,MAAM,KAAK,GAAG;AAChB,eAAO;AAAA,iBACE,MAAM,KAAK,IAAI;AACxB,eAAO;AAAA,iBACE,MAAM,KAAK,IAAI;AACxB,eAAO;AAAA,iBACE,MAAM,YAAY;AAC3B,eAAO;AAAA,aACF;AACL,eAAO;AAAA;AAAA;AAOX,0BAAsB,UAAU,iBAAiB,WAAY;AAC3D,UAAI,KAAK,MAAM,KAAK,KAAK,YAAY;AACnC,eAAO,KAAK,KAAK,SAAS,GAAG,KAAK;AAAA,iBACzB,KAAK,OAAO,KAAK,KAAK,YAAY;AAC3C,eAAO,KAAK;AAAA,aACP;AACL,cAAM,IAAI,MAAM;AAAA;AAAA;AAIpB,WAAO,wBAAwB;AAAA;AAejC,EAAC,YAAY;AACX,QAAI,aAAa,SAAU,IAAI;AAC7B,aAAO,SAAU,aAAa;AAC5B,YAAI,SAAS,IACX,eAAe,QAAQ,WACvB,aAAa,MACb,KAAK;AAEP,YAAI,eAAe,YAAY,YAAY,SAAS,cAAc;AAChE,uBAAa;AAAA,mBACJ,MAAM,aAAa;AAC5B,eAAK;AAAA;AAGP,YAAI,CAAC,MAAM,cAAc,QAAQ,MAAM,MAAM;AAC3C,kBAAQ,MAAM;AAAA;AAIhB,aAAK,MAAM;AAGX,aAAK,SAAS;AAGd,kCAA0B,MAAM;AAC9B,iBAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC5C,gBAAI,SAAS,IAAI;AAEjB,mBAAO,iBAAiB,WAAW,WAAY;AAC7C,sBAAQ,OAAO;AAAA;AAGjB,mBAAO,kBAAkB;AAAA;AAAA;AAI7B,qCAA6B,OAAO;AAClC,iBAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC5C,gBAAI,iBAAiB,YAAY;AAC/B,sBAAQ;AAAA,uBAER,iBAAiB,eACjB,YAAY,OAAO,QACnB;AACA,sBAAQ,IAAI,WAAW;AAAA,uBACd,iBAAiB,MAAM;AAChC,sBACE,iBAAiB,OAAO,KAAK,SAAU,SAAQ;AAC7C,uBAAO,IAAI,WAAW;AAAA;AAAA,mBAGrB;AAEL,sBACE,iBAAiB,IAAI,KAAK,CAAC,SAAS,KAAK,SAAU,SAAQ;AACzD,uBAAO,IAAI,WAAW;AAAA;AAAA;AAAA;AAAA;AAOhC,6BAAqB,MAAM;AACzB,cAAI,SAAS,KAAK,cAAc,KAAK,UAAU,KAAK;AAEpD,cAAI,CAAC,OAAO,UAAU,SAAS;AAC7B,kBAAM,IAAI,MAAM;AAAA;AAGlB,iBAAO;AAAA;AAST,aAAK,OAAO,SAAU,QAAQ;AAC5B,cAAI,SAAS,GAAG;AACd,kBAAM,IAAI,MAAM;AAAA;AAGlB,cAAI,MAAM,SAAS;AACjB,kBAAM,IAAI,MAAM;AAAA;AAGlB,cAAI,SAAS,KAAK,QAAQ;AACxB,kBAAM,IAAI,MAAM;AAAA;AAGlB,eAAK,MAAM;AAAA;AASb,aAAK,QAAQ,SAAU,MAAM;AAC3B,cAAI,WAAW;AAAA,YACX,QAAQ,KAAK;AAAA,YACb;AAAA,YACA,QAAQ,YAAY;AAAA,aAEtB,WAAW,SAAS,UAAU,KAAK;AAErC,eAAK,OAAO,SAAS;AACrB,eAAK,SAAS,KAAK,IAAI,KAAK,QAAQ,KAAK;AAGzC,yBAAe,aAAa,KAAK,WAAY;AAC3C,gBAAI,IAAI;AACN,qBAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC5C,oCAAoB,SAAS,MAAM,KAAK,SAAU,WAAW;AAC3D,sBAAI,eAAe,GACjB,UAAS,OAAO,KAAK,UAAU,SAC/B,sBAAsB,SAAU,KAAK,SAAS,SAAQ;AACpD,oCAAgB;AAEhB,wBAAI,gBAAgB,QAAO,QAAQ;AACjC;AAAA,2BACK;AAEL,yBAAG,MACD,IACA,SACA,cACA,QAAO,SAAS,cAChB,SAAS,SAAS,cAClB;AAAA;AAAA;AAKR,qBAAG,MACD,IACA,SACA,GACA,QAAO,QACP,SAAS,QACT;AAAA;AAAA;AAAA,uBAIG,YAAY;AACrB,qBAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC5C,2BAAW,aAAa;AAExB,2BAAW,KAAK,SAAS;AACzB,2BAAW,MAAM,IAAI,KAAK,CAAC,SAAS;AAAA;AAAA,uBAE7B,CAAC,UAAU;AAIpB,uBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,oBAAI,QAAQ,OAAO;AAGnB,oBACE,CACE,UAAS,SAAS,SAAS,UAAU,MAAM,UAC3C,SAAS,UAAU,MAAM,SAAS,MAAM,SAE1C;AACA,sBACE,SAAS,SAAS,MAAM,UACxB,SAAS,SAAS,SAAS,SACzB,MAAM,SAAS,MAAM,QACvB;AACA,0BAAM,IAAI,MAAM;AAAA;AAGlB,sBACE,SAAS,UAAU,MAAM,UACzB,SAAS,UAAU,MAAM,QACzB;AAEA,0BAAM,OAAO,SAAS;AAGtB;AAAA,yBACK;AACL,2BAAO,oBAAoB,MAAM,MAC9B,KAAK,SAAU,YAAY;AAC1B,4BAAM,OAAO;AAEb,6BAAO,oBAAoB,SAAS;AAAA,uBAErC,KAAK,SAAU,eAAe;AAC7B,+BAAS,OAAO;AAEhB,4BAAM,KAAK,IACT,SAAS,MACT,SAAS,SAAS,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAStC,mBAAO,KAAK;AAAA;AAAA;AAYhB,aAAK,WAAW,SAAU,UAAU;AAClC,cAAI,MAAM,YAAY;AACpB,2BAAe,aAAa,KAAK,WAAY;AAC3C,qBAAO;AAAA;AAAA,iBAEJ;AAEL,2BAAe,aAAa,KAAK,WAAY;AAC3C,kBAAI,SAAS;AAEb,uBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,uBAAO,KAAK,OAAO,GAAG;AAAA;AAGxB,qBAAO,IAAI,KAAK,QAAQ,EAAE,MAAM;AAAA;AAAA;AAIpC,iBAAO;AAAA;AAAA;AAAA;AAKb,WAAO,aAAa,WAAW;AAAA;AAkBjC,EAAC,YAAY;AACX,oBAAgB,MAAM,KAAK;AACzB,UAAI,SAAS;AAEb,OAAC,MAAM,KAAK,QAAQ,SAAU,KAAK;AACjC,iBAAS,QAAQ,KAAK;AACpB,cAAI,OAAO,UAAU,eAAe,KAAK,KAAK,OAAO;AACnD,mBAAO,QAAQ,IAAI;AAAA;AAAA;AAAA;AAKzB,aAAO;AAAA;AAQT,qCAAiC,KAAK;AACpC,UAAI,OAAO,QAAQ,YAAY,CAAC,IAAI,MAAM,+BAA+B;AACvE,cAAM,IAAI,MAAM;AAAA;AAGlB,aAAO,OAAO,KAAK,IAAI,UAAU,0BAA0B;AAAA;AAQ7D,0BAAsB,QAAQ,SAAS;AACrC,UAAI,QACF,OAAO,WAAW,YAAY,oBAAoB,KAAK,UACnD,SACA,OAAO,UAAU,cAAc;AAErC,aAAO,wBAAwB;AAAA;AAOjC,kCAA8B,QAAQ;AACpC,UAAI,IAAI,OAAO,WAAW,IACxB,IAAI,OAAO,WAAW,IACtB,IAAI,OAAO,WAAW,IACtB,IAAI,OAAO,WAAW;AAExB,aAAQ,KAAK,KAAK,IAAM,KAAK,KAAO,KAAK,QAAS;AAAA;AAUpD,qCAAiC,MAAM;AACrC,UAAI,SAAS,KAAK,QAAQ,OAAO;AAEjC,UAAI,WAAW,IAAI;AACjB,cAAM,IAAI,MAAM;AAAA;AAGlB,UAAI,WAAW;AAKf,aAAO,SAAS,KAAK,SAAS,GAAG;AAC/B,YAAI,aAAa;AAEjB,iBAAS,KAAK,UAAU,QAAQ,SAAS;AACzC,kBAAU;AAEV,sBAAc,qBAAqB,KAAK,UAAU,QAAQ,SAAS;AACnE,kBAAU;AAEV,gBAAQ;AAAA,eACD;AACH,mBAAO;AAAA,cACL,OAAO,KAAK,UAAU,QAAQ,SAAS;AAAA,cACvC;AAAA;AAAA,eAGC;AACH,uBAAW;AAIX;AAAA;AAGJ,kBAAU;AAEV,YAAK,eAAc,OAAU,GAAG;AAC9B;AAAA;AAAA;AAKJ,YAAM,IAAI,MACR;AAAA;AAKJ,yBAAqB,OAAO;AAC1B,WAAK,QAAQ;AAAA;AAGf,yBAAqB,OAAO;AAC1B,WAAK,QAAQ;AAAA;AAaf,uBAAmB,QAAQ,kBAAkB,MAAM;AAEjD,UAAI,MAAM,QAAQ,OAAO;AACvB,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,oBAAU,QAAQ,kBAAkB,KAAK;AAAA;AAAA,iBAGlC,OAAO,SAAS,UAAU;AACnC,eAAO,YAAY;AAAA,iBACV,gBAAgB,YAAY;AACrC,eAAO,WAAW;AAAA,iBACT,KAAK,IAAI;AAElB,aAAK,SAAS,OAAO,MAAM;AAE3B,eAAO,mBAAmB,KAAK;AAI/B,YAAI,MAAM,QAAQ,KAAK,OAAO;AAG5B,cAAI,SAAS,WAAW;AAExB,cAAI,KAAK,SAAS,IAAI;AAEpB,mBAAO,UAAU;AAAA,iBACZ;AACL,sBAAU,OAAO;AAMjB,mBAAO,WAAW,CAAC,GAAG,GAAG,GAAG;AAAA;AAG9B,sBAAY,OAAO;AAEnB,eAAK,aAAa,YAAY;AAC9B,oBAAU,QAAQ,kBAAkB,KAAK;AAEzC,cAAI,KAAK,SAAS,IAAI;AACpB,sBAAU,OAAO;AAEjB,iBAAK,OAAO,UAAU;AAEtB,mBAAO,KAAK;AACZ,mBAAO,qBAAqB,KAAK,MAAM;AAEvC,mBAAO,KAAK;AAAA;AAAA,mBAEL,OAAO,KAAK,SAAS,UAAU;AACxC,iBAAO,gBAAgB,KAAK,KAAK;AACjC,eAAK,aAAa,OAAO,MAAM;AAC/B,iBAAO,YAAY,KAAK;AAAA,mBACf,OAAO,KAAK,SAAS,UAAU;AAExC,cAAI,CAAC,KAAK,MAAM;AACd,iBAAK,OAAO,OAAO,mBAAmB,KAAK;AAAA;AAG7C,iBAAO,gBAAgB,KAAK;AAC5B,eAAK,aAAa,OAAO,MAAM;AAC/B,iBAAO,mBAAmB,KAAK,MAAM,KAAK;AAAA,mBACjC,KAAK,gBAAgB,aAAa;AAC3C,iBAAO,gBAAgB;AACvB,eAAK,aAAa,OAAO,MAAM;AAC/B,iBAAO,cAAc,KAAK,KAAK;AAAA,mBACtB,KAAK,gBAAgB,aAAa;AAC3C,iBAAO,gBAAgB;AACvB,eAAK,aAAa,OAAO,MAAM;AAC/B,iBAAO,aAAa,KAAK,KAAK;AAAA,mBACrB,KAAK,gBAAgB,YAAY;AAC1C,iBAAO,gBAAgB,KAAK,KAAK;AACjC,eAAK,aAAa,OAAO,MAAM;AAC/B,iBAAO,WAAW,KAAK;AAAA,eAClB;AACL,gBAAM,IAAI,MAAM,uBAAuB,OAAO,KAAK;AAAA;AAAA,aAEhD;AACL,cAAM,IAAI,MAAM,uBAAuB,OAAO,KAAK;AAAA;AAAA;AA0BvD,QAAI,aAAa,SAAU,uBAAuB,YAAY;AAC5D,aAAO,SAAU,SAAS;AACxB,YAAI,4BAA4B,KAC9B,uBAAuB,GACvB,gBAAgB,OAChB,aAAa,GACb,cAAc,GAId,cAAc,MAId,qBAAqB,MAIrB,kBAAkB,MAKlB,qBAAqB,IACrB,mBAAmB,GACnB,kBAAkB,GAClB,iBAAiB;AAAA,UACf,SAAS;AAAA,UAET,aAAa;AAAA,UACb,cAAc;AAAA,UAGd,YAAY;AAAA,UACZ,IAAI;AAAA,UAGJ,eAAe;AAAA,UACf,WAAW;AAAA,WAEb,aAAa;AAAA,UACX,MAAM;AAAA,YACJ,IAAI,IAAI,WAAW,CAAC,IAAM,IAAM,KAAM;AAAA,YACtC,cAAc;AAAA;AAAA,UAEhB,aAAa;AAAA,YACX,IAAI,IAAI,WAAW,CAAC,IAAM,IAAM,KAAM;AAAA,YACtC,cAAc;AAAA;AAAA,UAEhB,QAAQ;AAAA,YACN,IAAI,IAAI,WAAW,CAAC,IAAM,IAAM,KAAM;AAAA,YACtC,cAAc;AAAA;AAAA,WAGlB,aACA,kBAAkB;AAAA,UAChB,IAAI;AAAA,UACJ,MAAM,IAAI,YAAY;AAAA,WAExB,UACA,OAAO,IACP,aAAa,IAAI,WAAW,QAAQ,cAAc,QAAQ;AAE5D,6CAAqC,YAAY;AAC/C,iBAAO,aAAa,YAAY;AAAA;AAUlC,8CAAsC,QAAQ;AAC5C,cACE,gBAAgB,QAChB,YAAY,UAAU,OAAO,SAC7B,YAAY,WAAW,OAAO,QAC9B;AACA,0BAAc,SAAS,cAAc;AACrC,wBAAY,QAAQ,OAAO;AAC3B,wBAAY,SAAS,OAAO;AAE5B,iCAAqB,YAAY,WAAW;AAC5C,8BAAkB,mBAAmB,gBACnC,YAAY,OACZ,YAAY;AAAA;AAIhB,cAAI,gBAAgB,OAAO,WAAW,OACpC,aAAa,cAAc,aACzB,GACA,GACA,OAAO,OACP,OAAO,QACP,MACF,WAAW,gBAAgB,MAC3B,YAAY,GACZ,SAAS,OAAO,QAAQ,OAAO,SAAS;AAE1C,mBACM,YAAY,GAChB,YAAY,QACZ,aAAa,GACb;AACA,gBAAI,QAAQ,WAAW;AAGvB,qBAAS,eAAe;AACxB,qBAAS,eAAe;AACxB,qBAAS,eAAe;AACxB,qBAAS,eAAe;AAAA;AAG1B,6BAAmB,aAAa,iBAAiB,GAAG;AAEpD,iBAAO;AAAA;AAST,kCAA0B;AACxB,cAAI,2BAA2B;AAAA,YAC3B,IAAI;AAAA,YACJ,MAAM;AAAA,YACN,MAAM;AAAA,aAER,SAAS;AAAA,YACP,IAAI;AAAA,YACJ,MAAM;AAAA;AAGV,mBAAS,QAAQ,YAAY;AAC3B,gBAAI,YAAY,WAAW;AAE3B,sBAAU,eAAe,OAAO,OAAO;AAEvC,mBAAO,KAAK,KAAK;AAAA,cACf,IAAI;AAAA,cACJ,MAAM;AAAA,gBACJ;AAAA,kBACE,IAAI;AAAA,kBACJ,MAAM,UAAU;AAAA;AAAA,gBAElB,UAAU;AAAA;AAAA;AAAA;AAKhB,iBAAO;AAAA;AAMT,+BAAuB;AACrB,qBAAW;AAEX,cAAI,aAAa;AAAA,YACb,IAAI;AAAA,YACJ,MAAM;AAAA,cACJ;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA;AAAA,aAIZ,cAAc;AAAA,YACZ,IAAI;AAAA,YACJ,MAAM;AAAA,cACJ;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA;AAAA,aAGJ,kBAAkB;AAAA,YAChB;AAAA,cACE,IAAI;AAAA,cACJ,MAAM;AAAA;AAAA,YAER;AAAA,cACE,IAAI;AAAA,cACJ,MAAM;AAAA;AAAA;AAIZ,cAAI,QAAQ,aAAa;AACvB,4BAAgB,KAAK;AAAA,cACnB,IAAI;AAAA,cACJ,MAAM;AAAA;AAAA;AAIV,cAAI,SAAS;AAAA,YACX,IAAI;AAAA,YACJ,MAAM;AAAA,cACJ;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA,kBACJ;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAOhB,wBAAc;AAAA,YACZ,IAAI;AAAA,YACJ,MAAM;AAAA,YACN,MAAM,CAAC,UAAU,aAAa;AAAA;AAGhC,cAAI,eAAe,IAAI,sBAAsB;AAE7C,oBAAU,cAAc,WAAW,KAAK,CAAC,YAAY;AACrD,qBAAW,MAAM,aAAa;AAG9B,qBAAW,YAAY,aAAa,OAAO,4BACzC,YAAY;AAEd,qBAAW,OAAO,aAAa,OAAO,4BACpC,OAAO;AAGT,0BAAgB;AAAA;AAUlB,wDAAgD,UAAU;AACxD,cAAI,OACF,gBACA,eAAe,IAAI,sBAAsB,IAAI,IAAI;AAInD,cAAI,CAAE,UAAS,cAAc,KAAK,SAAS,cAAc,MAAM;AAC7D,kBAAM,IAAI,MAAM;AAAA;AAGlB,uBAAa,gBAAgB,SAAS;AACtC,uBAAa,WAAW,SAAS;AACjC,uBAAa,UAAU;AAEvB,kBAAQ;AAAA,YACN,IAAI;AAAA,YACJ,MAAM,CAAC,aAAa,kBAAkB,SAAS;AAAA;AAGjD,2BAAiB;AAAA,YACf,IAAI;AAAA,YACJ,MAAM;AAAA,cACJ;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA,kBACJ;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAOzB,iBAAO;AAAA,YACL,IAAI;AAAA,YACJ,MAAM,CAAC,OAAO;AAAA;AAAA;AAWlB,8CAAsC,UAAU;AAC9C,cAAI,eAAe,IAAI,sBAAsB,IAAI,IAAI;AAErD,cAAI,CAAE,UAAS,cAAc,KAAK,SAAS,cAAc,MAAM;AAC7D,kBAAM,IAAI,MAAM;AAAA;AAGlB,uBAAa,gBAAgB,SAAS;AACtC,uBAAa,WAAW,SAAS;AAGjC,uBAAa,UACX,KAAK;AAGP,iBAAO;AAAA,YACL,IAAI;AAAA,YACJ,MAAM,CAAC,aAAa,kBAAkB,SAAS;AAAA;AAAA;AASnD,4CAAoC,UAAU;AAC5C,cAAI,SAAS,OAAO;AAClB,mBAAO,uCAAuC;AAAA;AAGhD,iBAAO,6BAA6B;AAAA;AAUtC,+BAAuB,SAAS;AAC9B,iBAAO;AAAA,YACL,IAAI;AAAA,YACJ,MAAM;AAAA,cACJ;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM,KAAK,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAMjC,6BAAqB,YAAY,aAAa,mBAAmB;AAC/D,eAAK,KAAK;AAAA,YACR,IAAI;AAAA,YACJ,MAAM;AAAA,cACJ;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA;AAAA,cAER;AAAA,gBACE,IAAI;AAAA,gBACJ,MAAM;AAAA,kBACJ;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM;AAAA;AAAA,kBAER;AAAA,oBACE,IAAI;AAAA,oBACJ,MAAM,4BAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAY9C,6BAAqB;AACnB,cAAI,OAAO;AAAA,YACP,IAAI;AAAA,YACJ,MAAM;AAAA,aAER,aAAa,IAAI,sBAAsB,KAAK,KAAK,SAAS;AAE5D,oBAAU,YAAY,WAAW,KAAK;AACtC,qBAAW,MAAM,WAAW;AAG5B,qBAAW,KAAK,aAAa,OAAO,4BAClC,KAAK;AAAA;AAOT,2CAAmC;AACjC,cAAI,mBAAmB,WAAW,GAAG;AACnC;AAAA;AAIF,cAAI,eAAe;AAEnB,mBAAS,IAAI,GAAG,IAAI,mBAAmB,QAAQ,KAAK;AAClD,4BACE,mBAAmB,GAAG,MAAM,SAC3B,oBAAmB,GAAG,QACnB,mBAAmB,GAAG,MAAM,SAC5B;AAAA;AAGR,cAAI,SAAS,IAAI,sBACb,eAAe,mBAAmB,SAAS,KAE7C,UAAU,cAAc;AAAA,YACtB,UAAU,KAAK,MAAM;AAAA;AAGzB,mBAAS,IAAI,GAAG,IAAI,mBAAmB,QAAQ,KAAK;AAClD,oBAAQ,KAAK,KAAK,2BAA2B,mBAAmB;AAAA;AAGlE,oBAAU,QAAQ,WAAW,KAAK;AAClC,qBAAW,MAAM,OAAO;AAExB,sBACE,sBACA,KAAK,MAAM,mBACX,QAAQ;AAGV,+BAAqB;AACrB,8BAAoB;AACpB,4BAAkB;AAAA;AAGpB,mCAA2B;AAEzB,cAAI,CAAC,QAAQ,eAAe;AAC1B,gBAAI,QAAQ,WAAW;AACrB,sBAAQ,gBAAgB,MAAO,QAAQ;AAAA,mBAClC;AACL,oBAAM,IAAI,MACR;AAAA;AAAA;AAMN,kBAAQ,UAAU,KAAK,IAAI,KAAK,IAAI,QAAQ,SAAS,UAAU;AAE/D,cAAI,QAAQ,iBAAiB,QAAW;AACtC,oBAAQ,eAAe,QAAQ;AAAA,iBAC1B;AACL,oBAAQ,eAAe,KAAK,IAC1B,KAAK,IAAI,QAAQ,cAAc,UAC/B;AAAA;AAAA;AASN,mCAA2B,OAAO;AAChC,gBAAM,cAAc;AAGpB,gBAAM,WAAW,KAAK,MAAM;AAE5B,6BAAmB,KAAK;AAExB,6BAAmB,MAAM;AAEzB,cAAI,mBAAmB,2BAA2B;AAChD;AAAA;AAAA;AASJ,mCAA2B;AACzB,cAAI,iBAAiB,IAAI,sBAAsB,SAAS,OACtD,SAAS,WAAW;AAGtB,oBAAU,gBAAgB,SAAS,YAAY,SAAS;AAGxD,qBAAW,KAAK,SAAS;AACzB,qBAAW,MAAM,eAAe;AAEhC,qBAAW,KAAK;AAAA;AAMlB,mCAA2B;AACzB,cAAI,SAAS,IAAI,sBAAsB,IACrC,SAAS,WAAW;AAGtB,iBAAO,cAAc;AAGrB,qBAAW,KAAK,gBAAgB;AAChC,qBAAW,MAAM,OAAO;AAExB,qBAAW,KAAK;AAAA;AAwBlB,aAAK,WAAW,SAAU,OAAO,OAAO,uBAAuB;AAC7D,cAAI,CAAC,eAAe;AAClB,yBAAa,MAAM,SAAS;AAC5B,0BAAc,MAAM,UAAU;AAE9B;AAAA;AAGF,cAAI,WAAW,wBACX,aAAa,OAAO,QAAQ,WAE9B,eACA,aAAa;AAEf,cAAI,uBAAuB;AACzB,4BAAgB;AAAA,qBACP,OAAO,SAAS,UAAU;AACnC,4BAAgB;AAAA,iBACX;AACL,4BAAgB,QAAQ;AAAA;AAG1B,cAAI,QAAQ,aAAa;AACvB,gBAAI,iBAAiB,qBAAqB,OAAO,UAAU,UAAU;AACnE,2BAAa;AAAA,uBACJ,SAAS,UAAU;AAC5B,2BAAa,6BAA6B;AAAA;AAAA;AAI9C,4BAAkB;AAAA,YAChB,OAAO,SAAS;AAAA,YAChB,UAAU;AAAA,YACV,OAAO,aACH,wBACE,aAAa,YAAY,QAAQ,eACjC,QACF;AAAA;AAAA;AAUR,aAAK,WAAW,WAAY;AAC1B,kBAAQ,IAAI,yBAAyB,WAAW;AAEhD,cAAI,CAAC,eAAe;AAClB;AAAA;AAGF;AAEA;AACA;AACA;AAEA,iBAAO,WAAW,SAAS;AAAA;AAG7B,aAAK,iBAAiB,WAAY;AAChC,iBAAO,WAAW;AAAA;AAGpB,kBAAU,OAAO,gBAAgB,WAAW;AAC5C;AAAA;AAAA;AAIJ,WAAO,aAAa,WAClB,OAAO,uBACP,OAAO;AAAA;;;ACn2CT,EAAC,YAAY;AACb,WAAO,WAAW,SAAU,MAAM,aAAa,aAAa;AAC1D,UAAI,OAAO,QACT,cAAc,4BACd,WAAW,eAAe,aAC1B,UAAU,MACV,MAAM,CAAC,eAAe,CAAC,eAAe,SACtC,SAAS,SAAS,cAAc,MAChC,WAAW,SAAU,GAAG;AAAE,eAAO,OAAO;AAAA,SACxC,SAAU,KAAK,QAAQ,KAAK,WAAW,KAAK,cAAc,UAC1D,WAAW,eAAe,YAC1B,MACA;AACF,eAAS,OAAO,OAAO,OAAO,KAAK,QAAQ;AAE3C,UAAI,OAAO,UAAU,QAAQ;AAC3B,kBAAU,CAAC,SAAS;AACpB,mBAAW,QAAQ;AACnB,kBAAU,QAAQ;AAAA;AAIpB,UAAI,OAAO,IAAI,SAAS,MAAM;AAC5B,mBAAW,IAAI,MAAM,KAAK,MAAM,MAAM,KAAK;AAC3C,eAAO,OAAO;AACd,YAAI,OAAO,KAAK,QAAQ,SAAS,IAAI;AACnC,cAAI,OAAO,IAAI;AACf,eAAK,KAAK,OAAO,KAAK;AACtB,eAAK,eAAe;AACpB,eAAK,SAAS,SAAU,GAAG;AACzB,qBAAS,EAAE,OAAO,UAAU,UAAU;AAAA;AAExC,qBAAW,WAAY;AAAE,iBAAK;AAAA,aAAW;AACzC,iBAAO;AAAA;AAAA;AAMX,UAAI,iCAAiC,KAAK,UAAU;AAElD,YAAI,QAAQ,SAAU,OAAO,OAAO,SAAU,WAAW,UAAU;AACjE,oBAAU,cAAc;AACxB,qBAAW,QAAQ,QAAQ;AAAA,eACtB;AACL,iBAAO,UAAU,aACf,UAAU,WAAW,cAAc,UAAU,YAC7C,MAAM;AAAA;AAAA,aAGL;AACL,YAAI,gBAAgB,KAAK,UAAU;AACjC,cAAI,IAAI,GAAG,YAAY,IAAI,WAAW,QAAQ,SAAS,KAAK,UAAU;AACtE,eAAK,GAAG,IAAI,IAAI,EAAE;AAAG,sBAAU,KAAK,QAAQ,WAAW;AACvD,oBAAU,IAAI,OAAO,CAAC,YAAY,EAAE,MAAM;AAAA;AAAA;AAG9C,aAAO,mBAAmB,SACxB,UACA,IAAI,OAAO,CAAC,UAAU,EAAE,MAAM;AAGhC,6BAAuB,QAAQ;AAC7B,YAAI,QAAQ,OAAO,MAAM,UACvB,OAAO,MAAM,IACb,eAAe,OAAO,QAAQ,aAAa,IAAI,IAAI,GACnD,UAAU,MAAM,iBAAiB,WAAW,OAAO,oBACnD,UAAU,QAAQ,MAAM,QACxB,MAAK,QAAQ,QACb,KAAI,GACJ,QAAQ,IAAI,WAAW;AAEzB,aAAK,IAAG,KAAI,KAAI,EAAE;AAAG,gBAAM,MAAK,QAAQ,WAAW;AAEnD,eAAO,IAAI,OAAO,CAAC,QAAQ,EAAE;AAAA;AAG/B,qBAAe,MAAK,SAAS;AAE3B,YAAI,cAAc,QAAQ;AACxB,iBAAO,OAAO;AACd,iBAAO,aAAa,YAAY;AAChC,iBAAO,YAAY;AACnB,iBAAO,YAAY;AACnB,iBAAO,MAAM,UAAU;AACvB,iBAAO,iBAAiB,SAAS,SAAU,GAAG;AAC5C,cAAE;AACF,iBAAK,oBAAoB,SAAS,UAAU;AAAA;AAE9C,mBAAS,KAAK,YAAY;AAC1B,qBAAW,WAAY;AACrB,mBAAO;AACP,qBAAS,KAAK,YAAY;AAC1B,gBAAI,YAAY,MAAM;AAAE,yBAAW,WAAY;AAAE,qBAAK,IAAI,gBAAgB,OAAO;AAAA,iBAAU;AAAA;AAAA,aAC1F;AACH,iBAAO;AAAA;AAIT,YAAI,gDAAgD,KAAK,UAAU,YAAY;AAC7E,cAAI,SAAS,KAAK;AAAM,mBAAM,UAAU,KAAI,QAAQ,uBAAuB;AAC3E,cAAI,CAAC,OAAO,KAAK,OAAM;AACrB,gBAAI,QAAQ,iGAAiG;AAAE,uBAAS,OAAO;AAAA;AAAA;AAEjI,iBAAO;AAAA;AAIT,YAAI,IAAI,SAAS,cAAc;AAC/B,iBAAS,KAAK,YAAY;AAE1B,YAAI,CAAC,WAAW,SAAS,KAAK,OAAM;AAClC,iBAAM,UAAU,KAAI,QAAQ,uBAAuB;AAAA;AAErD,UAAE,MAAM;AACR,mBAAW,WAAY;AAAE,mBAAS,KAAK,YAAY;AAAA,WAAO;AAAA;AAO5D,UAAI,UAAU,YAAY;AACxB,eAAO,UAAU,WAAW,MAAM;AAAA;AAGpC,UAAI,KAAK,KAAK;AACZ,cAAM,KAAK,IAAI,gBAAgB,OAAO;AAAA,aACjC;AAEL,YAAI,OAAO,SAAS,YAAY,KAAK,gBAAgB,UAAU;AAC7D,cAAI;AACF,mBAAO,MAAM,UAAU,WAAW,aAAa,KAAK,KAAK;AAAA,mBAClD,GAAP;AACA,mBAAO,MAAM,UAAU,WAAW,MAAM,mBAAmB;AAAA;AAAA;AAK/D,iBAAS,IAAI;AACb,eAAO,SAAS,SAAU,GAAG;AAC3B,gBAAM,KAAK;AAAA;AAEb,eAAO,cAAc;AAAA;AAEvB,aAAO;AAAA;AAAA;;;AClIT,EAAC,YAAY;AAEb;AAEA,QAAI,MAAM,OAAO;AACjB,QAAI,YAAW,OAAO;AACtB,QAAI,MAAM,OAAO;AACjB,QAAI,aAAa,OAAO;AASxB,QAAI,CAAE,SAAQ,SAAS;AACrB,aAAO,KAAK,WAAY;AAAA;AAAA;AAG1B,QAAI,CAAC,kBAAkB,UAAU,QAAQ;AACvC,aAAO,eAAe,kBAAkB,WAAW,UAAU;AAAA,QAC3D,OAAO,SAAU,UAAU,MAAM,SAAS;AAExC,cAAI,SAAS,KAAK,KAAK,UAAU,MAAM,SAAS,MAAM,KAAK,KACzD,MAAM,OAAO,QACb,MAAM,IAAI,WAAW;AAEvB,mBAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,gBAAI,KAAK,OAAO,WAAW;AAAA;AAG7B,mBAAS,IAAI,KAAK,CAAC,MAAM,EAAE,MAAM,QAAQ;AAAA;AAAA;AAAA;AAK/C,AAWA,IAAC,YAAY;AAEX,UAAI,iBAAiB,UAAU,OAAO;AACpC,eAAO,cAAc;AAAA;AAGvB,UAAI,SAAS,OAAO,eAAe,OAAO;AACxC,YAAI,YAAY,KAAK;AAErB,eAAO,YAAY,MAAM,eAAe;AACtC,iBAAO,KAAK,QAAQ;AAAA;AAAA;AAAA;AAK1B,iBAAa,GAAG;AACd,aAAO,OAAO,YAAY,GAAG,MAAM;AAAA;AAIrC,QAAI,cAAc,OAAO,KAAK;AAE9B,oBAAgB;AACd,oBAAc;AACZ,eAAO,KAAK,MAAO,KAAI,KAAK,YAAY,OAAS,SAAS,IAAI,UAAU;AAAA;AAE1E,aAAO,OAAO,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,OAAO;AAAA;AAGlF,4BAAwB,UAAU;AAEhC,UAAI,YAAY;AAEhB,WAAK,WAAW;AAEhB,WAAK,KAAK,SAAU,OAAO,SAAS;AAElC,kBAAU,SAAS;AAAA;AAIrB,WAAK,OAAO,SAAU,OAAO;AAE3B,YAAI,UAAU,UAAU;AACxB,YAAI,SAAS;AAEX,kBAAQ,MAAM,MAAM,MAAM,UAAU,MAAM,KAAK,WAAW;AAAA;AAAA;AAM9D,WAAK,WAAW,SAAS,QAAQ;AACjC,WAAK,YAAY;AACjB,WAAK,WAAW;AAAA;AAIlB,mBAAe,UAAU,QAAQ,WAAY;AAAA;AAC7C,mBAAe,UAAU,OAAO,WAAY;AAAA;AAC5C,mBAAe,UAAU,MAAM,WAAY;AAAA;AAC3C,mBAAe,UAAU,OAAO,WAAY;AAAA;AAC5C,mBAAe,UAAU,UAAU,WAAY;AAAA;AAC/C,mBAAe,UAAU,gBAAgB,WAAY;AAAE,aAAO;AAAA;AAC9D,mBAAe,UAAU,OAAO,WAAY;AAAE,cAAQ,IAAI;AAAA;AAsG1D,2BAAuB,UAAU;AAC/B,UAAI,SAAS,SAAS,cAAc;AAEpC,qBAAe,KAAK,MAAM;AAE1B,WAAK,UAAW,SAAS,UAAU,OAAQ;AAE3C,WAAK,YAAY;AACjB,WAAK,WAAW;AAChB,WAAK,eAAe,KAAK;AACzB,WAAK,YAAY,SAAS;AAE1B,WAAK,SAAS;AACd,WAAK,OAAO;AAEZ,WAAK,cAAc,IAAI,WAAW;AAAA,QAChC,SAAS,KAAK;AAAA,QACd,YAAY;AAAA,QACZ,IAAI;AAAA,QACJ,WAAW,KAAK;AAAA;AAAA;AAKpB,kBAAc,YAAY,OAAO,OAAO,eAAe;AAEvD,kBAAc,UAAU,QAAQ,SAAU,QAAQ;AAEhD,WAAK;AAAA;AAIP,kBAAc,UAAU,MAAM,SAAU,QAAQ;AAE9C,WAAK,YAAY,SAAS;AAE1B,UAAI,KAAK,SAAS,eAAe,KAAM,KAAK,SAAS,KAAK,SAAS,aAAc,KAAK,SAAS,cAAc;AAC3G,aAAK,KAAK,SAAU,MAAM;AACxB,eAAK,WAAW,KAAK,eAAe,WAAW,IAAI,KAAK;AACxD,oBAAS,MAAM,KAAK,WAAW,KAAK,WAAW,KAAK;AACpD,eAAK;AACL,eAAK;AACL,eAAK,WAAW,KAAK,eAAe,WAAW,IAAI,KAAK;AACxD,eAAK;AAAA,UACL,KAAK;AAAA,aACF;AACL,aAAK;AACL,aAAK;AAAA;AAAA;AAKT,kBAAc,UAAU,OAAO,SAAU,UAAU;AAEjD,WAAK,YAAY,WAAW,KAAK;AAAA;AAInC,kBAAc,UAAU,UAAU,SAAU,QAAQ;AAElD,WAAK,SAAS;AACd,WAAK,cAAc,IAAI,WAAW;AAAA,QAChC,SAAS,KAAK;AAAA,QACd,YAAY;AAAA,QACZ,IAAI;AAAA,QACJ,WAAW,KAAK;AAAA;AAAA;AAKpB,mCAA+B,UAAU;AAEvC,qBAAe,KAAK,MAAM;AAE1B,eAAS,UAAW,SAAS,UAAU,OAAQ;AAE/C,WAAK,UAAU,IAAI,aAAa,MAAM;AACtC,WAAK,QAAQ,GAAG,WAAW,WAAY;AACrC,aAAK,KAAK;AAAA,QACV,KAAK;AACP,WAAK,QAAQ,GAAG,YAAY,SAAU,KAAK,MAAM;AAC/C,YAAI,KAAK,KAAK;AACd,YAAI,IAAI;AACN,eAAK,WAAW;AAChB,aAAG,KAAK;AAAA;AAAA,QAEV,KAAK;AACP,WAAK,QAAQ,GAAG,YAAY,SAAU,UAAU;AAC9C,YAAI,KAAK,SAAS,YAAY;AAC5B,eAAK,SAAS,WAAW;AAAA;AAAA,QAE3B,KAAK;AACP,WAAK,QAAQ,GAAG,SAAS,SAAU,MAAM;AACvC,cAAM,KAAK,UAAU,MAAM,MAAM;AAAA,QACjC,KAAK;AAAA;AAIT,0BAAsB,YAAY,OAAO,OAAO,eAAe;AAE/D,0BAAsB,UAAU,QAAQ,WAAY;AAElD,WAAK,QAAQ,MAAM,KAAK;AAAA;AAI1B,0BAAsB,UAAU,MAAM,SAAU,QAAQ;AAEtD,WAAK,QAAQ,IAAI;AAAA;AAInB,0BAAsB,UAAU,OAAO,SAAU,UAAU;AAEzD,WAAK,WAAW;AAChB,WAAK,QAAQ;AAAA;AAIf,0BAAsB,UAAU,gBAAgB,WAAY;AAC1D,aAAO,KAAK,QAAQ;AAAA;AAOtB,6BAAyB,UAAU;AAEjC,qBAAe,KAAK,MAAM;AAE1B,WAAK,YAAY,KAAK,SAAS;AAC/B,WAAK,OAAO;AACZ,WAAK,YAAY;AACjB,WAAK,SAAS;AACd,WAAK,gBAAgB;AACrB,WAAK,SAAS;AAAA;AAIhB,oBAAgB,YAAY,OAAO,OAAO,eAAe;AAEzD,oBAAgB,UAAU,MAAM,SAAU,QAAQ;AAEhD,UAAI,CAAC,KAAK,QAAQ;AAChB,aAAK,SAAS,OAAO,cAAc,KAAK;AACxC,aAAK,gBAAgB,IAAI,cAAc,KAAK;AAC5C,aAAK,cAAc;AAEnB,aAAK,cAAc,kBAAkB,SAAU,GAAG;AAChD,eAAK,OAAO,KAAK,EAAE;AAAA,UACnB,KAAK;AAAA;AAGT,WAAK;AAAA;AAIP,oBAAgB,UAAU,OAAO,SAAU,UAAU;AAEnD,WAAK,cAAc,SAAS,SAAU,GAAG;AACvC,YAAI,OAAO,IAAI,KAAK,KAAK,QAAQ,EAAE,QAAQ;AAC3C,aAAK,SAAS;AACd,iBAAS;AAAA,QAET,KAAK;AAEP,WAAK,cAAc;AAAA;AAkErB,0BAAsB,UAAU;AAE9B,qBAAe,KAAK,MAAM;AAE1B,eAAS,UAAU,KAAO,UAAS,UAAU,KAAK,OAAQ;AAC1D,eAAS,UAAU,SAAS,WAAW;AAEvC,WAAK,YAAY;AACjB,WAAK,WAAW;AAEhB,WAAK,SAAS,SAAS,cAAc;AACrC,WAAK,MAAM,KAAK,OAAO,WAAW;AAClC,WAAK,UAAU;AAEf,WAAK,UAAU,IAAI,IAAI;AAAA,QACrB,SAAS,SAAS;AAAA,QAClB,SAAS,SAAS;AAAA,QAClB,cAAc,SAAS,cAAc;AAAA;AAGvC,WAAK,QAAQ,GAAG,YAAY,SAAU,UAAU;AAC9C,YAAI,KAAK,SAAS,YAAY;AAC5B,eAAK,SAAS,WAAW;AAAA;AAAA,QAE3B,KAAK;AAEP,WAAK,QAAQ,GAAG,YAAY,SAAU,MAAM;AAC1C,YAAI,KAAK,KAAK;AACd,YAAI,IAAI;AACN,eAAK,WAAW;AAChB,aAAG;AAAA;AAAA,QAEL,KAAK;AAAA;AAIT,iBAAa,YAAY,OAAO,OAAO,eAAe;AAEtD,iBAAa,UAAU,MAAM,SAAU,QAAQ;AAE7C,UAAI,CAAC,KAAK,SAAS;AACjB,aAAK,QAAQ,UAAU,SAAS,OAAO;AACvC,aAAK,QAAQ,UAAU,UAAU,OAAO;AACxC,aAAK,UAAU;AAAA;AAGjB,WAAK,OAAO,QAAQ,OAAO;AAC3B,WAAK,OAAO,SAAS,OAAO;AAC5B,WAAK,IAAI,UAAU,QAAQ,GAAG;AAE9B,WAAK,QAAQ,SAAS,KAAK,KAAK,EAAE,MAAM,MAAM,OAAO,KAAK,SAAS;AACnE,WAAK;AAAA;AAUP,iBAAa,UAAU,OAAO,SAAU,UAAU;AAEhD,WAAK,WAAW;AAEhB,WAAK,QAAQ;AAAA;AAIf,sBAAkB,UAAU;AAE1B,UAAI,YAAY,YAAY,IAC1B,QAAQ,IAAI,QACZ,UACA,UACA,OACA,YACA,kBACA,uBACA,OACA,UACA,YAAY,IACZ,aAAa,IACb,cAAc,GACd,0BAA0B,GAC1B,aAAa,MACb,kCAAkC,IAClC,aAAa,OACb,YAAY;AAEd,gBAAU,YAAY,UAAU,aAAa;AAC7C,gBAAU,mBAAmB,IAAK,WAAU,oBAAoB;AAChE,iBAAW,UAAU,WAAW;AAChC,iBAAW,UAAU,WAAW;AAChC,gBAAU,OAAO,MAAS,UAAU;AACpC,gBAAU,YAAY,UAAU,aAAa;AAC7C,gBAAU,aAAa,UAAU,cAAc;AAC/C,gBAAU,YAAY,UAAU,aAAa;AAE7C,UAAI,eAAe,SAAS,cAAc;AAC1C,mBAAa,MAAM,WAAW;AAC9B,mBAAa,MAAM,OAAO,aAAa,MAAM,MAAM;AACnD,mBAAa,MAAM,kBAAkB;AACrC,mBAAa,MAAM,aAAa;AAChC,mBAAa,MAAM,WAAW;AAC9B,mBAAa,MAAM,UAAU;AAC7B,mBAAa,MAAM,QAAQ;AAC3B,mBAAa,MAAM,SAAS;AAC5B,UAAI,UAAU;AAAS,iBAAS,KAAK,YAAY;AAEjD,UAAI,mBAAmB,SAAS,cAAc;AAC9C,UAAI,gBAAgB,iBAAiB,WAAW;AAChD,UAAI;AACJ,UAAI;AAEJ,WAAK,oBAAoB,UAAU,OAAO;AAE1C,UAAI,YAAY;AAAA,QAEd,MAAM;AAAA,QAIN,sBAAsB;AAAA;AAGxB,UAAI,OAAO,UAAU,UAAU;AAC/B,UAAI,CAAC,MAAM;AACT,cAAM,2DAA2D,OAAO,KAAK,WAAW,KAAK;AAAA;AAE/F,iBAAW,IAAI,KAAK;AACpB,eAAS,OAAO;AAEhB,eAAS,GAAG,WAAW;AACvB,eAAS,GAAG,YAAY;AAExB,UAAI,iBAAiB,UAAU,OAAO;AACpC,eAAO,cAAc;AAAA;AAGvB,WAAK,MAAO,KAAK,OAAO,WAAY;AAClC,eAAO,IAAI,OAAO;AAAA;AAGpB,UAAI,SAAS,OAAO,eAAe,OAAO;AAExC,YAAI,YAAY,KAAK;AAErB,YAAI,YAAY,UAAU,YAAY,OAAO,iBAAiB;AAC5D,sBAAY,YAAY,OAAO;AAAA;AAGjC,eAAO,YAAY,MAAM,eAAe;AACtC,iBAAO,KAAK,QAAQ;AAAA;AAAA;AAIxB,UAAI,iBAAiB,OAAO,YAC1B,kBAAkB,OAAO,aACzB,oBAAoB,OAAO,eAC3B,mBAAmB,OAAO,cAC1B,4BAA4B,OAAO,uBACnC,UAAU,OAAO,KAAK,KACtB,qBAAqB,OAAO,YAAY,KACxC,cAAc,OAAO,KAAK,UAAU;AAGtC,UAAI,QAAQ;AAEZ,uBAAiB;AAEf,aAAK;AAEL,qBAAa,OAAO,KAAK;AACzB,gBAAQ,aAAa,UAAU;AAC/B,gCAAwB,OAAO,YAAY;AAC3C,2BAAmB,wBAAwB,UAAU;AAErD,eAAO,KAAK,UAAU,UAAU,WAAY;AAC1C,iBAAO;AAAA;AAET,eAAO,KAAK,MAAM,WAAY;AAC5B,iBAAO;AAAA;AAGT,eAAO,aAAa,SAAU,UAAU,MAAM;AAC5C,cAAI,IAAI;AAAA,YACN;AAAA,YACA;AAAA,YACA,aAAa,QAAQ;AAAA;AAEvB,oBAAU,KAAK;AACf,eAAK,oBAAoB,EAAE;AAC3B,iBAAO;AAAA;AAET,eAAO,eAAe,SAAU,IAAI;AAClC,mBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,gBAAI,UAAU,MAAM,IAAI;AACtB,wBAAU,OAAO,GAAG;AACpB,mBAAK;AACL;AAAA;AAAA;AAAA;AAIN,eAAO,cAAc,SAAU,UAAU,MAAM;AAC7C,cAAI,IAAI;AAAA,YACN;AAAA,YACA;AAAA,YACA,aAAa,QAAQ;AAAA;AAEvB,qBAAW,KAAK;AAChB,eAAK,qBAAqB,EAAE;AAC5B,iBAAO;AAAA;AAET,eAAO,gBAAgB,SAAU,IAAI;AACnC,eAAK;AACL,iBAAO;AAAA;AAET,eAAO,wBAAwB,SAAU,UAAU;AACjD,0CAAgC,KAAK;AAAA;AAEvC,eAAO,YAAY,MAAM,WAAY;AACnC,iBAAO;AAAA;AAGT,mCAA2B;AACzB,cAAI,CAAC,KAAK,SAAS;AACjB,iBAAK,UAAU;AACf,iBAAK,cAAc,KAAK,eAAe;AACvC,iBAAK;AACL,kBAAM,KAAK;AAAA;AAEb,iBAAO,KAAK,cAAc,UAAU;AAAA;AACrC;AAED,YAAI;AACF,iBAAO,eAAe,iBAAiB,WAAW,eAAe,EAAE,KAAK;AACxE,iBAAO,eAAe,iBAAiB,WAAW,eAAe,EAAE,KAAK;AAAA,iBACjE,KAAP;AACA,eAAK;AAAA;AAAA;AAKT,wBAAkB;AAChB;AACA,iBAAS;AACT,qBAAa;AAAA;AAGf,uBAAiB;AACf,qBAAa;AACb,iBAAS;AACT;AAAA;AAGF,qBAAe,IAAI,GAAG;AACpB,uBAAe,IAAI,GAAG;AAAA;AAGxB,uBAAiB;AAEf,cAAM;AAAA;AAGR,0BAAoB;AAClB,aAAK;AACL,eAAO,aAAa;AACpB,eAAO,cAAc;AACrB,eAAO,gBAAgB;AACvB,eAAO,eAAe;AACtB,eAAO,wBAAwB;AAC/B,eAAO,KAAK,UAAU,UAAU;AAChC,eAAO,KAAK,MAAM;AAClB,eAAO,YAAY,MAAM;AAAA;AAG3B,6BAAuB;AACrB,YAAI,UAAU,cAAc,UAAU;AACtC,YAAK,UAAU,cAAc,eAAe,UAAU,cAAgB,UAAU,aAAa,WAAW,UAAU,WAAY;AAC5H;AACA;AAAA;AAEF,YAAI,IAAI,IAAI,KAAK;AACjB,UAAE,WAAW;AACb,YAAI,UAAU,mBAAmB,GAAG;AAClC,uBAAa,cAAc,cAAc,UAAU,SAAS,QAAQ,cAAc,cAAc,0BAA0B,eAAe,EAAE,cAAc,OAAO,IAAI;AAAA,eAC/J;AACL,uBAAa,cAAc,cAAc,UAAU,SAAS,QAAQ,cAAc,eAAe,EAAE,cAAc,OAAO,IAAI;AAAA;AAAA;AAIhI,2BAAqB,QAAQ;AAE3B,YAAI,iBAAiB,UAAU,OAAO,SAAS,iBAAiB,WAAW,OAAO,QAAQ;AACxF,2BAAiB,QAAQ,OAAO;AAChC,2BAAiB,SAAS,OAAO;AACjC,6BAAmB,IAAI,YAAY,iBAAiB,SAAS,iBAAiB,QAAQ;AACtF,wBAAc,YAAY;AAC1B,wBAAc,SAAS,GAAG,GAAG,iBAAiB,OAAO,iBAAiB;AAAA;AAAA;AAK1E,2BAAqB,QAAQ;AAI3B,sBAAc,UAAU,QAAQ,GAAG;AACnC,oBAAY,cAAc,aAAa,GAAG,GAAG,iBAAiB,OAAO,iBAAiB;AACtF,iBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK,GAAG;AACnD,2BAAiB,MAAM,UAAU,KAAK;AACtC,2BAAiB,IAAI,MAAM,UAAU,KAAK,IAAI;AAC9C,2BAAiB,IAAI,MAAM,UAAU,KAAK,IAAI;AAAA;AAEhD;AAAA;AAIF,4BAAsB;AACpB,YAAI,OAAO,UAAU;AACrB,iBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK,GAAG;AACnD,eAAK,KAAK,iBAAiB,KAAK,IAAI,UAAU;AAC9C,eAAK,IAAI,KAAK,iBAAiB,IAAI,KAAK,IAAI,UAAU;AACtD,eAAK,IAAI,KAAK,iBAAiB,IAAI,KAAK,IAAI,UAAU;AAAA;AAExD,sBAAc,aAAa,WAAW,GAAG;AACzC,iBAAS,IAAI;AACb;AACA,kCAA0B;AAC1B,aAAK,oBAAoB,cAAc,MAAM;AAC7C,iBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK,GAAG;AACnD,2BAAiB,KAAK;AACtB,2BAAiB,IAAI,KAAK;AAC1B,2BAAiB,IAAI,KAAK;AAAA;AAE5B;AAAA;AAIF,wBAAkB,QAAQ;AAExB,YAAI,YAAY;AAEd,cAAI,UAAU,mBAAmB,GAAG;AAElC,wBAAY;AACZ,wBAAY;AAEZ,gBAAI,2BAA2B,MAAK,UAAU,kBAAkB;AAC9D;AAAA,mBACK;AACL;AAAA;AAAA,iBAGG;AACL,qBAAS,IAAI;AACb;AACA,iBAAK,iBAAiB;AAAA;AAAA;AAAA;AAO5B,0BAAoB;AAElB,YAAI,OAAO,MAAO,UAAU;AAC5B,YAAI,KAAM,eAAc,0BAA0B,UAAU,oBAAoB;AAEhF,gBAAQ,aAAa;AACrB,2BAAmB,wBAAwB;AAE3C,cAAM,QAAQ,SAAU,GAAG;AACzB,YAAE,cAAc,KAAK;AAAA;AAGvB;AACA,aAAK,YAAY,cAAc,MAAM;AAErC,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,cAAI,SAAS,UAAU,GAAG,aAAa;AACrC,kBAAM,UAAU,GAAG;AAEnB,sBAAU,OAAO,GAAG;AACpB;AAAA;AAAA;AAIJ,iBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,cAAI,SAAS,WAAW,GAAG,aAAa;AACtC,kBAAM,WAAW,GAAG;AACpB,uBAAW,GAAG,eAAe,WAAW,GAAG;AAE3C;AAAA;AAAA;AAIJ,wCAAgC,QAAQ,SAAU,IAAI;AACpD,gBAAM,IAAI,QAAQ;AAAA;AAEpB,0CAAkC;AAAA;AAIpC,qBAAe,UAAU;AAEvB,YAAI,CAAC,UAAU;AACb,qBAAW,SAAU,MAAM;AACzB,sBAAS,MAAM,SAAS,WAAW,SAAS,WAAW,SAAS;AAChE,mBAAO;AAAA;AAAA;AAGX,iBAAS,KAAK;AAAA;AAIhB,oBAAc,SAAS;AACrB,YAAI;AAAU,kBAAQ,IAAI;AAAA;AAG5B,mBAAa,OAAO,SAAS;AAE3B,kBAAU,SAAS;AAAA;AAIrB,qBAAe,OAAO;AAEpB,YAAI,UAAU,UAAU;AACxB,YAAI,SAAS;AAEX,kBAAQ,MAAM,MAAM,MAAM,UAAU,MAAM,KAAK,WAAW;AAAA;AAAA;AAM9D,yBAAmB,UAAU;AAE3B,cAAM,YAAY;AAAA;AAIpB,aAAO;AAAA,QACL,OAAO;AAAA,QACP,SAAS;AAAA,QACT,MAAM;AAAA,QACN,MAAM;AAAA,QACN,IAAI;AAAA;AAAA;AAIR,WAAO,WAAW;AAAA;;;AC54BpB,uBAA8B;AAAA,IAS5B,cAAc;AACZ,WAAK,SAAS;AACd,WAAK,UAAU;AAAA;AAAA,IAGjB,cAAc,EAAE,YAAY,SAAS,cAAgC;AACnE,WAAK,SAAS;AACd,WAAK,KAAK;AACV,WAAK,YAAY;AACjB,WAAK,SAAS;AACd,WAAK,UAAU,IAAI,OAAO,SAAS;AAAA,QACjC,WAAW;AAAA,QACX,QAAQ;AAAA,QACR,SAAS;AAAA;AAEX,WAAK,aAAa,cAAc,WAAY;AAAA;AAAA;AAAA,IAG9C,eAAe;AACb,UAAI,KAAK,UAAU,CAAC,KAAK,SAAS;AAChC,aAAK,QAAQ;AAAA;AAGf,UAAI,KAAK,QAAQ;AACf,aAAK,QAAQ,QAAQ,KAAK;AAC1B,aAAK;AAEL,YAAI,KAAK,SAAS,KAAK,WAAW;AAChC,eAAK,QAAQ;AACb,eAAK,QAAQ;AACb,eAAK;AAAA;AAAA;AAAA;AAAA;;;AC9Cb,MAAI,QAAQ;AAEV,UAAM,WAAW,IAAI;AACrB,WAAO,gBAAgB,SAAS,cAAc,KAAK;AACnD,WAAO,eAAe,SAAS,aAAa,KAAK;AAAA;",
  "names": []
}
