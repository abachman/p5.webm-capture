{
  "version": 3,
  "sources": ["../node_modules/ccapture.js/src/CCapture.js", "../src/vendor/webm-writer-0.2.0.js", "../src/capturer.ts", "../src/index.ts"],
  "sourcesContent": [";(function() {\r\n\r\n\"use strict\";\r\n\r\n// var isNodeEnviroment = typeof module !== 'undefined' && typeof module.exports !== 'undefined';\r\nvar isNodeEnviroment = false\r\n\r\nvar Tar = window.Tar;\r\nvar download = window.download;\r\nvar GIF = window.GIF;\r\nvar WebMWriter = window.WebMWriter;\r\n\r\nvar objectTypes = {\r\n'function': true,\r\n'object': true\r\n};\r\n\r\nfunction checkGlobal(value) {\r\n    return (value && value.Object === Object) ? value : null;\r\n  }\r\n\r\n/** Built-in method references without a dependency on `root`. */\r\nvar freeParseFloat = parseFloat,\r\n  freeParseInt = parseInt;\r\n\r\n/** Detect free variable `exports`. */\r\nvar freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)\r\n? exports\r\n: undefined;\r\n\r\n/** Detect free variable `module`. */\r\nvar freeModule = (objectTypes[typeof module] && module && !module.nodeType)\r\n? module\r\n: undefined;\r\n\r\n/** Detect the popular CommonJS extension `module.exports`. */\r\nvar moduleExports = (freeModule && freeModule.exports === freeExports)\r\n? freeExports\r\n: undefined;\r\n\r\n/** Detect free variable `global` from Node.js. */\r\nvar freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);\r\n\r\n/** Detect free variable `self`. */\r\nvar freeSelf = checkGlobal(objectTypes[typeof self] && self);\r\n\r\n/** Detect free variable `window`. */\r\nvar freeWindow = checkGlobal(objectTypes[typeof window] && window);\r\n\r\n/** Detect `this` as the global object. */\r\nvar thisGlobal = checkGlobal(objectTypes[typeof this] && this);\r\n\r\n/**\r\n* Used as a reference to the global object.\r\n*\r\n* The `this` value is used if it's the global object to avoid Greasemonkey's\r\n* restricted `window` object, otherwise the `window` object is used.\r\n*/\r\nvar root = freeGlobal ||\r\n((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||\r\n  freeSelf || thisGlobal || Function('return this')();\r\n\r\nif( !('gc' in window ) ) {\r\n\twindow.gc = function(){}\r\n}\r\n\r\nif (!HTMLCanvasElement.prototype.toBlob) {\r\n Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\r\n  value: function (callback, type, quality) {\r\n\r\n    var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),\r\n        len = binStr.length,\r\n        arr = new Uint8Array(len);\r\n\r\n    for (var i=0; i<len; i++ ) {\r\n     arr[i] = binStr.charCodeAt(i);\r\n    }\r\n\r\n    callback( new Blob( [arr], {type: type || 'image/png'} ) );\r\n  }\r\n });\r\n}\r\n\r\n// @license http://opensource.org/licenses/MIT\r\n// copyright Paul Irish 2015\r\n\r\n\r\n// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\r\n//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\r\n// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\r\n\r\n// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\r\n// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\r\n\r\n\r\n(function(){\r\n\r\n  if (\"performance\" in window == false) {\r\n      window.performance = {};\r\n  }\r\n\r\n  Date.now = (Date.now || function () {  // thanks IE8\r\n\t  return new Date().getTime();\r\n  });\r\n\r\n  if (\"now\" in window.performance == false){\r\n\r\n    var nowOffset = Date.now();\r\n\r\n    if (performance.timing && performance.timing.navigationStart){\r\n      nowOffset = performance.timing.navigationStart\r\n    }\r\n\r\n    window.performance.now = function now(){\r\n      return Date.now() - nowOffset;\r\n    }\r\n  }\r\n\r\n})();\r\n\r\n\r\nfunction pad( n ) {\r\n\treturn String(\"0000000\" + n).slice(-7);\r\n}\r\n// https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers\r\n\r\nvar g_startTime = window.Date.now();\r\n\r\nfunction guid() {\r\n\tfunction s4() {\r\n\t\treturn Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\r\n\t}\r\n\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\r\n}\r\n\r\nfunction CCFrameEncoder( settings ) {\r\n\r\n\tvar _handlers = {};\r\n\r\n\tthis.settings = settings;\r\n\r\n\tthis.on = function(event, handler) {\r\n\r\n\t\t_handlers[event] = handler;\r\n\r\n\t};\r\n\r\n\tthis.emit = function(event) {\r\n\r\n\t\tvar handler = _handlers[event];\r\n\t\tif (handler) {\r\n\r\n\t\t\thandler.apply(null, Array.prototype.slice.call(arguments, 1));\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.filename = settings.name || guid();\r\n\tthis.extension = '';\r\n\tthis.mimeType = '';\r\n\r\n}\r\n\r\nCCFrameEncoder.prototype.start = function(){};\r\nCCFrameEncoder.prototype.stop = function(){};\r\nCCFrameEncoder.prototype.add = function(){};\r\nCCFrameEncoder.prototype.save = function(){};\r\nCCFrameEncoder.prototype.dispose = function(){};\r\nCCFrameEncoder.prototype.safeToProceed = function(){ return true; };\r\nCCFrameEncoder.prototype.step = function() { console.log( 'Step not set!' ) }\r\n\r\nfunction CCTarEncoder( settings ) {\r\n\r\n  CCFrameEncoder.call( this, settings );\r\n\r\n  this.extension = '.tar'\r\n  this.mimeType = 'application/x-tar'\r\n  this.fileExtension = '';\r\n  this.baseFilename = this.filename;\r\n\r\n  this.tape = null\r\n  this.count = 0;\r\n  this.part = 1;\r\n  this.frames = 0;\r\n\r\n}\r\n\r\nCCTarEncoder.prototype = Object.create( CCFrameEncoder.prototype );\r\n\r\nCCTarEncoder.prototype.start = function(){\r\n\r\n  this.dispose();\r\n\r\n};\r\n\r\nCCTarEncoder.prototype.add = function( blob ) {\r\n\r\n  var fileReader = new FileReader();\r\n  fileReader.onload = function() {\r\n    this.tape.append( pad( this.count ) + this.fileExtension, new Uint8Array( fileReader.result ) );\r\n\r\n    if( this.settings.autoSaveTime > 0 && ( this.frames / this.settings.framerate ) >= this.settings.autoSaveTime ) {\r\n      this.save( function( blob ) {\r\n        this.filename = this.baseFilename + '-part-' + pad( this.part );\r\n        download( blob, this.filename + this.extension, this.mimeType );\r\n        var count = this.count;\r\n        this.dispose();\r\n        this.count = count+1;\r\n        this.part++;\r\n        this.filename = this.baseFilename + '-part-' + pad( this.part );\r\n        this.frames = 0;\r\n        this.step();\r\n      }.bind( this ) )\r\n    } else {\r\n      this.count++;\r\n      this.frames++;\r\n      this.step();\r\n    }\r\n\r\n  }.bind( this );\r\n  fileReader.readAsArrayBuffer(blob);\r\n\r\n}\r\n\r\nCCTarEncoder.prototype.save = function( callback ) {\r\n\r\n  callback( this.tape.save() );\r\n\r\n}\r\n\r\nCCTarEncoder.prototype.dispose = function() {\r\n\r\n  this.tape = new Tar();\r\n  this.count = 0;\r\n\r\n}\r\n\r\nfunction CCPNGEncoder( settings ) {\r\n\r\n\tCCTarEncoder.call( this, settings );\r\n\r\n\tthis.type = 'image/png';\r\n\tthis.fileExtension = '.png';\r\n\r\n}\r\n\r\nCCPNGEncoder.prototype = Object.create( CCTarEncoder.prototype );\r\n\r\nCCPNGEncoder.prototype.add = function( canvas ) {\r\n\r\n\tcanvas.toBlob( function( blob ) {\r\n\t\tCCTarEncoder.prototype.add.call( this, blob );\r\n\t}.bind( this ), this.type )\r\n\r\n}\r\n\r\nfunction CCJPEGEncoder( settings ) {\r\n\r\n\tCCTarEncoder.call( this, settings );\r\n\r\n\tthis.type = 'image/jpeg';\r\n\tthis.fileExtension = '.jpg';\r\n\tthis.quality = ( settings.quality / 100 ) || .8;\r\n\r\n}\r\n\r\nCCJPEGEncoder.prototype = Object.create( CCTarEncoder.prototype );\r\n\r\nCCJPEGEncoder.prototype.add = function( canvas ) {\r\n\r\n\tcanvas.toBlob( function( blob ) {\r\n\t\tCCTarEncoder.prototype.add.call( this, blob );\r\n\t}.bind( this ), this.type, this.quality )\r\n\r\n}\r\n\r\n/*\r\n\r\n\tWebM Encoder\r\n\r\n*/\r\n\r\nfunction CCWebMEncoder( settings ) {\r\n\r\n\tvar canvas = document.createElement( 'canvas' );\r\n\tif( canvas.toDataURL( 'image/webp' ).substr(5,10) !== 'image/webp' ){\r\n\t\tconsole.log( \"WebP not supported - try another export format\" )\r\n\t}\r\n\r\n\tCCFrameEncoder.call( this, settings );\r\n\r\n\tthis.quality = ( settings.quality / 100 ) || .8;\r\n\r\n\tthis.extension = '.webm'\r\n\tthis.mimeType = 'video/webm'\r\n\tthis.baseFilename = this.filename;\r\n  this.framerate = settings.framerate;\r\n\r\n\tthis.frames = 0;\r\n\tthis.part = 1;\r\n\r\n  this.videoWriter = new WebMWriter({\r\n    quality: this.quality,\r\n    fileWriter: null,\r\n    fd: null,\r\n    frameRate: this.framerate\r\n  });\r\n\r\n}\r\n\r\nCCWebMEncoder.prototype = Object.create( CCFrameEncoder.prototype );\r\n\r\nCCWebMEncoder.prototype.start = function( canvas ) {\r\n\r\n\tthis.dispose();\r\n\r\n}\r\n\r\nCCWebMEncoder.prototype.add = function( canvas ) {\r\n\r\n  this.videoWriter.addFrame(canvas);\r\n\r\n\tif( this.settings.autoSaveTime > 0 && ( this.frames / this.settings.framerate ) >= this.settings.autoSaveTime ) {\r\n\t\tthis.save( function( blob ) {\r\n\t\t\tthis.filename = this.baseFilename + '-part-' + pad( this.part );\r\n\t\t\tdownload( blob, this.filename + this.extension, this.mimeType );\r\n\t\t\tthis.dispose();\r\n\t\t\tthis.part++;\r\n\t\t\tthis.filename = this.baseFilename + '-part-' + pad( this.part );\r\n\t\t\tthis.step();\r\n\t\t}.bind( this ) )\r\n\t} else {\r\n    this.frames++;\r\n\t\tthis.step();\r\n\t}\r\n\r\n}\r\n\r\nCCWebMEncoder.prototype.save = function( callback ) {\r\n\r\n  this.videoWriter.complete().then(callback);\r\n\r\n}\r\n\r\nCCWebMEncoder.prototype.dispose = function( canvas ) {\r\n\r\n\tthis.frames = 0;\r\n  this.videoWriter = new WebMWriter({\r\n    quality: this.quality,\r\n    fileWriter: null,\r\n    fd: null,\r\n    frameRate: this.framerate\r\n  });\r\n\r\n}\r\n\r\nfunction CCFFMpegServerEncoder( settings ) {\r\n\r\n\tCCFrameEncoder.call( this, settings );\r\n\r\n\tsettings.quality = ( settings.quality / 100 ) || .8;\r\n\r\n\tthis.encoder = new FFMpegServer.Video( settings );\r\n    this.encoder.on( 'process', function() {\r\n        this.emit( 'process' )\r\n    }.bind( this ) );\r\n    this.encoder.on('finished', function( url, size ) {\r\n        var cb = this.callback;\r\n        if ( cb ) {\r\n            this.callback = undefined;\r\n            cb( url, size );\r\n        }\r\n    }.bind( this ) );\r\n    this.encoder.on( 'progress', function( progress ) {\r\n        if ( this.settings.onProgress ) {\r\n            this.settings.onProgress( progress )\r\n        }\r\n    }.bind( this ) );\r\n    this.encoder.on( 'error', function( data ) {\r\n        alert(JSON.stringify(data, null, 2));\r\n    }.bind( this ) );\r\n\r\n}\r\n\r\nCCFFMpegServerEncoder.prototype = Object.create( CCFrameEncoder.prototype );\r\n\r\nCCFFMpegServerEncoder.prototype.start = function() {\r\n\r\n\tthis.encoder.start( this.settings );\r\n\r\n};\r\n\r\nCCFFMpegServerEncoder.prototype.add = function( canvas ) {\r\n\r\n\tthis.encoder.add( canvas );\r\n\r\n}\r\n\r\nCCFFMpegServerEncoder.prototype.save = function( callback ) {\r\n\r\n    this.callback = callback;\r\n    this.encoder.end();\r\n\r\n}\r\n\r\nCCFFMpegServerEncoder.prototype.safeToProceed = function() {\r\n    return this.encoder.safeToProceed();\r\n};\r\n\r\n/*\r\n\tHTMLCanvasElement.captureStream()\r\n*/\r\n\r\nfunction CCStreamEncoder( settings ) {\r\n\r\n\tCCFrameEncoder.call( this, settings );\r\n\r\n\tthis.framerate = this.settings.framerate;\r\n\tthis.type = 'video/webm';\r\n\tthis.extension = '.webm';\r\n\tthis.stream = null;\r\n\tthis.mediaRecorder = null;\r\n\tthis.chunks = [];\r\n\r\n}\r\n\r\nCCStreamEncoder.prototype = Object.create( CCFrameEncoder.prototype );\r\n\r\nCCStreamEncoder.prototype.add = function( canvas ) {\r\n\r\n\tif( !this.stream ) {\r\n\t\tthis.stream = canvas.captureStream( this.framerate );\r\n\t\tthis.mediaRecorder = new MediaRecorder( this.stream );\r\n\t\tthis.mediaRecorder.start();\r\n\r\n\t\tthis.mediaRecorder.ondataavailable = function(e) {\r\n\t\t\tthis.chunks.push(e.data);\r\n\t\t}.bind( this );\r\n\r\n\t}\r\n\tthis.step();\r\n\r\n}\r\n\r\nCCStreamEncoder.prototype.save = function( callback ) {\r\n\r\n\tthis.mediaRecorder.onstop = function( e ) {\r\n\t\tvar blob = new Blob( this.chunks, { 'type' : 'video/webm' });\r\n\t\tthis.chunks = [];\r\n\t\tcallback( blob );\r\n\r\n\t}.bind( this );\r\n\r\n\tthis.mediaRecorder.stop();\r\n\r\n}\r\n\r\n/*function CCGIFEncoder( settings ) {\r\n\r\n\tCCFrameEncoder.call( this );\r\n\r\n\tsettings.quality = settings.quality || 6;\r\n\tthis.settings = settings;\r\n\r\n\tthis.encoder = new GIFEncoder();\r\n\tthis.encoder.setRepeat( 1 );\r\n  \tthis.encoder.setDelay( settings.step );\r\n  \tthis.encoder.setQuality( 6 );\r\n  \tthis.encoder.setTransparent( null );\r\n  \tthis.encoder.setSize( 150, 150 );\r\n\r\n  \tthis.canvas = document.createElement( 'canvas' );\r\n  \tthis.ctx = this.canvas.getContext( '2d' );\r\n\r\n}\r\n\r\nCCGIFEncoder.prototype = Object.create( CCFrameEncoder );\r\n\r\nCCGIFEncoder.prototype.start = function() {\r\n\r\n\tthis.encoder.start();\r\n\r\n}\r\n\r\nCCGIFEncoder.prototype.add = function( canvas ) {\r\n\r\n\tthis.canvas.width = canvas.width;\r\n\tthis.canvas.height = canvas.height;\r\n\tthis.ctx.drawImage( canvas, 0, 0 );\r\n\tthis.encoder.addFrame( this.ctx );\r\n\r\n\tthis.encoder.setSize( canvas.width, canvas.height );\r\n\tvar readBuffer = new Uint8Array(canvas.width * canvas.height * 4);\r\n\tvar context = canvas.getContext( 'webgl' );\r\n\tcontext.readPixels(0, 0, canvas.width, canvas.height, context.RGBA, context.UNSIGNED_BYTE, readBuffer);\r\n\tthis.encoder.addFrame( readBuffer, true );\r\n\r\n}\r\n\r\nCCGIFEncoder.prototype.stop = function() {\r\n\r\n\tthis.encoder.finish();\r\n\r\n}\r\n\r\nCCGIFEncoder.prototype.save = function( callback ) {\r\n\r\n\tvar binary_gif = this.encoder.stream().getData();\r\n\r\n\tvar data_url = 'data:image/gif;base64,'+encode64(binary_gif);\r\n\twindow.location = data_url;\r\n\treturn;\r\n\r\n\tvar blob = new Blob( [ binary_gif ], { type: \"octet/stream\" } );\r\n\tvar url = window.URL.createObjectURL( blob );\r\n\tcallback( url );\r\n\r\n}*/\r\n\r\nfunction CCGIFEncoder( settings ) {\r\n\r\n\tCCFrameEncoder.call( this, settings );\r\n\r\n\tsettings.quality = 31 - ( ( settings.quality * 30 / 100 ) || 10 );\r\n\tsettings.workers = settings.workers || 4;\r\n\r\n\tthis.extension = '.gif'\r\n\tthis.mimeType = 'image/gif'\r\n\r\n  \tthis.canvas = document.createElement( 'canvas' );\r\n  \tthis.ctx = this.canvas.getContext( '2d' );\r\n  \tthis.sizeSet = false;\r\n\r\n  \tthis.encoder = new GIF({\r\n\t\tworkers: settings.workers,\r\n\t\tquality: settings.quality,\r\n\t\tworkerScript: settings.workersPath + 'gif.worker.js'\r\n\t} );\r\n\r\n    this.encoder.on( 'progress', function( progress ) {\r\n        if ( this.settings.onProgress ) {\r\n            this.settings.onProgress( progress )\r\n        }\r\n    }.bind( this ) );\r\n\r\n    this.encoder.on('finished', function( blob ) {\r\n        var cb = this.callback;\r\n        if ( cb ) {\r\n            this.callback = undefined;\r\n            cb( blob );\r\n        }\r\n    }.bind( this ) );\r\n\r\n}\r\n\r\nCCGIFEncoder.prototype = Object.create( CCFrameEncoder.prototype );\r\n\r\nCCGIFEncoder.prototype.add = function( canvas ) {\r\n\r\n\tif( !this.sizeSet ) {\r\n\t\tthis.encoder.setOption( 'width',canvas.width );\r\n\t\tthis.encoder.setOption( 'height',canvas.height );\r\n\t\tthis.sizeSet = true;\r\n\t}\r\n\r\n\tthis.canvas.width = canvas.width;\r\n\tthis.canvas.height = canvas.height;\r\n\tthis.ctx.drawImage( canvas, 0, 0 );\r\n\r\n\tthis.encoder.addFrame( this.ctx, { copy: true, delay: this.settings.step } );\r\n\tthis.step();\r\n\r\n\t/*this.encoder.setSize( canvas.width, canvas.height );\r\n\tvar readBuffer = new Uint8Array(canvas.width * canvas.height * 4);\r\n\tvar context = canvas.getContext( 'webgl' );\r\n\tcontext.readPixels(0, 0, canvas.width, canvas.height, context.RGBA, context.UNSIGNED_BYTE, readBuffer);\r\n\tthis.encoder.addFrame( readBuffer, true );*/\r\n\r\n}\r\n\r\nCCGIFEncoder.prototype.save = function( callback ) {\r\n\r\n    this.callback = callback;\r\n\r\n\tthis.encoder.render();\r\n\r\n}\r\n\r\nfunction CCapture( settings ) {\r\n\r\n\tvar _settings = settings || {},\r\n\t\t_date = new Date(),\r\n\t\t_verbose,\r\n\t\t_display,\r\n\t\t_time,\r\n\t\t_startTime,\r\n\t\t_performanceTime,\r\n\t\t_performanceStartTime,\r\n\t\t_step,\r\n        _encoder,\r\n\t\t_timeouts = [],\r\n\t\t_intervals = [],\r\n\t\t_frameCount = 0,\r\n\t\t_intermediateFrameCount = 0,\r\n\t\t_lastFrame = null,\r\n\t\t_requestAnimationFrameCallbacks = [],\r\n\t\t_capturing = false,\r\n        _handlers = {};\r\n\r\n\t_settings.framerate = _settings.framerate || 60;\r\n\t_settings.motionBlurFrames = 2 * ( _settings.motionBlurFrames || 1 );\r\n\t_verbose = _settings.verbose || false;\r\n\t_display = _settings.display || false;\r\n\t_settings.step = 1000.0 / _settings.framerate ;\r\n\t_settings.timeLimit = _settings.timeLimit || 0;\r\n\t_settings.frameLimit = _settings.frameLimit || 0;\r\n\t_settings.startTime = _settings.startTime || 0;\r\n\r\n\tvar _timeDisplay = document.createElement( 'div' );\r\n\t_timeDisplay.style.position = 'absolute';\r\n\t_timeDisplay.style.left = _timeDisplay.style.top = 0\r\n\t_timeDisplay.style.backgroundColor = 'black';\r\n\t_timeDisplay.style.fontFamily = 'monospace'\r\n\t_timeDisplay.style.fontSize = '11px'\r\n\t_timeDisplay.style.padding = '5px'\r\n\t_timeDisplay.style.color = 'red';\r\n\t_timeDisplay.style.zIndex = 100000\r\n\tif( _settings.display ) document.body.appendChild( _timeDisplay );\r\n\r\n\tvar canvasMotionBlur = document.createElement( 'canvas' );\r\n\tvar ctxMotionBlur = canvasMotionBlur.getContext( '2d' );\r\n\tvar bufferMotionBlur;\r\n\tvar imageData;\r\n\r\n\t_log( 'Step is set to ' + _settings.step + 'ms' );\r\n\r\n    var _encoders = {\r\n\t\tgif: CCGIFEncoder,\r\n\t\twebm: CCWebMEncoder,\r\n\t\tffmpegserver: CCFFMpegServerEncoder,\r\n\t\tpng: CCPNGEncoder,\r\n\t\tjpg: CCJPEGEncoder,\r\n\t\t'webm-mediarecorder': CCStreamEncoder\r\n    };\r\n\r\n    var ctor = _encoders[ _settings.format ];\r\n    if ( !ctor ) {\r\n\t\tthrow \"Error: Incorrect or missing format: Valid formats are \" + Object.keys(_encoders).join(\", \");\r\n    }\r\n    _encoder = new ctor( _settings );\r\n    _encoder.step = _step\r\n\r\n\t_encoder.on('process', _process);\r\n    _encoder.on('progress', _progress);\r\n\r\n    if (\"performance\" in window == false) {\r\n    \twindow.performance = {};\r\n    }\r\n\r\n\tDate.now = (Date.now || function () {  // thanks IE8\r\n\t\treturn new Date().getTime();\r\n\t});\r\n\r\n\tif (\"now\" in window.performance == false){\r\n\r\n\t\tvar nowOffset = Date.now();\r\n\r\n\t\tif (performance.timing && performance.timing.navigationStart){\r\n\t\t\tnowOffset = performance.timing.navigationStart\r\n\t\t}\r\n\r\n\t\twindow.performance.now = function now(){\r\n\t\t\treturn Date.now() - nowOffset;\r\n\t\t}\r\n\t}\r\n\r\n\tvar _oldSetTimeout = window.setTimeout,\r\n\t\t_oldSetInterval = window.setInterval,\r\n\t    \t_oldClearInterval = window.clearInterval,\r\n\t\t_oldClearTimeout = window.clearTimeout,\r\n\t\t_oldRequestAnimationFrame = window.requestAnimationFrame,\r\n\t\t_oldNow = window.Date.now,\r\n\t\t_oldPerformanceNow = window.performance.now,\r\n\t\t_oldGetTime = window.Date.prototype.getTime;\r\n\t// Date.prototype._oldGetTime = Date.prototype.getTime;\r\n\r\n\tvar media = [];\r\n\r\n\tfunction _init() {\r\n\r\n\t\t_log( 'Capturer start' );\r\n\r\n\t\t_startTime = window.Date.now();\r\n\t\t_time = _startTime + _settings.startTime;\r\n\t\t_performanceStartTime = window.performance.now();\r\n\t\t_performanceTime = _performanceStartTime + _settings.startTime;\r\n\r\n\t\twindow.Date.prototype.getTime = function(){\r\n\t\t\treturn _time;\r\n\t\t};\r\n\t\twindow.Date.now = function() {\r\n\t\t\treturn _time;\r\n\t\t};\r\n\r\n\t\twindow.setTimeout = function( callback, time ) {\r\n\t\t\tvar t = {\r\n\t\t\t\tcallback: callback,\r\n\t\t\t\ttime: time,\r\n\t\t\t\ttriggerTime: _time + time\r\n\t\t\t};\r\n\t\t\t_timeouts.push( t );\r\n\t\t\t_log( 'Timeout set to ' + t.time );\r\n            return t;\r\n\t\t};\r\n\t\twindow.clearTimeout = function( id ) {\r\n\t\t\tfor( var j = 0; j < _timeouts.length; j++ ) {\r\n\t\t\t\tif( _timeouts[ j ] == id ) {\r\n\t\t\t\t\t_timeouts.splice( j, 1 );\r\n\t\t\t\t\t_log( 'Timeout cleared' );\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\twindow.setInterval = function( callback, time ) {\r\n\t\t\tvar t = {\r\n\t\t\t\tcallback: callback,\r\n\t\t\t\ttime: time,\r\n\t\t\t\ttriggerTime: _time + time\r\n\t\t\t};\r\n\t\t\t_intervals.push( t );\r\n\t\t\t_log( 'Interval set to ' + t.time );\r\n\t\t\treturn t;\r\n\t\t};\r\n\t\twindow.clearInterval = function( id ) {\r\n\t\t\t_log( 'clear Interval' );\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\twindow.requestAnimationFrame = function( callback ) {\r\n\t\t\t_requestAnimationFrameCallbacks.push( callback );\r\n\t\t};\r\n\t\twindow.performance.now = function(){\r\n\t\t\treturn _performanceTime;\r\n\t\t};\r\n\r\n\t\tfunction hookCurrentTime() {\u00A0\r\n\t\t\tif( !this._hooked ) {\r\n\t\t\t\tthis._hooked = true;\r\n\t\t\t\tthis._hookedTime = this.currentTime || 0;\r\n\t\t\t\tthis.pause();\r\n\t\t\t\tmedia.push( this );\r\n\t\t\t}\r\n\t\t\treturn this._hookedTime + _settings.startTime;\r\n\t\t};\r\n\r\n\t\ttry {\r\n\t\t\tObject.defineProperty( HTMLVideoElement.prototype, 'currentTime', { get: hookCurrentTime } )\r\n\t\t\tObject.defineProperty( HTMLAudioElement.prototype, 'currentTime', { get: hookCurrentTime } )\r\n\t\t} catch (err) {\r\n\t\t\t_log(err);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction _start() {\r\n\t\t_init();\r\n\t\t_encoder.start();\r\n\t\t_capturing = true;\r\n\t}\r\n\r\n\tfunction _stop() {\r\n\t\t_capturing = false;\r\n\t\t_encoder.stop();\r\n\t\t_destroy();\r\n\t}\r\n\r\n\tfunction _call( fn, p ) {\r\n\t\t_oldSetTimeout( fn, 0, p );\r\n\t}\r\n\r\n\tfunction _step() {\r\n\t\t//_oldRequestAnimationFrame( _process );\r\n\t\t_call( _process );\r\n\t}\r\n\r\n\tfunction _destroy() {\r\n\t\t_log( 'Capturer stop' );\r\n\t\twindow.setTimeout = _oldSetTimeout;\r\n\t\twindow.setInterval = _oldSetInterval;\r\n\t\twindow.clearInterval = _oldClearInterval;\r\n\t\twindow.clearTimeout = _oldClearTimeout;\r\n\t\twindow.requestAnimationFrame = _oldRequestAnimationFrame;\r\n\t\twindow.Date.prototype.getTime = _oldGetTime;\r\n\t\twindow.Date.now = _oldNow;\r\n\t\twindow.performance.now = _oldPerformanceNow;\r\n\t}\r\n\r\n\tfunction _updateTime() {\r\n\t\tvar seconds = _frameCount / _settings.framerate;\r\n\t\tif( ( _settings.frameLimit && _frameCount >= _settings.frameLimit ) || ( _settings.timeLimit && seconds >= _settings.timeLimit ) ) {\r\n\t\t\t_stop();\r\n\t\t\t_save();\r\n\t\t}\r\n\t\tvar d = new Date( null );\r\n\t\td.setSeconds( seconds );\r\n\t\tif( _settings.motionBlurFrames > 2 ) {\r\n\t\t\t_timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames (' + _intermediateFrameCount + ' inter) | ' +  d.toISOString().substr( 11, 8 );\r\n\t\t} else {\r\n\t\t\t_timeDisplay.textContent = 'CCapture ' + _settings.format + ' | ' + _frameCount + ' frames | ' +  d.toISOString().substr( 11, 8 );\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _checkFrame( canvas ) {\r\n\r\n\t\tif( canvasMotionBlur.width !== canvas.width || canvasMotionBlur.height !== canvas.height ) {\r\n\t\t\tcanvasMotionBlur.width = canvas.width;\r\n\t\t\tcanvasMotionBlur.height = canvas.height;\r\n\t\t\tbufferMotionBlur = new Uint16Array( canvasMotionBlur.height * canvasMotionBlur.width * 4 );\r\n\t\t\tctxMotionBlur.fillStyle = '#0'\r\n\t\t\tctxMotionBlur.fillRect( 0, 0, canvasMotionBlur.width, canvasMotionBlur.height );\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction _blendFrame( canvas ) {\r\n\r\n\t\t//_log( 'Intermediate Frame: ' + _intermediateFrameCount );\r\n\r\n\t\tctxMotionBlur.drawImage( canvas, 0, 0 );\r\n\t\timageData = ctxMotionBlur.getImageData( 0, 0, canvasMotionBlur.width, canvasMotionBlur.height );\r\n\t\tfor( var j = 0; j < bufferMotionBlur.length; j+= 4 ) {\r\n\t\t\tbufferMotionBlur[ j ] += imageData.data[ j ];\r\n\t\t\tbufferMotionBlur[ j + 1 ] += imageData.data[ j + 1 ];\r\n\t\t\tbufferMotionBlur[ j + 2 ] += imageData.data[ j + 2 ];\r\n\t\t}\r\n\t\t_intermediateFrameCount++;\r\n\r\n\t}\r\n\r\n\tfunction _saveFrame(){\r\n\r\n\t\tvar data = imageData.data;\r\n\t\tfor( var j = 0; j < bufferMotionBlur.length; j+= 4 ) {\r\n\t\t\tdata[ j ] = bufferMotionBlur[ j ] * 2 / _settings.motionBlurFrames;\r\n\t\t\tdata[ j + 1 ] = bufferMotionBlur[ j + 1 ] * 2 / _settings.motionBlurFrames;\r\n\t\t\tdata[ j + 2 ] = bufferMotionBlur[ j + 2 ] * 2 / _settings.motionBlurFrames;\r\n\t\t}\r\n\t\tctxMotionBlur.putImageData( imageData, 0, 0 );\r\n\t\t_encoder.add( canvasMotionBlur );\r\n\t\t_frameCount++;\r\n\t\t_intermediateFrameCount = 0;\r\n\t\t_log( 'Full MB Frame! ' + _frameCount + ' ' +  _time );\r\n\t\tfor( var j = 0; j < bufferMotionBlur.length; j+= 4 ) {\r\n\t\t\tbufferMotionBlur[ j ] = 0;\r\n\t\t\tbufferMotionBlur[ j + 1 ] = 0;\r\n\t\t\tbufferMotionBlur[ j + 2 ] = 0;\r\n\t\t}\r\n\t\tgc();\r\n\r\n\t}\r\n\r\n\tfunction _capture( canvas ) {\r\n\r\n\t\tif( _capturing ) {\r\n\r\n\t\t\tif( _settings.motionBlurFrames > 2 ) {\r\n\r\n\t\t\t\t_checkFrame( canvas );\r\n\t\t\t\t_blendFrame( canvas );\r\n\r\n\t\t\t\tif( _intermediateFrameCount >= .5 * _settings.motionBlurFrames ) {\r\n\t\t\t\t\t_saveFrame();\r\n\t\t\t\t} else {\r\n\t\t\t\t\t_step();\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\t_encoder.add( canvas );\r\n\t\t\t\t_frameCount++;\r\n\t\t\t\t_log( 'Full Frame! ' + _frameCount );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction _process() {\r\n\r\n\t\tvar step = 1000 / _settings.framerate;\r\n\t\tvar dt = ( _frameCount + _intermediateFrameCount / _settings.motionBlurFrames ) * step;\r\n\r\n\t\t_time = _startTime + dt;\r\n\t\t_performanceTime = _performanceStartTime + dt;\r\n\r\n\t\tmedia.forEach( function( v ) {\r\n\t\t\tv._hookedTime = dt / 1000;\r\n\t\t} );\r\n\r\n\t\t_updateTime();\r\n\t\t_log( 'Frame: ' + _frameCount + ' ' + _intermediateFrameCount );\r\n\r\n\t\tfor( var j = 0; j < _timeouts.length; j++ ) {\r\n\t\t\tif( _time >= _timeouts[ j ].triggerTime ) {\r\n\t\t\t\t_call( _timeouts[ j ].callback )\r\n\t\t\t\t//console.log( 'timeout!' );\r\n\t\t\t\t_timeouts.splice( j, 1 );\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor( var j = 0; j < _intervals.length; j++ ) {\r\n\t\t\tif( _time >= _intervals[ j ].triggerTime ) {\r\n\t\t\t\t_call( _intervals[ j ].callback );\r\n\t\t\t\t_intervals[ j ].triggerTime += _intervals[ j ].time;\r\n\t\t\t\t//console.log( 'interval!' );\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_requestAnimationFrameCallbacks.forEach( function( cb ) {\r\n     \t\t_call( cb, _time - g_startTime );\r\n        } );\r\n        _requestAnimationFrameCallbacks = [];\r\n\r\n\t}\r\n\r\n\tfunction _save( callback ) {\r\n\r\n\t\tif( !callback ) {\r\n\t\t\tcallback = function( blob ) {\r\n\t\t\t\tdownload( blob, _encoder.filename + _encoder.extension, _encoder.mimeType );\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t_encoder.save( callback );\r\n\r\n\t}\r\n\r\n\tfunction _log( message ) {\r\n\t\tif( _verbose ) console.log( message );\r\n\t}\r\n\r\n    function _on( event, handler ) {\r\n\r\n        _handlers[event] = handler;\r\n\r\n    }\r\n\r\n    function _emit( event ) {\r\n\r\n        var handler = _handlers[event];\r\n        if ( handler ) {\r\n\r\n            handler.apply( null, Array.prototype.slice.call( arguments, 1 ) );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function _progress( progress ) {\r\n\r\n        _emit( 'progress', progress );\r\n\r\n    }\r\n\r\n\treturn {\r\n\t\tstart: _start,\r\n\t\tcapture: _capture,\r\n\t\tstop: _stop,\r\n\t\tsave: _save,\r\n        on: _on\r\n\t}\r\n}\r\n\r\n(freeWindow || freeSelf || {}).CCapture = CCapture;\r\n\r\n  // Some AMD build optimizers like r.js check for condition patterns like the following:\r\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\r\n    // Define as an anonymous module so, through path mapping, it can be\r\n    // referenced as the \"underscore\" module.\r\n    define(function() {\r\n    \treturn CCapture;\r\n    });\r\n}\r\n  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\r\n  else if (freeExports && freeModule) {\r\n    // Export for Node.js.\r\n    if (moduleExports) {\r\n    \t(freeModule.exports = CCapture).CCapture = CCapture;\r\n    }\r\n    // Export for CommonJS support.\r\n    freeExports.CCapture = CCapture;\r\n}\r\nelse {\r\n    // Export to the global object.\r\n    root.CCapture = CCapture;\r\n}\r\n\r\n}());\r\n", "/**\n * A tool for presenting an ArrayBuffer as a stream for writing some simple data types.\n * \n * By Nicholas Sherlock\n * \n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n\"use strict\";\n\n(function(){\n\n    // var isNodeEnviroment = typeof module !== 'undefined' && typeof module.exports !== 'undefined';\n    var isNodeEnviroment = false;\n\n    /**\n     * Create an ArrayBuffer of the given length and present it as a writable stream with methods\n     * for writing data in different formats.\n     */\n\n    var ArrayBufferDataStream = function(length) {\n        this.data = new Uint8Array(length);\n        this.pos = 0;\n    };\n    \n    ArrayBufferDataStream.prototype.seek = function(offset) {\n        this.pos = offset;\n    };\n\n    ArrayBufferDataStream.prototype.writeBytes = function(arr) {\n        for (var i = 0; i < arr.length; i++) {\n            this.data[this.pos++] = arr[i];\n        }\n    };\n\n    ArrayBufferDataStream.prototype.writeByte = function(b) {\n        this.data[this.pos++] = b;\n    };\n    \n    //Synonym:\n    ArrayBufferDataStream.prototype.writeU8 = ArrayBufferDataStream.prototype.writeByte;\n    \n    ArrayBufferDataStream.prototype.writeU16BE = function(u) {\n        this.data[this.pos++] = u >> 8;\n        this.data[this.pos++] = u;\n    };\n\n    ArrayBufferDataStream.prototype.writeDoubleBE = function(d) {\n        var \n            bytes = new Uint8Array(new Float64Array([d]).buffer);\n        \n        for (var i = bytes.length - 1; i >= 0; i--) {\n            this.writeByte(bytes[i]);\n        }\n    };\n\n    ArrayBufferDataStream.prototype.writeFloatBE = function(d) {\n        var \n            bytes = new Uint8Array(new Float32Array([d]).buffer);\n        \n        for (var i = bytes.length - 1; i >= 0; i--) {\n            this.writeByte(bytes[i]);\n        }\n    };\n\n    /**\n     * Write an ASCII string to the stream\n     */\n    ArrayBufferDataStream.prototype.writeString = function(s) {\n        for (var i = 0; i < s.length; i++) {\n            this.data[this.pos++] = s.charCodeAt(i);\n        }\n    };\n\n    /**\n     * Write the given 32-bit integer to the stream as an EBML variable-length integer using the given byte width \n     * (use measureEBMLVarInt).\n     * \n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     * \n     * @param i Integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n    ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function(i, width) {\n        switch (width) {\n            case 1:\n                this.writeU8((1 << 7) | i);\n            break;\n            case 2:\n                this.writeU8((1 << 6) | (i >> 8));\n                this.writeU8(i);\n            break;\n            case 3:\n                this.writeU8((1 << 5) | (i >> 16));\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            case 4:\n                this.writeU8((1 << 4) | (i >> 24));\n                this.writeU8(i >> 16);\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            case 5:\n                /* \n                 * JavaScript converts its doubles to 32-bit integers for bitwise operations, so we need to do a \n                 * division by 2^32 instead of a right-shift of 32 to retain those top 3 bits\n                 */\n                this.writeU8((1 << 3) | ((i / 4294967296) & 0x7)); \n                this.writeU8(i >> 24);\n                this.writeU8(i >> 16);\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            default:\n                throw new RuntimeException(\"Bad EBML VINT size \" + width);\n        }\n    };\n    \n    /**\n     * Return the number of bytes needed to encode the given integer as an EBML VINT.\n     */\n    ArrayBufferDataStream.prototype.measureEBMLVarInt = function(val) {\n        if (val < (1 << 7) - 1) { \n            /* Top bit is set, leaving 7 bits to hold the integer, but we can't store 127 because\n             * \"all bits set to one\" is a reserved value. Same thing for the other cases below:\n             */\n            return 1;\n        } else if (val < (1 << 14) - 1) {\n            return 2;\n        } else if (val < (1 << 21) - 1) {\n            return 3;\n        } else if (val < (1 << 28) - 1) {\n            return 4;\n        } else if (val < 34359738367) { // 2 ^ 35 - 1 (can address 32GB)\n            return 5;\n        } else {\n            throw new RuntimeException(\"EBML VINT size not supported \" + val);\n        }\n    };\n    \n    ArrayBufferDataStream.prototype.writeEBMLVarInt = function(i) {\n        this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));\n    };\n    \n    /**\n     * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     * \n     * Omit the width parameter to have it determined automatically for you.\n     * \n     * @param u Unsigned integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n    ArrayBufferDataStream.prototype.writeUnsignedIntBE = function(u, width) {\n        if (width === undefined) {\n            width = this.measureUnsignedInt(u);\n        }\n        \n        // Each case falls through:\n        switch (width) {\n            case 5:\n                this.writeU8(Math.floor(u / 4294967296)); // Need to use division to access >32 bits of floating point var\n            case 4:\n                this.writeU8(u >> 24);\n            case 3:\n                this.writeU8(u >> 16);\n            case 2:\n                this.writeU8(u >> 8);\n            case 1:\n                this.writeU8(u);\n            break;\n            default:\n                throw new RuntimeException(\"Bad UINT size \" + width);\n        }\n    };\n    \n    /**\n     * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.\n     */\n    ArrayBufferDataStream.prototype.measureUnsignedInt = function(val) {\n        // Force to 32-bit unsigned integer\n        if (val < (1 << 8)) {\n            return 1;\n        } else if (val < (1 << 16)) {\n            return 2;\n        } else if (val < (1 << 24)) {\n            return 3;\n        } else if (val < 4294967296) {\n            return 4;\n        } else {\n            return 5;\n        }\n    };\n\n    /**\n     * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.\n     */\n    ArrayBufferDataStream.prototype.getAsDataArray = function() {\n        if (this.pos < this.data.byteLength) {\n            return this.data.subarray(0, this.pos);\n        } else if (this.pos == this.data.byteLength) {\n            return this.data;\n        } else {\n            throw \"ArrayBufferDataStream's pos lies beyond end of buffer\";\n        }\n    };\n\n    window.ArrayBufferDataStream = ArrayBufferDataStream;\n\n    /**\n     * Allows a series of Blob-convertible objects (ArrayBuffer, Blob, String, etc) to be added to a buffer. Seeking and\n     * overwriting of blobs is allowed.\n     *\n     * You can supply a FileWriter, in which case the BlobBuffer is just used as temporary storage before it writes it\n     * through to the disk.\n     *\n     * By Nicholas Sherlock\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n\tvar BlobBuffer = function(fs) {\n\t\treturn function(destination) {\n\t\t\tvar\n\t\t\t\tbuffer = [],\n\t\t\t\twritePromise = Promise.resolve(),\n\t\t\t\tfileWriter = null,\n\t\t\t\tfd = null;\n\t\t\t\n\t\t\tif (typeof FileWriter !== \"undefined\" && destination instanceof FileWriter) {\n\t\t\t\tfileWriter = destination;\n\t\t\t} else if (fs && destination) {\n\t\t\t\tfd = destination;\n\t\t\t}\n\t\t\t\n\t\t\t// Current seek offset\n\t\t\tthis.pos = 0;\n\t\t\t\n\t\t\t// One more than the index of the highest byte ever written\n\t\t\tthis.length = 0;\n\t\t\t\n\t\t\t// Returns a promise that converts the blob to an ArrayBuffer\n\t\t\tfunction readBlobAsBuffer(blob) {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tvar\n\t\t\t\t\t\treader = new FileReader();\n\t\t\t\t\t\n\t\t\t\t\treader.addEventListener(\"loadend\", function () {\n\t\t\t\t\t\tresolve(reader.result);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\treader.readAsArrayBuffer(blob);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction convertToUint8Array(thing) {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tif (thing instanceof Uint8Array) {\n\t\t\t\t\t\tresolve(thing);\n\t\t\t\t\t} else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {\n\t\t\t\t\t\tresolve(new Uint8Array(thing));\n\t\t\t\t\t} else if (thing instanceof Blob) {\n\t\t\t\t\t\tresolve(readBlobAsBuffer(thing).then(function (buffer) {\n\t\t\t\t\t\t\treturn new Uint8Array(buffer);\n\t\t\t\t\t\t}));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Assume that Blob will know how to read this thing\n\t\t\t\t\t\tresolve(readBlobAsBuffer(new Blob([thing])).then(function (buffer) {\n\t\t\t\t\t\t\treturn new Uint8Array(buffer);\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction measureData(data) {\n\t\t\t\tvar\n\t\t\t\t\tresult = data.byteLength || data.length || data.size;\n\t\t\t\t\n\t\t\t\tif (!Number.isInteger(result)) {\n\t\t\t\t\tthrow \"Failed to determine size of element\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\t/**\n\t\t\t * Seek to the given absolute offset.\n\t\t\t *\n\t\t\t * You may not seek beyond the end of the file (this would create a hole and/or allow blocks to be written in non-\n\t\t\t * sequential order, which isn't currently supported by the memory buffer backend).\n\t\t\t */\n\t\t\tthis.seek = function (offset) {\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tthrow \"Offset may not be negative\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isNaN(offset)) {\n\t\t\t\t\tthrow \"Offset may not be NaN\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (offset > this.length) {\n\t\t\t\t\tthrow \"Seeking beyond the end of file is not allowed\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.pos = offset;\n\t\t\t};\n\t\t\t\n\t\t\t/**\n\t\t\t * Write the Blob-convertible data to the buffer at the current seek position.\n\t\t\t *\n\t\t\t * Note: If overwriting existing data, the write must not cross preexisting block boundaries (written data must\n\t\t\t * be fully contained by the extent of a previous write).\n\t\t\t */\n\t\t\tthis.write = function (data) {\n\t\t\t\tvar\n\t\t\t\t\tnewEntry = {\n\t\t\t\t\t\toffset: this.pos,\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\tlength: measureData(data)\n\t\t\t\t\t},\n\t\t\t\t\tisAppend = newEntry.offset >= this.length;\n\t\t\t\t\n\t\t\t\tthis.pos += newEntry.length;\n\t\t\t\tthis.length = Math.max(this.length, this.pos);\n\t\t\t\t\n\t\t\t\t// After previous writes complete, perform our write\n\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\tif (fd) {\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\t\t\t\tconvertToUint8Array(newEntry.data).then(function(dataArray) {\n\t\t\t\t\t\t\t\tvar\n\t\t\t\t\t\t\t\t\ttotalWritten = 0,\n\t\t\t\t\t\t\t\t\tbuffer = Buffer.from(dataArray.buffer),\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\thandleWriteComplete = function(err, written, buffer) {\n\t\t\t\t\t\t\t\t\t\ttotalWritten += written;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (totalWritten >= buffer.length) {\n\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// We still have more to write...\n\t\t\t\t\t\t\t\t\t\t\tfs.write(fd, buffer, totalWritten, buffer.length - totalWritten, newEntry.offset + totalWritten, handleWriteComplete);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tfs.write(fd, buffer, 0, buffer.length, newEntry.offset, handleWriteComplete);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (fileWriter) {\n\t\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\t\tfileWriter.onwriteend = resolve;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfileWriter.seek(newEntry.offset);\n\t\t\t\t\t\t\tfileWriter.write(new Blob([newEntry.data]));\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!isAppend) {\n\t\t\t\t\t\t// We might be modifying a write that was already buffered in memory.\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Slow linear search to find a block we might be overwriting\n\t\t\t\t\t\tfor (var i = 0; i < buffer.length; i++) {\n\t\t\t\t\t\t\tvar\n\t\t\t\t\t\t\t\tentry = buffer[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If our new entry overlaps the old one in any way...\n\t\t\t\t\t\t\tif (!(newEntry.offset + newEntry.length <= entry.offset || newEntry.offset >= entry.offset + entry.length)) {\n\t\t\t\t\t\t\t\tif (newEntry.offset < entry.offset || newEntry.offset + newEntry.length > entry.offset + entry.length) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Overwrite crosses blob boundaries\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (newEntry.offset == entry.offset && newEntry.length == entry.length) {\n\t\t\t\t\t\t\t\t\t// We overwrote the entire block\n\t\t\t\t\t\t\t\t\tentry.data = newEntry.data;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// We're done\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn convertToUint8Array(entry.data)\n\t\t\t\t\t\t\t\t\t\t.then(function (entryArray) {\n\t\t\t\t\t\t\t\t\t\t\tentry.data = entryArray;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\treturn convertToUint8Array(newEntry.data);\n\t\t\t\t\t\t\t\t\t\t}).then(function (newEntryArray) {\n\t\t\t\t\t\t\t\t\t\t\tnewEntry.data = newEntryArray;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tentry.data.set(newEntry.data, newEntry.offset - entry.offset);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Else fall through to do a simple append, as we didn't overwrite any pre-existing blocks\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbuffer.push(newEntry);\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t/**\n\t\t\t * Finish all writes to the buffer, returning a promise that signals when that is complete.\n\t\t\t *\n\t\t\t * If a FileWriter was not provided, the promise is resolved with a Blob that represents the completed BlobBuffer\n\t\t\t * contents. You can optionally pass in a mimeType to be used for this blob.\n\t\t\t *\n\t\t\t * If a FileWriter was provided, the promise is resolved with null as the first argument.\n\t\t\t */\n\t\t\tthis.complete = function (mimeType) {\n\t\t\t\tif (fd || fileWriter) {\n\t\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// After writes complete we need to merge the buffer to give to the caller\n\t\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\t\tvar\n\t\t\t\t\t\t\tresult = [];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (var i = 0; i < buffer.length; i++) {\n\t\t\t\t\t\t\tresult.push(buffer[i].data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn new Blob(result, {mimeType: mimeType});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn writePromise;\n\t\t\t};\n\t\t};\n\t}(null);\n\t\n\twindow.BlobBuffer = BlobBuffer;\n\n    /**\n     * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n     * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n     *\n     * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n     * eventually returned as one composite Blob.\n     *\n     * By Nicholas Sherlock.\n     *\n     * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n    var WebMWriter = function(ArrayBufferDataStream, BlobBuffer) {\n        function extend(base, top) {\n            var\n                target = {};\n            \n            [base, top].forEach(function(obj) {\n                for (var prop in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                        target[prop] = obj[prop];\n                    }\n                }\n            });\n            \n            return target;\n        }\n        \n        /**\n         * Decode a Base64 data URL into a binary string.\n         *\n         * Returns the binary string, or false if the URL could not be decoded.\n         */\n        function decodeBase64WebPDataURL(url) {\n            if (typeof url !== \"string\" || !url.match(/^data:image\\/webp;base64,/i)) {\n                return false;\n            }\n            \n            return window.atob(url.substring(\"data:image\\/webp;base64,\".length));\n        }\n        \n        /**\n         * Convert a raw binary string (one character = one output byte) to an ArrayBuffer\n         */\n        function stringToArrayBuffer(string) {\n            var\n                buffer = new ArrayBuffer(string.length),\n                int8Array = new Uint8Array(buffer);\n            \n            for (var i = 0; i < string.length; i++) {\n                int8Array[i] = string.charCodeAt(i);\n            }\n            \n            return buffer;\n        }\n        \n        /**\n         * Convert the given canvas to a WebP encoded image and return the image data as a string.\n         */\n        function renderAsWebP(canvas, quality) {\n            var\n                frame = canvas.toDataURL('image/webp', {quality: quality});\n            \n            return decodeBase64WebPDataURL(frame);\n        }\n        \n        function extractKeyframeFromWebP(webP) {\n            // Assume that Chrome will generate a Simple Lossy WebP which has this header:\n            var\n                keyframeStartIndex = webP.indexOf('VP8 ');\n            \n            if (keyframeStartIndex == -1) {\n                throw \"Failed to identify beginning of keyframe in WebP image\";\n            }\n            \n            // Skip the header and the 4 bytes that encode the length of the VP8 chunk\n            keyframeStartIndex += 'VP8 '.length + 4;\n            \n            return webP.substring(keyframeStartIndex);\n        }\n        \n        // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n        function EBMLFloat32(value) {\n            this.value = value;\n        }\n        \n        function EBMLFloat64(value) {\n            this.value = value;\n        }\n        \n        /**\n         * Write the given EBML object to the provided ArrayBufferStream.\n         *\n         * The buffer's first byte is at bufferFileOffset inside the video file. This is used to complete offset and\n         * dataOffset fields in each EBML structure, indicating the file offset of the first byte of the EBML element and\n         * its data payload.\n         */\n        function writeEBML(buffer, bufferFileOffset, ebml) {\n            // Is the ebml an array of sibling elements?\n            if (Array.isArray(ebml)) {\n                for (var i = 0; i < ebml.length; i++) {\n                    writeEBML(buffer, bufferFileOffset, ebml[i]);\n                }\n            // Is this some sort of raw data that we want to write directly?\n            } else if (typeof ebml === \"string\") {\n                buffer.writeString(ebml);\n            } else if (ebml instanceof Uint8Array) {\n                buffer.writeBytes(ebml);\n            } else if (ebml.id){\n                // We're writing an EBML element\n                ebml.offset = buffer.pos + bufferFileOffset;\n                \n                buffer.writeUnsignedIntBE(ebml.id); // ID field\n                \n                // Now we need to write the size field, so we must know the payload size:\n                \n                if (Array.isArray(ebml.data)) {\n                    // Writing an array of child elements. We won't try to measure the size of the children up-front\n                    \n                    var\n                        sizePos, dataBegin, dataEnd;\n                    \n                    if (ebml.size === -1) {\n                        // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n                        buffer.writeByte(0xFF);\n                    } else {\n                        sizePos = buffer.pos;\n                        \n                        /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n                         * which should be plenty (we don't want to have to buffer that much data in memory at one time\n                         * anyway!)\n                         */\n                        buffer.writeBytes([0, 0, 0, 0]);\n                    }\n                    \n                    dataBegin = buffer.pos;\n                    \n                    ebml.dataOffset = dataBegin + bufferFileOffset;\n                    writeEBML(buffer, bufferFileOffset, ebml.data);\n                    \n                    if (ebml.size !== -1) {\n                        dataEnd = buffer.pos;\n                        \n                        ebml.size = dataEnd - dataBegin;\n                        \n                        buffer.seek(sizePos);\n                        buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n                        \n                        buffer.seek(dataEnd);\n                    }\n                } else if (typeof ebml.data === \"string\") {\n                    buffer.writeEBMLVarInt(ebml.data.length); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeString(ebml.data);\n                } else if (typeof ebml.data === \"number\") {\n                    // Allow the caller to explicitly choose the size if they wish by supplying a size field\n                    if (!ebml.size) {\n                        ebml.size = buffer.measureUnsignedInt(ebml.data);\n                    }\n                    \n                    buffer.writeEBMLVarInt(ebml.size); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n                } else if (ebml.data instanceof EBMLFloat64) {\n                    buffer.writeEBMLVarInt(8); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeDoubleBE(ebml.data.value);\n                } else if (ebml.data instanceof EBMLFloat32) {\n                    buffer.writeEBMLVarInt(4); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeFloatBE(ebml.data.value);\n                } else if (ebml.data instanceof Uint8Array) {\n                    buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n                    ebml.dataOffset = buffer.pos + bufferFileOffset;\n                    buffer.writeBytes(ebml.data);\n                } else {\n                    throw \"Bad EBML datatype \" + typeof ebml.data;\n                }\n            } else {\n                throw \"Bad EBML datatype \" + typeof ebml.data;\n            }\n        }\n        \n        return function(options) {\n            var\n                MAX_CLUSTER_DURATION_MSEC = 5000,\n                DEFAULT_TRACK_NUMBER = 1,\n            \n                writtenHeader = false,\n                videoWidth, videoHeight,\n                \n                clusterFrameBuffer = [],\n                clusterStartTime = 0,\n                clusterDuration = 0,\n                \n                optionDefaults = {\n                    quality: 0.95,       // WebM image quality from 0.0 (worst) to 1.0 (best)\n                    fileWriter: null,    // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n                    fd: null,            // Node.JS file descriptor to write to instead of buffering (optional)\n                    \n                    // You must supply one of:\n                    frameDuration: null, // Duration of frames in milliseconds\n                    frameRate: null,     // Number of frames per second\n                },\n                \n                seekPoints = {\n                    Cues: {id: new Uint8Array([0x1C, 0x53, 0xBB, 0x6B]), positionEBML: null},\n                    SegmentInfo: {id: new Uint8Array([0x15, 0x49, 0xA9, 0x66]), positionEBML: null},\n                    Tracks: {id: new Uint8Array([0x16, 0x54, 0xAE, 0x6B]), positionEBML: null},\n                },\n                \n                ebmlSegment,\n                segmentDuration = {\n                    \"id\": 0x4489, // Duration\n                    \"data\": new EBMLFloat64(0)\n                },\n                \n                seekHead,\n                \n                cues = [],\n                \n                blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n    \n            function fileOffsetToSegmentRelative(fileOffset) {\n                return fileOffset - ebmlSegment.dataOffset;\n            }\n            \n            /**\n             * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n             *\n             * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n             * to be overwritten later.\n             */\n            function createSeekHead() {\n                var\n                    seekPositionEBMLTemplate = {\n                        \"id\": 0x53AC, // SeekPosition\n                        \"size\": 5, // Allows for 32GB video files\n                        \"data\": 0 // We'll overwrite this when the file is complete\n                    },\n                    \n                    result = {\n                        \"id\": 0x114D9B74, // SeekHead\n                        \"data\": []\n                    };\n                \n                for (var name in seekPoints) {\n                    var\n                        seekPoint = seekPoints[name];\n                \n                    seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n                    \n                    result.data.push({\n                         \"id\": 0x4DBB, // Seek\n                         \"data\": [\n                              {\n                                  \"id\": 0x53AB, // SeekID\n                                  \"data\": seekPoint.id\n                              },\n                              seekPoint.positionEBML\n                         ]\n                    });\n                }\n                \n                return result;\n            }\n            \n            /**\n             * Write the WebM file header to the stream.\n             */\n            function writeHeader() {\n                seekHead = createSeekHead();\n                \n                var\n                    ebmlHeader = {\n                        \"id\": 0x1a45dfa3, // EBML\n                        \"data\": [\n                            {\n                                \"id\": 0x4286, // EBMLVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f7, // EBMLReadVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f2, // EBMLMaxIDLength\n                                \"data\": 4\n                            },\n                            {\n                                \"id\": 0x42f3, // EBMLMaxSizeLength\n                                \"data\": 8\n                            },\n                            {\n                                \"id\": 0x4282, // DocType\n                                \"data\": \"webm\"\n                            },\n                            {\n                                \"id\": 0x4287, // DocTypeVersion\n                                \"data\": 2\n                            },\n                            {\n                                \"id\": 0x4285, // DocTypeReadVersion\n                                \"data\": 2\n                            }\n                        ]\n                    },\n                    \n                    segmentInfo = {\n                        \"id\": 0x1549a966, // Info\n                        \"data\": [\n                            {\n                                \"id\": 0x2ad7b1, // TimecodeScale\n                                \"data\": 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n                            },\n                            {\n                                \"id\": 0x4d80, // MuxingApp\n                                \"data\": \"webm-writer-js\",\n                            },\n                            {\n                                \"id\": 0x5741, // WritingApp\n                                \"data\": \"webm-writer-js\"\n                            },\n                            segmentDuration // To be filled in later\n                        ]\n                    },\n                    \n                    tracks = {\n                        \"id\": 0x1654ae6b, // Tracks\n                        \"data\": [\n                            {\n                                \"id\": 0xae, // TrackEntry\n                                \"data\": [\n                                    {\n                                        \"id\": 0xd7, // TrackNumber\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x73c5, // TrackUID\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x9c, // FlagLacing\n                                        \"data\": 0\n                                    },\n                                    {\n                                        \"id\": 0x22b59c, // Language\n                                        \"data\": \"und\"\n                                    },\n                                    {\n                                        \"id\": 0x86, // CodecID\n                                        \"data\": \"V_VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x258688, // CodecName\n                                        \"data\": \"VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x83, // TrackType\n                                        \"data\": 1\n                                    },\n                                    {\n                                        \"id\": 0xe0,  // Video\n                                        \"data\": [\n                                            {\n                                                \"id\": 0xb0, // PixelWidth\n                                                \"data\": videoWidth\n                                            },\n                                            {\n                                                \"id\": 0xba, // PixelHeight\n                                                \"data\": videoHeight\n                                            }\n                                        ]\n                                    }\n                                ]\n                            }\n                        ]\n                    };\n                \n                ebmlSegment = {\n                    \"id\": 0x18538067, // Segment\n                    \"size\": -1, // Unbounded size\n                    \"data\": [\n                        seekHead,\n                        segmentInfo,\n                        tracks,\n                    ]\n                };\n                \n                var\n                    bufferStream = new ArrayBufferDataStream(256);\n                    \n                writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n                blobBuffer.write(bufferStream.getAsDataArray());\n                \n                // Now we know where these top-level elements lie in the file:\n                seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n                seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n            };\n            \n            /**\n             * Create a SimpleBlock keyframe header using these fields:\n             *     timecode    - Time of this keyframe\n             *     trackNumber - Track number from 1 to 126 (inclusive)\n             *     frame       - Raw frame data payload string\n             *\n             * Returns an EBML element.\n             */\n            function createKeyframeBlock(keyframe) {\n                var\n                    bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n                \n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n                    throw \"TrackNumber must be > 0 and < 127\";\n                }\n    \n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                \n                // Flags byte\n                bufferStream.writeByte(\n                    1 << 7 // Keyframe\n                );\n                \n                return {\n                    \"id\": 0xA3, // SimpleBlock\n                    \"data\": [\n                         bufferStream.getAsDataArray(),\n                         keyframe.frame\n                    ]\n                };\n            }\n            \n            /**\n             * Create a Cluster node using these fields:\n             *\n             *    timecode    - Start time for the cluster\n             *\n             * Returns an EBML element.\n             */\n            function createCluster(cluster) {\n                return {\n                    \"id\": 0x1f43b675,\n                    \"data\": [\n                         {\n                            \"id\": 0xe7, // Timecode\n                            \"data\": Math.round(cluster.timecode)\n                         }\n                    ]\n                };\n            }\n            \n            function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n                cues.push({\n                    \"id\": 0xBB, // Cue\n                    \"data\": [\n                         {\n                             \"id\": 0xB3, // CueTime\n                             \"data\": clusterTime\n                         },\n                         {\n                             \"id\": 0xB7, // CueTrackPositions\n                             \"data\": [\n                                  {\n                                      \"id\": 0xF7, // CueTrack\n                                      \"data\": trackIndex\n                                  },\n                                  {\n                                      \"id\": 0xF1, // CueClusterPosition\n                                      \"data\": fileOffsetToSegmentRelative(clusterFileOffset)\n                                  }\n                             ]\n                         }\n                    ]\n                });\n            }\n            \n            /**\n             * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n             * The seek entry for the Cues in the SeekHead is updated.\n             */\n            function writeCues() {\n                var\n                    ebml = {\n                        \"id\": 0x1C53BB6B,\n                        \"data\": cues\n                    },\n                    \n                    cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n                \n                writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n                blobBuffer.write(cuesBuffer.getAsDataArray());\n                \n                // Now we know where the Cues element has ended up, we can update the SeekHead\n                seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n            }\n            \n            /**\n             * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n             */\n            function flushClusterFrameBuffer() {\n                if (clusterFrameBuffer.length == 0) {\n                    return;\n                }\n    \n                // First work out how large of a buffer we need to hold the cluster data\n                var\n                    rawImageSize = 0;\n                \n                for (var i = 0; i < clusterFrameBuffer.length; i++) {\n                    rawImageSize += clusterFrameBuffer[i].frame.length;\n                }\n                \n                var\n                    buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 32), // Estimate 32 bytes per SimpleBlock header\n    \n                    cluster = createCluster({\n                        timecode: Math.round(clusterStartTime),\n                    });\n                    \n                for (var i = 0; i < clusterFrameBuffer.length; i++) {\n                    cluster.data.push(createKeyframeBlock(clusterFrameBuffer[i]));\n                }\n                \n                writeEBML(buffer, blobBuffer.pos, cluster);\n                blobBuffer.write(buffer.getAsDataArray());\n                \n                addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n                \n                clusterFrameBuffer = [];\n                clusterStartTime += clusterDuration;\n                clusterDuration = 0;\n            }\n            \n            function validateOptions() {\n                // Derive frameDuration setting if not already supplied\n                if (!options.frameDuration) {\n                    if (options.frameRate) {\n                        options.frameDuration = 1000 / options.frameRate;\n                    } else {\n                        throw \"Missing required frameDuration or frameRate setting\";\n                    }\n                }\n            }\n            \n            function addFrameToCluster(frame) {\n                frame.trackNumber = DEFAULT_TRACK_NUMBER;\n                \n                // Frame timecodes are relative to the start of their cluster:\n                frame.timecode = Math.round(clusterDuration);\n    \n                clusterFrameBuffer.push(frame);\n                \n                clusterDuration += frame.duration;\n                \n                if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n                    flushClusterFrameBuffer();\n                }\n            }\n            \n            /**\n             * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n             *\n             * Call once writing is complete (so the offset of all top level elements is known).\n             */\n            function rewriteSeekHead() {\n                var\n                    seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n                    oldPos = blobBuffer.pos;\n                \n                // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n                writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);\n                \n                // And write that through to the file\n                blobBuffer.seek(seekHead.dataOffset);\n                blobBuffer.write(seekHeadBuffer.getAsDataArray());\n    \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n             */\n            function rewriteDuration() {\n                var\n                    buffer = new ArrayBufferDataStream(8),\n                    oldPos = blobBuffer.pos;\n                \n                // Rewrite the data payload (don't need to update the id or size)\n                buffer.writeDoubleBE(clusterStartTime);\n                \n                // And write that through to the file\n                blobBuffer.seek(segmentDuration.dataOffset);\n                blobBuffer.write(buffer.getAsDataArray());\n        \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Add a frame to the video. Currently the frame must be a Canvas element.\n             */\n            this.addFrame = function(canvas) {\n                if (writtenHeader) {\n                    if (canvas.width != videoWidth || canvas.height != videoHeight) {\n                        throw \"Frame size differs from previous frames\";\n                    }\n                } else {\n                    videoWidth = canvas.width;\n                    videoHeight = canvas.height;\n    \n                    writeHeader();\n                    writtenHeader = true;\n                }\n    \n                var\n                    webP = renderAsWebP(canvas, {quality: options.quality});\n                \n                if (!webP) {\n                    throw \"Couldn't decode WebP frame, does the browser support WebP?\";\n                }\n                \n                addFrameToCluster({\n                    frame: extractKeyframeFromWebP(webP),\n                    duration: options.frameDuration\n                });\n            };\n            \n            /**\n             * Finish writing the video and return a Promise to signal completion.\n             *\n             * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n             * a Blob with the contents of the entire video.\n             */\n            this.complete = function() {\n                flushClusterFrameBuffer();\n                \n                writeCues();\n                rewriteSeekHead();\n                rewriteDuration();\n                \n                return blobBuffer.complete('video/webm');\n            };\n            \n            this.getWrittenSize = function() {\n                return blobBuffer.length;\n            };\n    \n            options = extend(optionDefaults, options || {});\n            validateOptions();\n        };\n    };\n\n    window.WebMWriter = WebMWriter(ArrayBufferDataStream, BlobBuffer);\n})();\n", "import \"./vendor/webm-writer-0.2.0\";\nimport CCapture from \"ccapture.js\";\n\nexport type CapturerSettings = {\n  frameCount: number;\n  element: HTMLCanvasElement;\n  onComplete?: Function;\n};\n\nexport default class Capturer {\n  running: boolean;\n  active: boolean;\n  capture: CCapture;\n  maxFrames: number;\n  frames: number;\n  el: HTMLCanvasElement;\n  onComplete: Function;\n\n  constructor() {\n    this.active = false;\n    this.running = false;\n  }\n\n  enableCapture({ frameCount, element, onComplete }: CapturerSettings) {\n    this.active = true;\n    this.el = element;\n    this.maxFrames = frameCount;\n    this.frames = 0;\n    this.capture = new CCapture({\n      framerate: 60,\n      format: \"webm\",\n      verbose: false,\n    });\n    this.onComplete = onComplete || function () {};\n  }\n\n  captureFrame() {\n    if (this.active && !this.running) {\n      this.capture.start();\n    }\n\n    if (this.active) {\n      this.capture.capture(this.el);\n      this.frames++;\n\n      if (this.frames > this.maxFrames) {\n        this.capture.stop();\n        this.capture.save();\n        this.onComplete();\n      }\n    }\n  }\n}\n", "import Capturer, { CapturerSettings } from \"./capturer\";\n\ndeclare global {\n  interface Window {\n    enableCapture: (settings: CapturerSettings) => void;\n    captureFrame: () => void;\n  }\n}\n\nif (window) {\n  // running in a browser, attach capturer to global window object\n  const capturer = new Capturer();\n  window.enableCapture = capturer.enableCapture;\n  window.captureFrame = capturer.captureFrame;\n}\n"],
  "mappings": "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",
  "names": []
}
